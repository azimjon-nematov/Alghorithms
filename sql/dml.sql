/*Algorithms
Алгоритм поиска
- Линейный поиск
- Бинарный поиск

Алгоритм сортировки
- сортировка пузырьком
- сортировка выбором
- быстрая сортировка

Алгоритмы для работы с графами
- BFS (breadth first search)
- DFS (depth first search)
- алгоритм Дейкстры

Два указателя

Жадные алгоритмы
- Алгоритм Хаффмана
- Алгоритм Краскала

Быстрое возведение в степень C#
- Рекурсивная реализация быстрого возведения в степень
- Итерационная реализация быстрого возведения в степень
*/


INSERT INTO Topics([Name], HasChildren, ParentId, [Order])
VALUES(N'Алгоритмҳои ҷустуҷӯ', 1, NULL, 1)
	 ,(N'Алгоритмҳои ҷудокунӣ', 1, NULL, 2)
	 ,(N'Алгоритҳо барои кор бо графҳо', 1, NULL, 3)
	 ,(N'Ду нишондод', 0, NULL, 7)
	 ,(N'Алгоритмҳои хасис', 1, NULL, 5)
	 ,(N'Экспонентатсияи зуд', 1, NULL, 6)

GO

INSERT INTO Topics([Name], HasChildren, ParentId, [Order])
VALUES(N'Ҷустуҷӯи хатӣ', 0, 1, 1) --7
	 ,(N'Ҷустуҷӯи дуӣ', 0, 1, 2) --8
	 ,(N'Ҷудокунии ҳубобӣ', 0, 2, 1) --9
	 ,(N'Ҷудокунӣ аз рӯи интихоб', 0, 2, 2) --10
	 ,(N'Ҷудокунии зуд', 0, 2, 3)
	 ,(N'BFS (breadth first search)', 0, 3, 1) --12
	 ,(N'DFS (depth first search)', 0, 3, 2)
	 ,(N'Алгоритми Дейкстр', 0, 3, 3) --14
	 ,(N'Алгоритми Хаффман', 0, 5, 1)
	 ,(N'Алгоритми Краскал', 0, 5, 2) --16
	 ,(N'Алгоритми Евклид', 0, NULL, 5) --17
	 ,(N'Татбиқи рекурсивии экспонентатсияи зуд', 0, 6, 1)
	 ,(N'Татбиқи такрории экспонентатсияи зуд', 0, 6, 2) --19
	 ,(N'Манораи ханой', 0, NULL, 8) --20

GO

INSERT INTO Content(TopicId, ContentTypeId, [Data], Params, [Order])
VALUES(7, 2, N'Ҷустуҷӯи хатӣ яке аз соддатарин ва маъмултарин алгоритмҳои ҷустуҷӯи унсур дар массив мебошад. Он ҳар як унсури массивро аз аввал то пайдо шудани унсури дилхоҳ е то дидани ҳамаи унсурҳо такроран месанҷад.', NULL, 1)
	 ,(7, 4, N'https://sushrutkuchik.wordpress.com/wp-content/uploads/2020/05/linear_search.gif', NULL, 2)
	 ,(7, 2, N'Принсипи кори алгоритм хеле содда аст. Бо гузаштан аз унсурҳои массив як ба як, он ҳар як унсурро бо арзиши мақсаднок муқоиса мекунад. Агар элемент бо арзиши мақсаднок мувофиқат кунад, алгоритм индекси ин элементро бармегардонад. Агар унсур бо арзиши мақсаднок мувофиқат накунад, алгоритм ба интихоби унсурҳои зерин идома медиҳад. Агар унсури мақсаднок дар массив пайдо нашавад, алгоритм арзиши махсусеро, ки набудани онро нишон медиҳад, бармегардонад.', NULL, 3)
	 ,(7, 2, N'Намунаи код:', NULL, 4)

GO

INSERT INTO CodeLists(asd) VALUES(NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL)
,(NULL) ,(NULL) ,(NULL) ,(NULL);
SELECT * FROM CodeLists;

GO

SELECT * FROM ProgramingLanguages

GO

INSERT INTO Content(TopicId, ContentTypeId, [Data], Params, [Order], CodeListId)
VALUES(7, 6, N'', NULL, 6, 1)
	 ,(7, 2, N'Дар ин рамз функсияи `linear_search` массиви `arr` ва унсури мақсадноки `target` - ро қабул мекунад, сипас ҳар як унсури массивро интихоб мекунад ва онро бо арзиши мақсаднок муқоиса мекунад. Агар элемент бо арзиши мақсаднок мувофиқат кунад, функсия индекси онро бармегардонад. Дар акси ҳол, -1 бармегардад, ки нишон медиҳад, ки унсур ёфт нашудааст.', NULL,7, NULL)
	 ,(7, 2, N'Ҷустуҷӯи хатӣ як алгоритми оддӣ ва содда аст, аммо он метавонад барои массивҳои калон аз сабаби мураккабии вақти хаттии он бесамар бошад. Аммо, он метавонад ҳангоми ҷустуҷӯи унсурҳо дар маҷмӯаҳои хурди маълумот ё вақте ки алгоритмҳои дигар мувофиқ нестанд, муфид бошад.', NULL, 8, NULL)
	 
	 ,(15, 2, N'Алгоритми Хаффман (Huffman Algorithm) алгоритми тамаъҷӯест, ки барои сохтани рамзи префиксии оптималӣ истифода мешавад, ки аксар вақт дар фишурдани маълумот истифода мешавад. Биеед бифаҳмем, ки ин алгоритм чӣ гуна кор мекунад.', NULL, 1, NULL)
	 ,(15, 1, N'Қадамҳои асосии алгоритми Хаффман', NULL, 2, NULL)
	 ,(15, 2, N'1. Ҳисоб кардани басомади аломатҳо:', NULL, 3, NULL)
	 ,(15, 5, N'Пеш аз ҳама, басомади пайдоиши ҳар як аломат дар паем (е файл) муайян карда мешавад, ки барои он рамзи фишурда сохта мешавад.', NULL, 4, NULL)
	 ,(15, 2, N'2. Сохтани дарахти Хаффман:', NULL, 5, NULL)
	 ,(15, 5, N'Дарахти бинарӣ сохта мешавад, ки дар он ҳар як барг рамз аст ва гиреҳҳои дохилӣ ҷамъи басомади наслҳои худ мебошанд;'+char(10)+N'Дар ҳар қадам алгоритм ду гиреҳро бо басомади камтарин муттаҳид мекунад ва гиреҳи навро бо басомади умумӣ эҷод мекунад.', NULL, 6, NULL)
	 ,(15, 2, N'3. Таъини рамзҳо:', NULL, 7, NULL)
	 ,(15, 5, N'Рамзи префиксӣ (пайдарпаии битӣ) барои ҳар як рамз аз рӯи дарахт аз реша ба баргҳо сохта мешавад. Дар зери дарахти чап "0" ва дар тарафи рост "1" нишон дода шудааст;'+char(10)+N'Ба шарофати усули чашмгуруснагии сохтани дарахт, рамзҳои дарозии тағйиребанда аксар вақт истифода мешаванд. Аксар вақт рамзҳои кӯтоҳтар ба рамзҳои бештар таъин карда мешаванд.', NULL, 8, NULL)
	 ,(15, 2, N'4. Фишурдани маълумот:', NULL, 9, NULL)
	 ,(15, 5, N'Паем (е файл) бо версияи фишурда иваз карда мешавад, ки дар он ҳар як рамз бо рамзи префиксии мувофиқ иваз карда мешавад;'+char(10)+N'Ин ба шумо имкон медиҳад, ки маълумотро бо истифода аз битҳои камтар пешниҳод кунед, агар рамзҳои зуд-зуд рамзҳои кӯтоҳтар дошта бошанд.', NULL, 10, NULL)
	 ,(15, 6, N'', NULL, 11, 3)
	 ,(15, 2, N'Алгоритми Хаффман имкон медиҳад, ки маълумотро дар асоси басомади рамзҳо дар паем самаранок фишурда шавад. Он воситаи калидӣ дар фишурдани маълумот мебошад ва дар технологияҳои фишурдани файл, бойгонӣ, протоколҳои шабакавӣ ва дигар соҳаҳо васеъ истифода мешавад.', NULL, 12, NULL)
	 
	 ,(8, 2, N'Ҷустуҷӯи дуӣ алгоритми самараноки ҷустуҷӯи унсур дар массиви мураттабшуда мебошад. Он тавассути тақсим кардани массив ва муқоисаи унсури дилхоҳ бо унсури мобайни массив кор мекунад. Агар унсури ҷустуҷӯшаванда ба унсури миёнаи массив баробар бошад, ҷустуҷӯ ба анҷом мерасад. Агар унсури ҷустуҷӯшаванда аз унсури миёнаи массив хурдтар бошад, ҷустуҷӯ дар нимаи чапи массив идома меёбад. Агар унсури ҷустуҷӯшаванда аз унсури миёнаи массив калонтар бошад, ҷустуҷӯ дар нимаи рости массив идома меёбад. Ин раванд то пайдо шудани унсури ҷустуҷӯшуда ё то дар массив боқӣ мондани як унсур такрор мешавад.', NULL, 1, NULL)
	 ,(8, 4, N'https://media.proglib.io/posts/2022/11/21/1cf3b4ed69a54149b52f817571bd3d81.gif', NULL, 2, NULL)
	 ,(8, 2, N'Принсипи кори алгоритм чунин аст: дар ҳар як итерасия ҷустуҷӯи дуӣ андозаи диапазони ҷустуҷӯро ду баробар кам мекунад. Ин ба шумо имкон медиҳад, ки ҷустуҷӯро ба як адад кам мекунад.', NULL, 3, NULL)
	 ,(8, 2, N'Намуна код:', NULL, 4, NULL)
	 ,(8, 6, N'', NULL, 5, 4)
	 
	 ,(9, 2, N'Ҷобаҷогузории ҳубобӣ яке аз алгоритмҳои машҳури ҷобаҷогузорӣ мебошад. Дар ин ҷо шумо бояд арзишҳои унсурҳои ҳамсояро пай дар пай муқоиса кунед ва рақамҳоро бо ҷойҳо иваз кунед, агар пештара аз охирин калонтар бошад. Ҳамин тариқ, унсурҳои дорои арзишҳои калон дар охири рӯйхат ва бо арзишҳои хурдтар дар аввал боқӣ мемонанд.', NULL, 1, NULL)
	 ,(9, 4, N'https://yastatic.net/s3/education-portal/media/1_49e0bb0f63_63adb81133.gif', NULL, 2, NULL)
	 ,(9, 2, N'Ин алгоритм омӯзишӣ ҳисобида мешавад ва аз сабаби самаранокии паст қариб дар амал татбиқ карда намешавад: он оҳиста дар санҷишҳое кор мекунад, ки дар онҳо унсурҳои хурд (онҳоро черепахами меноманд) дар охири массив истодаанд. Аммо, бисер усулҳои дигар ба он асос ефтаанд, ба монанди ҷобаҷогузории ларзиш ва ҷобаҷогузории шона.', NULL, 3, NULL)
	 ,(9, 6, N'', NULL, 4, 5)
	 ,(9, 7, N'Бояд қайд кард, ки мураккабии муваққатии ин алгоритми O(n^2).', NULL, 5, NULL)
	 
	 ,(10, 2, N'Аввалан, шумо бояд зергурӯҳи массивро баррасӣ кунед ва дар он ҳадди аксар (е ҳадди аққал) пайдо кунед. Сипас арзиши интихобшуда бо арзиши унсури якуми ҷудонашуда иваз карда мешавад. Ин қадам бояд то ба охир расидани зермассивҳои ҷудонашуда дар массив такрор карда шавад.', NULL, 1, NULL)
	 ,(10, 4, N'https://yastatic.net/s3/education-portal/media/184_9_b67b9a57f4_deb9de7372.gif', NULL, 2, NULL)
	 ,(10, 6, N'', NULL, 3, 6)
	 ,(10, 7, N'мураккабии муваққатии ин алгоритми O(n^2).', NULL, 4, NULL)
	 
	 ,(11, 2, N'Ин алгоритм аз се марҳила иборат аст. Аввалан, шумо бояд як унсурро аз массив интихоб кунед-онро одатан дастгирӣ меноманд. Сипас унсурҳои дигари массивро тавре тақсим мекунанд, ки унсурҳои камтар аз унсурҳои такягоҳ пеш аз он ва калон е баробар пас аз он бошанд. Ва минбаъд ду қадами аввалро ба зермассивҳои рост ва чапи арзиши такягоҳ рекурсивӣ истифода мебаранд.', NULL, 1, NULL)
	 ,(11, 4, N'https://yastatic.net/s3/education-portal/media/184_11_3c7583c6cd_59878a71a8.gif', NULL, 2, NULL)
	 ,(11, 2, N'Ҷамъбасти зудро соли 1960 барои тарҷумаи мошинӣ ихтироъ карданд: он вақт луғатҳо дар лентаҳои магнитӣ нигоҳ дошта мешуданд ва ҷамъбасти калимаҳои матни коркардшуда имкон медод, ки тарҷумаҳоро дар як пешбурди лента бидуни бозгашт ба даст оранд.', NULL, 3, NULL)
	 ,(11, 6, N'', NULL, 4, 7)
	 ,(11, 7, N'мураккабии муваққатии ин алгоритми O(n^2).', NULL, 5, NULL)

	 ,(12, 2, N'BFS, ё Breadth First Search алгоритми канори граф дар паҳнои. Граф ин сохтори "қуллаҳо" ва "канорҳо" мебошад, ки қуллаҳоро бо ҳам мепайвандад. Дар канори он аз як қулла ба қуллаи дигар ҳаракат кардан мумкин аст ВА BFS ин корро сатҳӣ мекунад: аввал аз тамоми қуллаҳои наздиктарин аз нуқтаи ибтидоӣ мегузарад, сипас чуқуртар поен меравад.', NULL, 1, NULL)
	 ,(12, 2, N'Чунин ба назар мерасад: алгоритм дар қуллаи пешакӣ интихобшуда оғоз меебад ва аввал "ташриф меорад" ва ҳамаи ҳамсояҳои ин қулларо қайд мекунад. Сипас он ба ҳамсояҳои қуллаҳои ташриф овардашуда мегузарад, сипас минбаъд бо ҳамон принсип. Аз сабаби хусусияти паҳншавии ба мавҷ монанд, алгоритмро мавҷӣ низ меноманд. BFS яке аз ду алгоритми маъмули гузариш аст. Дуюм DFS ном дорад ва ба чуқурӣ гузаштанро дар назар дорад: аввал алгоритм аз канори граф ба чуқурӣ мегузарад.', NULL, 2, NULL)
	 ,(12, 1, N'BFS барои чӣ лозим', NULL, 3, NULL)
	 ,(12, 5, N'Барои ҳалли масъалаҳои ҷустуҷӯи роҳи оптималӣ. Вазифаи классикӣ ҷустуҷӯи автоматикунонидашудаи баромадан аз лабиринт ҳисобида мешавад.'+char(10)+N'Барои ҳалли масъалаҳои бевосита бо назарияи графҳо алоқаманд, масалан барои ҷустуҷӯи ҷузъи пайвастшавӣ. Ин масъалаҳо дар навбати Худ дар илми Маълумот, назарияи шабакаҳо ва электроника ҳал карда мешаванд.'+char(10)+N'Барои масъалаҳои зеҳни сунъӣ, ки бо ҷустуҷӯи ҳалли камтарин ҳаракатҳо алоқаманданд. Дар ин ҳолат ҳолати "мошини оқил" ҳамчун қуллаҳо ва гузаришҳо байни онҳо ҳамчун канораҳо ифода карда мешаванд.'+char(10)+N'Барои оптимизатсияи хотира ҳангоми гузаштан аз граф дар баъзе ҳолатҳо, масалан барои баъзе сохторҳои мушаххас.'+char(10)+N'Барои кор бо иттилоот дар сохторҳои муайяни маълумот, ба монанди дарахтон. Онҳоро низ бо алгоритми BFS убур кардан мумкин аст, зеро онҳо зергурӯҳи графҳо мебошанд.', NULL, 4, NULL)
	 ,(12, 1, N'Хусусиятҳои BFS', NULL, 5, NULL)
	 ,(12, 5, N'Шумораи доимии амалҳо барои ҳар як канор е қулла. Ин ҳангоми ҳисоб кардани мураккабии алгоритм ҳангоми интихоби усули оптималии ҳалли ин е он масъала муҳим аст.'+char(10)+N'Набудани мушкилоти "сикли беохир": алгоритм бо сабаби хусусиятҳои корӣ дар ягон шароит ба он дохил намешавад.'+char(10)+N'Дақиқии баланд ва меъмории боэътимод, ки ба шумо имкон медиҳад, ки ба ин алгоритм барои ҳалли масъалаҳои гуногун такя кунед.'+char(10)+N'Қобилияти кор кардан бо графҳои нигаронидашуда ва ғайримутамарказ. Дар бораи он, ки онҳо аз ҳам фарқ мекунанд, дар мақола дар бораи графикаи нигаронидашуда хондан мумкин аст.'+char(10)+N'Пуррагии алгоритм он ҳалли худро меебад, яъне роҳи кӯтоҳтаринро пайдо мекунад ва дар ҳар графаи ниҳоӣ ба анҷом мерасад. Агар граф беохир бошад, ҳалли он танҳо дар сурате пайдо мешавад, ки агар ягон роҳи он ниҳоӣ бошад.'+char(10)+N'Имконияти пайдо кардани роҳи кӯтоҳтарин дар граф, агар ҳамаи канораҳо дарозии якхела дошта бошанд. Агар дарозии қабурғаҳо гуногун бошанд, BFS роҳи камтарини қабурғаҳоро пайдо мекунад, аммо он ҳатман кӯтоҳтарин нахоҳад буд. Барои ҷустуҷӯи роҳи кӯтоҳтарин дар ин ҳолат алгоритми Дейкстра беҳтар хоҳад буд.', NULL, 6, NULL)
	 ,(12, 1, N'Алгоритми BFS чӣ гуна кор мекунад', NULL, 7, NULL)
	 ,(12, 2, N'Алгоритм оддӣ ва беихтиерона аст. Он аз болои қуллаҳои граф мегузарад, то он даме ки қуллаҳои ташриф наоварда боқӣ монанд ва роҳи кӯтоҳтаринро то қуллаи мақсаднок ҳисоб мекунад. Барои ба таври равшантар нишон додани кори он, алгоритмро зина ба зина муаррифӣ мекунем.', NULL, 8, NULL)
	 ,(12, 2, N'Оғози кор. Шумо метавонед ҳар як қулларо ҳамчун қуллаи ибтидоӣ интихоб кунед. Дар лаҳзаи оғози кори алгоритм, ҳамаи қуллаҳо ҳамчун ташриф наоварда қайд карда шудаанд онҳоро сафед меноманд. Аввалин чизе, ки алгоритм мекунад, ин аст, ки қуллаи ибтидоиро ҳамчун ташриф овардашуда қайд мекунад (инчунин истилоҳоти кушода е хокистарӣ истифода мешаванд). Агар он мақсаднок бошад, ин алгоритмро ба анҷом мерасонад. Аммо аксар вақт ин тавр нест.', NULL, 9, NULL)
	 ,(12, 2, N'Ҷустуҷӯи ҳамсояҳо. Алгоритм месанҷад, ки кадом ҳамсояҳо дар қуллаи ибтидоӣ ҳастанд. Онҳо ба "навбати амалҳо" бо тартиби алгоритме, ки онҳоро пайдо кардааст, илова карда мешаванд ва инчунин ҳамчун "сабз"қайд карда мешаванд. Ин то он даме идома меебад, ки дар қуллаи ибтидоӣ ҳамсояҳои "сафед" боқӣ монанд.', NULL, 10, NULL)
	 ,(12, 2, N'Гузариш ба қуллаи навбатӣ. Вақте ки алгоритм аз тамоми ҳамсояҳои қуллаи ибтидоӣ мегузарад, он онро пурра аз байн мебарад. Чунин қуллаҳоро "сиеҳ" низ меноманд: алгоритм ба онҳо барнамегардад. Сипас он ба яке аз қуллаҳои "хокистарӣ" — и ҳамсояҳои ибтидоӣ мегузарад. Алгоритм қуллаи аввалро дар навбат интихоб мекунад. Сипас амалҳо такрор мешаванд:" ҳамсояҳо "- и қулла, ба ғайр аз" сиеҳ", ба навбат ворид карда мешаванд.', NULL, 12, NULL)
	 ,(12, 2, N'Вақте ки ин қулла низ аз он мегузарад, гузариш бо ҳамон принсип такрор мешавад — қуллаи аввал дар навбат. Дар ин ҳолат, он ҳамсояи дуюми қуллаи ибтидоӣ хоҳад буд-мо дар хотир дорем, ки онҳо аввал ба навбат илова карда шуданд. Ва танҳо вақте ки ҳамсояҳои қуллаи ибтидоӣ дар навбат ба охир мерасанд, алгоритм аз рӯи "сатҳи" қуллаҳои навбатӣ мегузарад. Ҳамин тавр, ба паҳноии он роҳ дода мешавад.', NULL, 13, NULL)
	 ,(12, 2, N'Охири алгоритм. Агар навбат холӣ бошад, ин маънои онро дорад, ки қуллаҳои "сафед" ва "сафед" дигар боқӣ намондаанд. Алгоритм ба охир мерасад. Агар дар ин ҳолат қуллаи мақсаднок ба даст наояд, ин маънои онро дорад, ки ба он аз нуқтаи ибтидоӣ дастрасӣ вуҷуд надорад.', NULL, 14, NULL)
	 ,(12, 2, N'Агар қуллаи мақсаднок пеш аз он ки алгоритм аз тамоми граф гузарад, ба даст оварда шавад, ин метавонад маънои онро дошта бошад, ки он ба анҷом мерасад. Алгоритм қатъ мешавад, зеро вазифа иҷро мешавад: роҳи кӯтоҳтарин ба болои ҳадаф пайдо мешавад.', NULL, 15, NULL)
	 ,(12, 6, N'', NULL, 16, 8)


	 
	 ,(17, 1, N'Алгоритми Евклид: дарефти бузургтарин тақсимкунандаи умумӣ', NULL, 1, NULL)
	 ,(17, 2, N'Алгоритми Эвклид яке аз алгоритмҳои қадимтарин ва самараноктарин барои ёфтани калонтарин тақсимкунандаи умумии (КТУ) ду рақам мебошад. Дар тӯли асрҳо он яке аз воситаҳои асосии математикӣ боқӣ мемонад ва дар бисёр соҳаҳо, аз ҷумла алгебра, криптография, информатика ва ғайра истифода мешавад.', NULL, 2, NULL)
	 ,(17, 2, N'Алгоритм ба номи математики юнони қадим Эвклид номгузорӣ шудааст, ки онро дар рисолаи худ "Оғоз" тасвир кардааст, ки тақрибан соли 300 то милод навишта шудааст. соддагӣ ва самаранокии он онро махсусан барои истифода дар вазифаҳои гуногун ҷолиб месозад.', NULL, 3, NULL)
	 ,(17, 2, N'Принсипи кори алгоритми Эвклид ба идеяи оддӣ асос ёфтааст: агар a аз b калонтар бошад, пас КТУ a ва b ба КТУ b ва a mod b баробар аст, ки дар он mod амалиети гирифтани боқимондаи тақсимотро ифода мекунад. Ин раванд такрор мешавад, то яке аз рақамҳо ба 0 баробар шавад. Вақте ки яке аз ададҳо ба 0 баробар мешавад, адади боқимонда бузургтарин тақсимкунандаи умумии ададҳои ибтидоӣ хоҳад буд.', NULL, 4, NULL)
	 ,(17, 2, N'Намунаи код барои татбиқи алгоритми Эвклид:', NULL, 5, NULL)
	 ,(17, 6, N'', NULL, 6, 2)
	 ,(17, 2, N'Дар ин мисол, функсияи `euclidean_algorithm` ду рақами `a` ва` b` - ро ба вуруд қабул мекунад ва алгоритми Эвклидро барои ефтани тақсимкунандаи умумии калонтарини Онҳо истифода мебарад. То он даме, ки рақами дуюм ба 0 баробар шавад, он бо боқимондаи тақсимоти рақами аввал ба рақами дуюм иваз карда мешавад. Ин раванд то он даме идома меебад, ки яке аз рақамҳо ба 0 баробар шавад ва адади боқимонда бузургтарин тақсимкунандаи умумӣ бошад.', NULL, 7, NULL)
	 ,(17, 2, N'Алгоритми Эвклид яке аз усулҳои самаранок ва универсалии ефтани тақсимкунандаи умумии калонтарин мебошад ва қисми ҷудонопазири арсенали математикӣ боқӣ мемонад.', NULL, 8, NULL)

	 
	 ,(20, 1, N'Манораи ханой: Машқ ва якчанд роҳҳои татбиқ', NULL, 1, NULL)
	 ,(20, 2, N'Бурҷи ханой як мушкили классикӣ аст, ки аксар вақт барои таълим ва нишон додани принсипҳои рекурсия истифода мешавад. Вазифа аз он иборат аст, ки стеки дискҳои диаметри гуногунро аз як асо ба асои дигар бо истифода аз асои сеюм ҳамчун мобайнӣ интиқол диҳед, ба шарте ки дар ҳар як қадам танҳо як дискро интиқол додан мумкин бошад ва диски калонтар ҳеҷ гоҳ дар болои диски хурдтар ҷойгир карда нашавад.', NULL, 2, NULL)
	 ,(20, 2, N'Принсипи кори вазифаи бурҷи Ханой ба қадри кофӣ содда аст: барои интиқол додани стеки дискҳо аз як асо ба асои дигар, мо аввал дискҳои болоии `n-1`-ро ба асои мобайнӣ интиқол медиҳем, сипас диски калонтаринро ба асои ҳадаф интиқол медиҳем ва дар ниҳоят дискҳои `n-1` - ро аз асои мобайнӣ ба асои ҳадаф интиқол медиҳем. Ин раванд барои ҳар як пойгоҳи диск рекурсивӣ такрор карда мешавад, то он даме ки ҳамаи дискҳо ба асои ҳадаф интиқол дода шаванд.', NULL, 3, NULL)
	 ,(20, 1, N'Усули 1: ҳалли рекурсивӣ', NULL, 4, NULL)
	 ,(20, 2, N'Намунаи рамзи барои ҳалли рекурсивии масъалаи Манораи Ханой:', NULL, 5, NULL)
	 ,(20, 6, N'', NULL, 6, 9)
	 ,(20, 2, N'Усули 2: ҳалли такрорӣ', NULL, 7, NULL)
	 ,(20, 2, N'Намунаи рамзи барои ҳалли такрории масъалаи манораи Ханой:', NULL, 8, NULL)
	 ,(20, 6, N'', NULL, 9, 10)
	 ,(20, 2, N'Ҳарду роҳи ҳалли масъалаи Манораи Ханой самаранок буда, принсипҳои рекурсия ва итерасияро нишон медиҳанд. Интихоби усул аз афзалиятҳо ва талаботи мушаххаси лоиҳаи шумо вобаста аст.', NULL, 10, NULL)
	 
	 ,(19, 1, N'Татбиқи такрории экспонентатсияи зуд', NULL, 1, NULL)
	 ,(19, 2, N'Экспонентатсияи зуд усулест, ки ба шумо имкон медиҳад, ки арзиши рақами ба дараҷа бардошташударо самаранок ҳисоб кунед. Баръакси усули рекурсивӣ, татбиқи итеративӣ ба даври итеративӣ асос ёфтааст, ки рақамро ба худ пай дар пай зарб мекунад, то он даме ки ба дараҷаи зарурӣ мерасад.', NULL, 1, NULL)
	 ,(19, 2, N'Принсипи кори татбиқи итеративии экспонентатсияи зуд оддӣ аст: мо бо натиҷаи баробар ба 1 оғоз мекунем ва сипас онро пай дар пай ба пойгоҳ зарб карда, нишондиҳандаи дараҷаро дар ҳар қадам дучанд мекунем. Ин ба мо имкон медиҳад, ки шумораи амалиетҳои барои ҳисоб кардани дараҷа заруриро кам кунем.', NULL, 2, NULL)
	 ,(19, 2, N'Намунаи код:', NULL, 3, NULL)
	 ,(19, 6, N'', NULL, 4, 11)
	 ,(19, 2, N'Дар ин рамз функсияи `power` асоси `base` ва нишондиҳандаи дараҷаи `exponent` - ро ба вуруд қабул мекунад, сипас натиҷаи ба дараҷа баровардани рақамро итеративӣ ҳисоб мекунад. То он даме, ки нишондиҳанда аз 0 зиед аст, мо месанҷем, ки он ҷуфт ё тоқ аст. Агар он баробар бошад, мо асосро ба худ зарб мекунем ва нишондиҳандаро ду баробар кам мекунем. Агар он тоқ бошад, натиҷаро ба пойгоҳ зарб кунед ва нишондиҳандаро ба 1 кам кунед. Ин раванд то ба 0 баробар шудани нишондиҳанда такрор мешавад.', NULL, 5, NULL)
	 ,(19, 2, N'Татбиқи итеративии экспонентатсияи зуд усули муассир ва ба осонӣ фаҳмо барои кор бо ҳисоб кардани дараҷа мебошад.', NULL, 6, NULL)


	 
	 ,(16, 2, N'Алгоритми Краскал (Kruskals Algorithm) ин алгоритми ефтани дарахти ҳадди ақали сутун дар графаи пайвастаи тарозу мебошад. Дарахти остии оптималӣ ин зерграфи графи ибтидоӣ мебошад, ки ҳамаи қуллаҳоро дар бар мегирад, ки аз рӯи вазни канори он ҳадди ақал аст.', NULL, 1, NULL)
	 ,(16, 1, N'Ин аст алгоритми Краскал чӣ гуна кор мекунад:', NULL, 2, NULL)
	 ,(16, 2, N'Қадамҳои асосии алгоритми Краскал:', NULL, 3, NULL)
	 ,(16, 2, N'1. Оғози кор:', NULL, 4, NULL)
	 ,(16, 5, N'Мо ҷангал месозем, ки дар он ҳар як қуллаи граф дарахти алоҳида аст.', NULL, 5, NULL)
	 ,(16, 2, N'2. Ҷобаҷогузории қабурғаҳо:', NULL, 6, NULL)
	 ,(16, 5, N'Канори граф аз рӯи афзоиши вазнҳо ҷудо карда мешавад.', NULL, 7, NULL)
	 ,(16, 2, N'3. Якҷоя кардани дарахтон:', NULL, 8, NULL)
	 ,(16, 5, N'Қабурғаҳои вазни ҳадди ақал пай дар пай интихоб карда мешаванд.'+char(10)+N'Агар илова кардани қабурға дар дарахти пояи ҷорӣ даврае ба вуҷуд наорад, он ба поя илова карда мешавад. Алгоритми ҷустуҷӯи амиқ е равиши дигарро барои санҷиши давра истифода бурдан мумкин аст.', NULL, 9, NULL)
	 ,(16, 2, N'4. Такрор:', NULL, 10, NULL)
	 ,(16, 5, N'Қадамҳои 3 такрор мешаванд, то ҳама қуллаҳо баста шаванд ва дарахти камтарин пурра бошад.', NULL, 12, NULL)
	 ,(16, 2, N'Алгоритми Краскал усули самараноки пайдо кардани дарахти ҳадди ақали сутун дар граф аст. Он дар соҳаҳои гуногун васеъ истифода мешавад, ки дар он ҷо бояд зергурӯҳи оптималии дарахтро бо арзиши ҳадди ақали умумӣ пайдо кард.', NULL, 13, 12)

	 
	 ,(13, 2, N'DFS, ё Depth First Search, ҷустуҷӯи чуқурӣ, ки ба шумо имкон медиҳад, ки хатсайрро аз нуқтаи A то нуқтаи B пайдо кунед.Дар графҳои сохторҳои махсус, ки аз нуқтаҳои қуллаҳо ва канори роҳҳо иборат Мебошанд, Истифода Мешавад. DFS дар ҷустуҷӯи хатсайри графикӣ ба чуқурӣ аст: дар ҳар қадам дуртар меравад.', NULL, 1, NULL)
	 ,(13, 2, N'Намунаи классикии истифодаи алгоритм ҷустуҷӯи роҳи тасодуфӣ дар лабиринт. DFS корро дар нуқтаи додашуда оғоз мекунад, дар ҳар қадам аз лабиринт то гардиши навбатӣ мегузарад ва самтро интихоб мекунад. Агар роҳ сарбаста бошад, алгоритм ба гардиши қаблӣ бармегардад ва самти навро меозмояд. Дар натиҷа, дер е зуд роҳи дуруст аст.', NULL, 2, NULL)
	 ,(13, 4, N'https://blog.skillfactory.ru/wp-content/uploads/2023/02/dfs_maze-8816737.gif', NULL, 3, NULL)
	 ,(13, 1, N'Принсипи гузариши граф ба чуқурӣ', NULL, 4, NULL)
	 ,(13, 2, N'Мо алгоритми рекурсивии стандартии гузаришро дида мебароем. Дар бораи татбиқи ғайримуқаррарӣ дар зер сӯҳбат хоҳем кард: якчанд ҳастанд ва ҳар яки онҳо хусусиятҳои худро доранд. Принсипи стандартиро фаҳмидан хеле осон аст ва татбиқи он осон аст.', NULL, 5, NULL)
	 ,(13, 4, N'https://blog.skillfactory.ru/wp-content/uploads/2023/02/dfs-1-8650838.png', NULL, 6, NULL)
	 ,(13, 2, N'Қадами аввал. Вақте ки алгоритм ба кор шурӯъ мекунад, ҳамаи қуллаҳо "сафед" ҳисобида мешаванд, ки ба он ташриф намеоранд. DFS роҳро дар қуллаи пешакӣ муайяншудаи v оғоз мекунад ва бояд аз он ба қуллаи дигари додашуда роҳ ебад е харитаи графро пурра тартиб диҳад.', NULL, 7, NULL)
	 ,(13, 2, N'Аввалин чизе, ки DFS мекунад, ранг кардани болои он аст, ки дар он хокистарӣ аст. Ин нишон медиҳад, ки алгоритм аллакай дар он буд. пас аз он DFS ҳамсоягонро месанҷад-қуллаҳое, ки ба он ҷое, ки он ҷойгир аст, пайвастанд.', NULL, 8, NULL)
	 ,(13, 2, N'Гузариш. Агар яке аз қуллаҳои ҳамсоя сафед бошад, алгоритм ба он мегузарад ва ҳамон амалҳоро такрор мекунад: ба хокистарӣ ранг мекунад, ҳамсояҳоро меҷӯяд. Ин на ба таври даврӣ, балки ба таври рекурсивӣ сурат мегирад: агар DFS-ро ҳамчун функсия муаррифӣ кунем, пас ин функсия дар рафти иҷро худашро ба вуҷуд меорад, аммо барои қуллаи дигар. Аз ин рӯ, алгоритм аввал бо як ҳамсояи интихобшуда кор мекунад ва танҳо дар сурати ба бунбаст афтодан, бармегардад ва кӯшиш мекунад, ки роҳи дигарро тай кунад.', NULL, 9, NULL)
	 ,(13, 2, N'Интихоби ҳамсоя тасодуфан е бо меъерҳои пешакӣ муайяншуда сурат мегирад-масалан, он метавонад қуллаи чаптарин е росттарин бошад. Дар боло мо "қоидаи дасти чап" - ро зикр кардем: он аслан чунин меъер аст.', NULL, 10, NULL)
	 ,(13, 2, N'Агар дар болои он ҳамсояҳои номаълум боқӣ намонанд, он ҳамчун пурра ташриф овардашуда сиеҳ ранг карда мешавад.', NULL, 11, NULL)
	 ,(13, 2, N'Анҷом додани гардиш. Алгоритм агар ба нуқтаи зарурӣ бирасад, ба анҷом мерасад. Дар ин ҳолат, ҳамаи "намунаҳои" функсияҳои даъватшуда ба таври навбатӣ ба анҷом мерасанд: аз охирин то аввалин даъватшуда. Агар вазифа пурра аз болои граф гузарад, пас меъери ба итмом расонидани графи дигар: ҳамаи қуллаҳо бояд сиеҳ шаванд.', NULL, 12, NULL)
	 ,(13, 1, N'Чӣ тавр амалӣ кардани алгоритми DFS', NULL, 13, NULL)
	 ,(13, 2, N'Соддатарин татбиқи рекурсивӣ сохтани граф дар шакли рӯйхати алоқаманд е сохтори дигари маълумот ва сипас навиштани функсия барои гузаштан аз он мебошад. Чӣ тавр амалӣ кардани худи граф аз забони барномасозӣ вобаста аст: одатан намудҳое истифода мешаванд, ки ба нигоҳ доштани арзишҳои гуногун имкон медиҳанд. Ҳар як унсури чунин навъи комплексӣ қулла аст ва дар дохили қулла истинодҳо ба унсурҳои дигар е рақамҳои онҳо нигоҳ дошта мешаванд ҳамин тавр роҳҳо амалӣ карда мешаванд.', NULL, 14, NULL)
	 ,(13, 2, N'Худи функсия, ки шартан DFS (v) номида мешавад, хеле оддӣ аст ва аз рӯи мантиқи зерин амал мекунад.', NULL, 15, NULL)
	 ,(13, 5, N'Ба даромадгоҳ қуллаи сафед v ворид мешавад.'+char(10)+N'Дар болои v ранги хокистарӣ дорад.'+char(10)+N'Қуллаи w, ки бо v ва сафед ҳамсоя аст, ҷустуҷӯ карда мешавад.'+char(10)+N'Аз дохили DFS (v) dfs (w) рекурсивӣ даъват карда мешавад.'+char(10)+N'Вақте ки функсия ба итмом мерасад, болои v сиеҳ ранг карда мешавад.', NULL, 16, NULL)
	 ,(13, 2, N'"Рангкунӣ" метавонад бо ерии ягон тағиребанда дар дохили қулла амалӣ карда шавад: масалан, арзиши 0 сафед, 1 хокистарӣ ва ғайра', NULL, 17, NULL)
	 ,(13, 6, N'', NULL, 18, 13)

	 
	 ,(18, 1, N'Татбиқи рекурсивии экспонентатсияи зуд', NULL, 1, NULL)
	 ,(18, 2, N'Экспонентатсияи зуд роҳи самараноки зуд ҳисоб кардани арзиши рақами ба дараҷа бардошташуда мебошад. Татбиқи рекурсивии ин алгоритм ба идеяи оддӣ асос ефтааст: агар мо хоҳем, ки рақами а-ро ба дараҷаи n гузорем, мо метавонем n-ро ба ду тақсим кунем ва а-ро ба дараҷаи n/2 ҳисоб кунем ва сипас натиҷаи бадастомадаро квадрат кунем. Ин раванд то расидан ба дараҷаи 1 такрор мешавад.', NULL, 2, NULL)
	 ,(18, 2, N'Намунаи код:', NULL, 3, NULL)
	 ,(18, 6, N'', NULL, 4, 14)
	 ,(18, 2, N'Дар ин код функсияи `power` асоси `base` ва нишондиҳандаи дараҷаи `exponent` - ро қабул мекунад, сипас натиҷаи ба дараҷа баровардани рақамро рекурсивӣ ҳисоб мекунад. Агар нишондиҳанда 0 бошад, функсия 1-ро бармегардонад. Агар нишондиҳанда ҷуфт бошад, функсия арзиши base^{exponent/2} - ро ҳисоб мекунад ва онро квадрат мекунад. Агар нишондиҳанда ночиз бошад, функсия арзиши base^{(exponent-1)/2} - ро ҳисоб мекунад ва онро ба асос зарб мекунад. Ин раванд то расидан ба ҳолати асосӣ, ки нишондиҳандаи дараҷа 0 аст, такрор мешавад.', NULL, 5, NULL)
	 ,(18, 2, N'Татбиқи рекурсивии экспонентатсияи зуд роҳи самараноки ҳисоб кардани дараҷа мебошад, алахусус ҳангоми кор бо нишондиҳандаҳои калон.', NULL, 6, NULL)



	 --,(18, 2, N'', NULL, 1, NULL)

GO

INSERT INTO CodeInLang(CodeListId, LanguageId, Code)
VALUES(1, 1, N'def linear_search(arr, target):'+char(10)+N'    for i in range(len(arr)):'+char(10)+N'        if arr[i] == target:'+char(10)+N'            return i'+char(10)+N'    return -1'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'arr = [10, 20, 30, 40, 50]'+char(10)+N'target = 30'+char(10)+N'result = linear_search(arr, target)'+char(10)+N'if result != -1:'+char(10)+N'    print("Элементи", target, "ёфта шуд дар индекси", result)'+char(10)+N'else:'+char(10)+N'    print("Элементи", target, "ёфта нашуд")')
,(1, 2, '#include <iostream>'+char(10)+N'using namespace std;'+char(10)+N'int main() {'+char(10)+N'    int arr[7] = { 1, 3, 5, 7, 9, 11, 13 };'+char(10)+N'    int target = 7, result = -1;'+char(10)+N'    for(int i=0; i < 7; i++) {'+char(10)+N'        if(arr[i] == target) {'+char(10)+N'            result = i;'+char(10)+N'            cout << "Элемент найден в позиции " << i << ".";'+char(10)+N'            break;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    if(result != -1)'+char(10)+N'        cout << "Элемент ёфта шуд дар индекси " << i << ".";'+char(10)+N'    else'+char(10)+N'        cout << "Элемент ёфта нашуд.";'+char(10)+N'}')

,(2, 1, N'def euclidean_algorithm(a, b):'+char(10)+N'    while b != 0:'+char(10)+N'        a, b = b, a % b'+char(10)+N'    return a'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'num1 = 48'+char(10)+N'num2 = 18'+char(10)+N'gcd = euclidean_algorithm(num1, num2)'+char(10)+N'print("Калонтарин тақсимкунандаи умумии рақамҳои", num1, "ва", num2, "бароюар аст ба", gcd)')
--,(2, 2, N'')

,(3, 1, N'import heapq'+char(10)+'from collections import defaultdict'+char(10)+''+char(10)+'def huffman_coding(freq):'+char(10)+'    heap = [[weight, [symbol, ""]] for symbol, weight in freq.items()]'+char(10)+'    heapq.heapify(heap)'+char(10)+'    while len(heap) > 1:'+char(10)+'        lo = heapq.heappop(heap)'+char(10)+'        hi = heapq.heappop(heap)'+char(10)+'        for pair in lo[1:]:'+char(10)+'            pair[1] = "0" + pair[1]'+char(10)+'        for pair in hi[1:]:'+char(10)+'            pair[1] = "1" + pair[1]'+char(10)+'        heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])'+char(10)+'    return sorted(heapq.heappop(heap)[1:], key=lambda p: (len(p[-1]), p))'+char(10)+''+char(10)+N'# Пример использования'+char(10)+'data = "hello"'+char(10)+'freq = defaultdict(int)'+char(10)+'for symbol in data:'+char(10)+'    freq[symbol] += 1'+char(10)+'huff_codes = huffman_coding(freq)'+char(10)+N'print("Символ\tЧастота\tКод Хаффмана")'+char(10)+'for symbol, f in freq.items():'+char(10)+'    code = [x[1] for x in huff_codes if x[0] == symbol][0]'+char(10)+'    print(f"{symbol}\t{f}\t{code}")')

,(4, 1, N'def binary_search(arr, target):'+char(10)+N'    # Оғози сарҳади чап ва рости массив'+char(10)+N'    left, right = 0, len(arr) - 1'+char(10)+N'    # То сарҳади чап аз сарҳади рост зиёд набошад'+char(10)+N'    while left <= right:'+char(10)+N'        # Индекси миёнаи массивро пайдо мекунад'+char(10)+N'        mid = (left + right) // 2'+char(10)+N'        # Агар унсури миёна ба унсури мақсаднок баробар бошад, индекси онро бармегардонем'+char(10)+N'        if arr[mid] == target:'+char(10)+N'            return mid'+char(10)+N'        # Агар унсури миена аз ҳадаф хурдтар бошад, ҷустуҷӯро ба нимаи рости массив кам кунед'+char(10)+N'        elif arr[mid] < target:'+char(10)+N'            left = mid + 1'+char(10)+N'        # Агар унсури миена аз ҳадаф калонтар бошад, майдони ҷустуҷӯро ба нимаи чапи массив танг кунед'+char(10)+N'        else:'+char(10)+N'            right = mid - 1'+char(10)+N'    # Агар элемент ёфт нашавад, мо бармегардем -1'+char(10)+N'    return -1'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'arr = [10, 20, 30, 40, 50, 60, 70]'+char(10)+N'target = 30'+char(10)+N'result = binary_search(arr, target)'+char(10)+N'if result != -1:'+char(10)+N'    print("Элементи", target, " ёфта шуд дар индекси ", result)'+char(10)+N'else:'+char(10)+N'    print("Элементи", target, " дар массив ёфта нашудааст ")')
,(4, 2, N'#include <iostream>'+char(10)+N'#include <vector>'+char(10)+N''+char(10)+N'int binary_search(const std::vector<int>& arr, int target) {'+char(10)+N'    int left = 0, right = arr.size() - 1;'+char(10)+N'    while (left <= right) {'+char(10)+N'        int mid = left + (right - left) / 2; // Индекси миёнаи массивро пайдо мекунад'+char(10)+N'        if (arr[mid] == target) {'+char(10)+N'            return mid;'+char(10)+N'        } else if (arr[mid] < target) {'+char(10)+N'            left = mid + 1;'+char(10)+N'        } else {'+char(10)+N'            right = mid - 1;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return -1;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::vector<int> arr = {1, 3, 5, 7, 9, 11, 13};'+char(10)+N'    int target = 7;'+char(10)+N'    int result = binary_search(arr, target);'+char(10)+N'    if (result != -1) {'+char(10)+N'        std::cout << "Элемент ёфта шуд дар индекси " << result << "." << std::endl;'+char(10)+N'    } else {'+char(10)+N'        std::cout << "Элемент дар массив ёфта нашудааст." << std::endl;'+char(10)+N'    }'+char(10)+N'    return 0;'+char(10)+N'}')

,(5, 2, N'void BubbleSort(vector<int>& values) {'+char(10)+N'  for (size_t idx_i = 0; idx_i + 1 < values.size(); ++idx_i) {'+char(10)+N'    for (size_t idx_j = 0; idx_j + 1 < values.size() - idx_i; ++idx_j) {'+char(10)+N'      if (values[idx_j + 1] < values[idx_j]) {'+char(10)+N'        swap(values[idx_j], values[idx_j + 1]);'+char(10)+N'      }'+char(10)+N'    }'+char(10)+N'  }'+char(10)+N'}')
,(5, 1, N'def bubble_sort(values):'+char(10)+N'    for idx_i in range(len(values) - 1):'+char(10)+N'        for idx_j in range(len(values) - idx_i - 1):'+char(10)+N'            if values[idx_j + 1] < values[idx_j]:'+char(10)+N'                values[idx_j], values[idx_j + 1] = values[idx_j + 1], values[idx_j]'+char(10)+N''+char(10)+N'# Пример использования'+char(10)+N'values = [64, 34, 25, 12, 22, 11, 90]'+char(10)+N'bubble_sort(values)'+char(10)+N'print("Отсортированный список:", values)')

,(6, 2, N'void SelectionSort(vector<int>& values) {'+char(10)+N'  for (auto i = values.begin(); i != values.end(); ++i) {'+char(10)+N'    auto j = std::min_element(i, values.end());'+char(10)+N'    swap(*i, *j);'+char(10)+N'  }'+char(10)+N'}')

,(7, 2, N'int Partition(vector<int>& values, int l, int r) {'+char(10)+N'  int x = values[r];'+char(10)+N'  int less = l;'+char(10)+N''+char(10)+N'  for (int i = l; i < r; ++i) {'+char(10)+N'    if (values[i] <= x) {'+char(10)+N'      swap(values[i], values[less]);'+char(10)+N'      ++less;'+char(10)+N'    }'+char(10)+N'  }'+char(10)+N'  swap(values[less], values[r]);'+char(10)+N'  return less;'+char(10)+N'}'+char(10)+N''+char(10)+N'void QuickSortImpl(vector<int>& values, int l, int r) {'+char(10)+N'  if (l < r) {'+char(10)+N'    int q = Partition(values, l, r);'+char(10)+N'    QuickSortImpl(values, l, q - 1);'+char(10)+N'    QuickSortImpl(values, q + 1, r);'+char(10)+N'  }'+char(10)+N'}'+char(10)+N''+char(10)+N'void QuickSort(vector<int>& values) {'+char(10)+N'  if (!values.empty()) {'+char(10)+N'    QuickSortImpl(values, 0, values.size() - 1);'+char(10)+N'  }'+char(10)+N'}')

,(8, 1, N'def bfs(graph, start):'+char(10)+N'    queue = [start]'+char(10)+N'    visited = set()'+char(10)+N'    while queue:'+char(10)+N'        current = queue.pop(0)'+char(10)+N'        visited.add(current)'+char(10)+N'        for neighbor in graph[current]:'+char(10)+N'            if neighbor not in visited:'+char(10)+N'                queue.append(neighbor)'+char(10)+N''+char(10)+N'graph = {'+char(10)+N'    "A": ["B", "C"],'+char(10)+N'    "B": ["D", "E"],'+char(10)+N'    "C": ["F"],'+char(10)+N'    "D": [],'+char(10)+N'    "E": [],'+char(10)+N'    "F": [],'+char(10)+N'}'+char(10)+N'bfs(graph, "A")')

,(9, 1, N'def hanoi_recursive(n, source, target, auxiliary):'+char(10)+N'    if n == 1:'+char(10)+N'        print("Ҷойивазкунии диск 1 с", source, "на", target)'+char(10)+N'        return'+char(10)+N'    hanoi_recursive(n-1, source, auxiliary, target)'+char(10)+N'    print("Ҷойивазкунии диск ", n, "с", source, "на", target)'+char(10)+N'    hanoi_recursive(n-1, auxiliary, target, source)'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'n = 3'+char(10)+N'hanoi_recursive(n, "A", "C", "B")')

,(10, 1, N'def hanoi_iterative(n, source, target, auxiliary):'+char(10)+N'    stack = [(n, source, target, auxiliary)]'+char(10)+N'    while stack:'+char(10)+N'        n, source, target, auxiliary = stack.pop()'+char(10)+N'        if n == 1:'+char(10)+N'            print("Ҷойивазкунии диск 1 с", source, "на", target)'+char(10)+N'        else:'+char(10)+N'            stack.append((n-1, auxiliary, target, source))'+char(10)+N'            stack.append((1, source, target, auxiliary))'+char(10)+N'            stack.append((n-1, source, auxiliary, target))'+char(10)+char(10)+N'# Намунаи истифода:'+char(10)+N'n = 3'+char(10)+N'hanoi_iterative(n, "A", "C", "B")')

,(11, 1, N'def power(base, exponent):'+char(10)+N'    result = 1'+char(10)+N'    # То расидан ба нишондиҳанда 0'+char(10)+N'    while exponent > 0:'+char(10)+N'        # Агар нишондиҳанда ҷуфт бошад'+char(10)+N'        if exponent % 2 == 0:'+char(10)+N'            base *= base'+char(10)+N'            exponent //= 2'+char(10)+N'        # Агар нишондиҳанда тоқ бошад'+char(10)+N'        else:'+char(10)+N'            result *= base'+char(10)+N'            exponent -= 1'+char(10)+N'    return result'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'base = 2'+char(10)+N'exponent = 10'+char(10)+N'result = power(base, exponent)'+char(10)+N'print(base, "дар дараҷаи", exponent, "баробар аст ба ", result)')

,(12, 1, N'class Kruskal:'+char(10)+N'    def find_parent(self, parent, i):'+char(10)+N'        if parent[i] == i:'+char(10)+N'            return i'+char(10)+N'        return self.find_parent(parent, parent[i])'+char(10)+N''+char(10)+N'    def union(self, parent, rank, x, y):'+char(10)+N'        x_root = self.find_parent(parent, x)'+char(10)+N'        y_root = self.find_parent(parent, y)'+char(10)+N''+char(10)+N'        if rank[x_root] < rank[y_root]:'+char(10)+N'            parent[x_root] = y_root'+char(10)+N'        elif rank[x_root] > rank[y_root]:'+char(10)+N'            parent[y_root] = x_root'+char(10)+N'        else:'+char(10)+N'            parent[y_root] = x_root'+char(10)+N'            rank[x_root] += 1'+char(10)+N''+char(10)+N'    def kruskal_algorithm(self, graph):'+char(10)+N'        result = []'+char(10)+N'        i, e = 0, 0'+char(10)+N'        graph = sorted(graph, key=lambda item: item[2])'+char(10)+N'        parent, rank = [], []'+char(10)+N'        for node in range(len(graph)):'+char(10)+N'            parent.append(node)'+char(10)+N'            rank.append(0)'+char(10)+N''+char(10)+N'        while e < len(graph) - 1:'+char(10)+N'            u, v, w = graph[i]'+char(10)+N'            i += 1'+char(10)+N'            x = self.find_parent(parent, u)'+char(10)+N'            y = self.find_parent(parent, v)'+char(10)+N'            if x != y:'+char(10)+N'                e += 1'+char(10)+N'                result.append([u, v, w])'+char(10)+N'                self.union(parent, rank, x, y)'+char(10)+N'        return result'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'graph = [[0, 1, 4], [0, 7, 8], [1, 7, 11], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, 2], [8, 6, 6], [2, 5, 4], [2, 3, 7], [6, 5, 2], [3, 5, 14], [3, 4, 9], [5, 4, 10]]'+char(10)+N'kruskal = Kruskal()'+char(10)+N'result = kruskal.kruskal_algorithm(graph)'+char(10)+N'print(result)')

,(13, 1, N'def dfs(graph, start):'+char(10)+N'    """'+char(10)+N'    graph: Луғате, ки графро ифода мекунад.'+char(10)+N'    start: Нуқтаи оғоз.'+char(10)+N'    """'+char(10)+N'    visited = {key: 0 for key in graph}  # Ҳама нуқтаҳоро ҳамчун сафед оғоз кунед (дида нашуда)'+char(10)+N'    stack = [start]  # Истифодаи рӯйхат ҳамчун стек'+char(10)+N'    visited[start] = 1  # Нуқтаро ҳамчун хокистарӣ қайд мекунем (дар рафти боздид)'+char(10)+N''+char(10)+N'    while stack:'+char(10)+N'        vertex = stack.pop()'+char(10)+N'        print(vertex, "->", end=" ")'+char(10)+N'        '+char(10)+N'        # Для каждой смежной вершины'+char(10)+N'        if vertex in graph:'+char(10)+N'            for neighbour in graph[vertex]:'+char(10)+N'                if visited[neighbour] == 0:  # Агар нуқта сафед бошад (дида нашуда)'+char(10)+N'                    stack.append(neighbour)'+char(10)+N'                    visited[neighbour] = 1  # Нуқтаро ҳамчун хокистарӣ қайд мекунем (дар рафти боздид)'+char(10)+N''+char(10)+N'        visited[vertex] = 2  # Нуқтаро ҳамчун сиёҳ қайд мекунем (комилан дидан карда шудааст)'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'graph = {'+char(10)+N'    0: [1, 2],'+char(10)+N'    1: [2],'+char(10)+N'    2: [0, 3],'+char(10)+N'    3: [3]'+char(10)+N'}'+char(10)+N''+char(10)+N'start_vertex = 2'+char(10)+N'print(Ҷустуҷӯи амиқи такрории (DFS) сар карда аз нуқтаи", start_vertex)'+char(10)+N'dfs(graph, start_vertex)')

,(14, 1, N'def power(base, exponent):'+char(10)+N'    # Агар нишондиҳанда 0 бошад, бармегардад 1'+char(10)+N'    if exponent == 0:'+char(10)+N'        return 1'+char(10)+N'    # Агар нишондиҳанда ҷуфт бошад, ҳисоб мекунем base^(exponent/2) ва мураббаъ кунед'+char(10)+N'    elif exponent % 2 == 0:'+char(10)+N'        temp = power(base, exponent // 2)'+char(10)+N'        return temp * temp'+char(10)+N'    # Агар нишондиҳанда тоқ бошад, ҳисоб мекунем base^(exponent-1) ва зарб ба base'+char(10)+N'    else:'+char(10)+N'        temp = power(base, (exponent - 1) // 2)'+char(10)+N'        return base * temp * temp'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'base = 2'+char(10)+N'exponent = 10'+char(10)+N'result = power(base, exponent)'+char(10)+N'print(base, "дар дараҷаи", exponent, " баробар ба", result)')


--,(13, 1, N'')
--,(13, 1, N'')
--,(13, 1, N'')
--,(13, 1, N'')

GO


INSERT INTO Users([Name], IsAdmin, [Login], PasswordHash)
VALUES(N'Azimjon', 0, N'anematov2002@gmail.com', N'123')
,(N'Акмалхон Бурхонов', 0, N'b@gmail.com', N'123')
,(N'Шаҳзод', 0, N'shahanshohov01@gmail.com', N'123')
,(N'admin', 1, N'admin', N'admin')

--,(N'', 0, '', '')

-- def search(arr, target):'+char(10)+'    for i in range(0, len(arr)):'+char(10)+'        if item== target:'+char(10)+'            return i'+char(10)+'    return -1'+char(10)+''+char(10)+'# Пример использования'+char(10)+'arr = [1, 3, 5, 7, 9, 11, 13]'+char(10)+'target = 7'+char(10)+'result = search(arr, target)'+char(10)+'if result != -1:'+char(10)+'    print(f"Элемент найден в позиции {result}.")'+char(10)+'else:'+char(10)+'    print("Элемент не найден.")
-- def search(arr, target):'+char(10)+'    for item in arr:'+char(10)+'        if item == target:'+char(10)+'            return true'+char(10)+'    return false'+char(10)+''+char(10)+'# Пример использования'+char(10)+'arr = ["Alex", "Bob", "Martin", "Sven"]'+char(10)+'target = "Sven"'+char(10)+'result = search(arr, target)'+char(10)+'if result:'+char(10)+'    print(f"Элемент найден.")'+char(10)+'else:'+char(10)+'    print("Элемент не найден.")
-- import heapq'+char(10)+'from collections import defaultdict'+char(10)+''+char(10)+'def huffman_coding(freq):'+char(10)+'    heap = [[weight, [symbol, ""]] for symbol, weight in freq.items()]'+char(10)+'    heapq.heapify(heap)'+char(10)+'    while len(heap) > 1:'+char(10)+'        lo = heapq.heappop(heap)'+char(10)+'        hi = heapq.heappop(heap)'+char(10)+'        for pair in lo[1:]:'+char(10)+'            pair[1] = '0' + pair[1]'+char(10)+'        for pair in hi[1:]:'+char(10)+'            pair[1] = '1' + pair[1]'+char(10)+'        heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])'+char(10)+'    return sorted(heapq.heappop(heap)[1:], key=lambda p: (len(p[-1]), p))'+char(10)+''+char(10)+'# Пример использования'+char(10)+'data = "hello"'+char(10)+'freq = defaultdict(int)'+char(10)+'for symbol in data:'+char(10)+'    freq[symbol] += 1'+char(10)+'huff_codes = huffman_coding(freq)'+char(10)+'print("Символ\tЧастота\tКод Хаффмана")'+char(10)+'for symbol, f in freq.items():'+char(10)+'    code = [x[1] for x in huff_codes if x[0] == symbol][0]'+char(10)+'    print(f"{symbol}\t{f}\t{code}")

-- def binary_search(arr, target):'+char(10)+'    left, right = 0, len(arr) - 1'+char(10)+'    while left <= right:'+char(10)+'        mid = (left + right) // 2'+char(10)+'        if arr[mid] == target:'+char(10)+'            return mid'+char(10)+'        elif arr[mid] < target:'+char(10)+'            left = mid + 1'+char(10)+'        else:'+char(10)+'            right = mid - 1'+char(10)+'    return -1'+char(10)+''+char(10)+'# Пример использования'+char(10)+'arr = [1, 3, 5, 7, 9, 11, 13]'+char(10)+'target = 7'+char(10)+'result = binary_search(arr, target)'+char(10)+'if result != -1:'+char(10)+'    print(f"Элемент найден в позиции {result}.")'+char(10)+'else:'+char(10)+'    print("Элемент не найден.")'+char(10)+'


-- <code class="keyword">def</code> <code class="plain">binary_search(arr, target):</code><br><code class="plain">&emsp;left, right = 0, len(arr) - 1</code><br>&emsp;<code class="keyword">while</code><code class="plain"> left <= right:</code><br>&emsp;&emsp;<code class="plain">mid = (left + right) // 2</code><br>&emsp;&emsp;<code class="keyword">if</code"> <code class="plain">arr[mid] == target:</code><br>&emsp;&emsp;&emsp;<code class="keyword">return</code> <code class="plain">mid</code><br>&emsp;&emsp;<code class="keyword">elif</code> <code class="plain">arr[mid] < target:</code><br>&emsp;&emsp;&emsp;<code class="plain">left = mid + 1</code><br>&emsp;&emsp;<code class="keyword">else</code>:<br>&emsp;&emsp;&emsp;<code class="plain">right = mid - 1<code><br>&emsp;<code class="keyword">return</code> <code class="plain">-1</code><br> <br><code class="comments"># Пример использования</code><br><code class="plain">arr = [1, 3, 5, 7, 9, 11, 13]</code><br><code class="plain">target = 7</code><br><code class="plain">result = binary_search(arr, target)</code><br>if <code class="plain">result != -1:<code><br>&emsp;<code class="keyword">print<code><code class="plain">(</code><code class="string">f"Элемент найден в позиции </code><code class="plain">{result}</code><code class="string">."</code>)<br>else<code class="plain">:<code><br><code class="keyword">&emsp;print</code><code class="plain">(</code><code class="string">"Элемент не найден."</code><code class="plain">)</code>