/*Algorithms
Алгоритм поиска
- Линейный поиск
- Бинарный поиск

Алгоритм сортировки
- сортировка пузырьком
- сортировка выбором
- быстрая сортировка

Алгоритмы для работы с графами
- BFS (breadth first search)
- DFS (depth first search)
- алгоритм Дейкстры

Два указателя

Жадные алгоритмы
- Алгоритм Хаффмана
- Алгоритм Краскала

Быстрое возведение в степень C#
- Рекурсивная реализация быстрого возведения в степень
- Итерационная реализация быстрого возведения в степень
*/


INSERT INTO Topics([Name], HasChildren, ParentId, [Order])
VALUES(N'Алгоритмҳои ҷустуҷӯ', 1, NULL, 1)
	 ,(N'Алгоритмҳои ҷудокунӣ', 1, NULL, 2)
	 ,(N'Алгоритҳо барои кор бо графҳо', 1, NULL, 3)
	 ,(N'Ду нишондод', 0, NULL, 7)
	 ,(N'Алгоритмҳои хасис', 1, NULL, 5)
	 ,(N'Экспонентатсияи зуд', 1, NULL, 6)

GO

INSERT INTO Topics([Name], HasChildren, ParentId, [Order])
VALUES(N'Ҷустуҷӯи хатӣ', 0, 1, 1) --7
	 ,(N'Ҷустуҷӯи дуӣ', 0, 1, 2) --8
	 ,(N'Ҷудокунии ҳубобӣ', 0, 2, 1) --9
	 ,(N'Ҷудокунӣ аз рӯи интихоб', 0, 2, 2) --10
	 ,(N'Ҷудокунии зуд', 0, 2, 3)
	 ,(N'BFS (breadth first search)', 0, 3, 1) --12
	 ,(N'DFS (depth first search)', 0, 3, 2)
	 ,(N'Алгоритми Дейкстр', 0, 3, 3) --14
	 ,(N'Алгоритми Хаффман', 0, 5, 1)
	 ,(N'Алгоритми Краскал', 0, 5, 2) --16
	 ,(N'Алгоритми Евклид', 0, NULL, 5) --17
	 ,(N'Татбиқи рекурсивии экспонентатсияи зуд', 0, 6, 1)
	 ,(N'Татбиқи такрории экспонентатсияи зуд', 0, 6, 2) --19
	 ,(N'Манораи ханой', 0, NULL, 8) --20
	 ,(N'Барномасозии динамикӣ', 1, NULL, 9) --21
	 ,(N'Ҷойгиркунии n-маликаҳо дар тахтаи шоҳмот', 0, 21, 2) --22
	 ,(N'Рақамҳои ибтидоӣ', 0, NULL, 10) --23
	 ,(N'Алгоритмҳои тасодуфӣ', 0, 21, 3) --24
	 ,(N'Мушкилоти ҷузвдон', 0, 21, 4) --25
	 ,(N'Масофа дар шабака', 0, 21, 5) --26

GO

INSERT INTO Content(TopicId, ContentTypeId, [Data], Params, [Order])
VALUES(7, 2, N'Ҷустуҷӯи хатӣ яке аз соддатарин ва маъмултарин алгоритмҳои ҷустуҷӯи унсур дар массив мебошад. Он ҳар як унсури массивро аз аввал то пайдо шудани унсури дилхоҳ ё то дидани ҳамаи унсурҳо такроран месанҷад.', NULL, 1)
	 ,(7, 4, N'https://sushrutkuchik.wordpress.com/wp-content/uploads/2020/05/linear_search.gif', NULL, 2)
	 ,(7, 2, N'Принсипи кори алгоритм хеле содда аст. Бо гузаштан аз унсурҳои массив як ба як, он ҳар як унсурро бо арзиши мақсаднок муқоиса мекунад. Агар элемент бо арзиши мақсаднок мувофиқат кунад, алгоритм индекси ин элементро бармегардонад. Агар унсур бо арзиши мақсаднок мувофиқат накунад, алгоритм ба интихоби унсурҳои зерин идома медиҳад. Агар унсури мақсаднок дар массив пайдо нашавад, алгоритм арзиши махсусеро, ки набудани онро нишон медиҳад, бармегардонад.', NULL, 3)
	 ,(7, 2, N'Намунаи код:', NULL, 4)

GO

INSERT INTO CodeLists(asd) VALUES(NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL)
,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL)
,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL);
SELECT * FROM CodeLists;

GO

SELECT * FROM ProgramingLanguages

GO

INSERT INTO Content(TopicId, ContentTypeId, [Data], Params, [Order], CodeListId)
VALUES(7, 6, N'', NULL, 6, 1)
	 ,(7, 2, N'Дар ин рамз функсияи `linear_search` массиви `arr` ва унсури мақсадноки `target` - ро қабул мекунад, сипас ҳар як унсури массивро интихоб мекунад ва онро бо арзиши мақсаднок муқоиса мекунад. Агар элемент бо арзиши мақсаднок мувофиқат кунад, функсия индекси онро бармегардонад. Дар акси ҳол, -1 бармегардад, ки нишон медиҳад, ки унсур ёфт нашудааст.', NULL,7, NULL)
	 ,(7, 2, N'Ҷустуҷӯи хатӣ як алгоритми оддӣ ва содда аст, аммо он метавонад барои массивҳои калон аз сабаби мураккабии вақти хаттии он бесамар бошад. Аммо, он метавонад ҳангоми ҷустуҷӯи унсурҳо дар маҷмӯаҳои хурди маълумот ё вақте ки алгоритмҳои дигар мувофиқ нестанд, муфид бошад.', NULL, 8, NULL)
	 
	 ,(15, 2, N'Алгоритми Хаффман (Huffman Algorithm) алгоритми тамаъҷӯест, ки барои сохтани рамзи префиксии оптималӣ истифода мешавад, ки аксар вақт дар фишурдани маълумот истифода мешавад. Биеед бифаҳмем, ки ин алгоритм чӣ гуна кор мекунад.', NULL, 1, NULL)
	 ,(15, 3, N'Қадамҳои асосии алгоритми Хаффман', NULL, 2, NULL)
	 ,(15, 2, N'1. Ҳисоб кардани басомади аломатҳо:', NULL, 3, NULL)
	 ,(15, 5, N'Пеш аз ҳама, басомади пайдоиши ҳар як аломат дар паем (е файл) муайян карда мешавад, ки барои он рамзи фишурда сохта мешавад.', NULL, 4, NULL)
	 ,(15, 2, N'2. Сохтани дарахти Хаффман:', NULL, 5, NULL)
	 ,(15, 5, N'Дарахти бинарӣ сохта мешавад, ки дар он ҳар як барг рамз аст ва гиреҳҳои дохилӣ ҷамъи басомади наслҳои худ мебошанд;'+char(10)+N'Дар ҳар қадам алгоритм ду гиреҳро бо басомади камтарин муттаҳид мекунад ва гиреҳи навро бо басомади умумӣ эҷод мекунад.', NULL, 6, NULL)
	 ,(15, 2, N'3. Таъини рамзҳо:', NULL, 7, NULL)
	 ,(15, 5, N'Рамзи префиксӣ (пайдарпаии битӣ) барои ҳар як рамз аз рӯи дарахт аз реша ба баргҳо сохта мешавад. Дар зери дарахти чап "0" ва дар тарафи рост "1" нишон дода шудааст;'+char(10)+N'Ба шарофати усули чашмгуруснагии сохтани дарахт, рамзҳои дарозии тағйиребанда аксар вақт истифода мешаванд. Аксар вақт рамзҳои кӯтоҳтар ба рамзҳои бештар таъин карда мешаванд.', NULL, 8, NULL)
	 ,(15, 2, N'4. Фишурдани маълумот:', NULL, 9, NULL)
	 ,(15, 5, N'Паем (е файл) бо версияи фишурда иваз карда мешавад, ки дар он ҳар як рамз бо рамзи префиксии мувофиқ иваз карда мешавад;'+char(10)+N'Ин ба шумо имкон медиҳад, ки маълумотро бо истифода аз битҳои камтар пешниҳод кунед, агар рамзҳои зуд-зуд рамзҳои кӯтоҳтар дошта бошанд.', NULL, 10, NULL)
	 ,(15, 6, N'', NULL, 11, 3)
	 ,(15, 2, N'Алгоритми Хаффман имкон медиҳад, ки маълумотро дар асоси басомади рамзҳо дар паем самаранок фишурда шавад. Он воситаи калидӣ дар фишурдани маълумот мебошад ва дар технологияҳои фишурдани файл, бойгонӣ, протоколҳои шабакавӣ ва дигар соҳаҳо васеъ истифода мешавад.', NULL, 12, NULL)
	 
	 ,(8, 2, N'Ҷустуҷӯи дуӣ алгоритми самараноки ҷустуҷӯи унсур дар массиви мураттабшуда мебошад. Он тавассути тақсим кардани массив ва муқоисаи унсури дилхоҳ бо унсури мобайни массив кор мекунад. Агар унсури ҷустуҷӯшаванда ба унсури миёнаи массив баробар бошад, ҷустуҷӯ ба анҷом мерасад. Агар унсури ҷустуҷӯшаванда аз унсури миёнаи массив хурдтар бошад, ҷустуҷӯ дар нимаи чапи массив идома меёбад. Агар унсури ҷустуҷӯшаванда аз унсури миёнаи массив калонтар бошад, ҷустуҷӯ дар нимаи рости массив идома меёбад. Ин раванд то пайдо шудани унсури ҷустуҷӯшуда ё то дар массив боқӣ мондани як унсур такрор мешавад.', NULL, 1, NULL)
	 ,(8, 4, N'https://media.proglib.io/posts/2022/11/21/1cf3b4ed69a54149b52f817571bd3d81.gif', NULL, 2, NULL)
	 ,(8, 2, N'Принсипи кори алгоритм чунин аст: дар ҳар як итерасия ҷустуҷӯи дуӣ андозаи диапазони ҷустуҷӯро ду баробар кам мекунад. Ин ба шумо имкон медиҳад, ки ҷустуҷӯро ба як адад кам мекунад.', NULL, 3, NULL)
	 ,(8, 2, N'Намуна код:', NULL, 4, NULL)
	 ,(8, 6, N'', NULL, 5, 4)
	 
	 ,(9, 2, N'Ҷобаҷогузории ҳубобӣ яке аз алгоритмҳои машҳури ҷобаҷогузорӣ мебошад. Дар ин ҷо шумо бояд арзишҳои унсурҳои ҳамсояро пай дар пай муқоиса кунед ва рақамҳоро бо ҷойҳо иваз кунед, агар пештара аз охирин калонтар бошад. Ҳамин тариқ, унсурҳои дорои арзишҳои калон дар охири рӯйхат ва бо арзишҳои хурдтар дар аввал боқӣ мемонанд.', NULL, 1, NULL)
	 ,(9, 4, N'https://yastatic.net/s3/education-portal/media/1_49e0bb0f63_63adb81133.gif', NULL, 2, NULL)
	 ,(9, 2, N'Ин алгоритм омӯзишӣ ҳисобида мешавад ва аз сабаби самаранокии паст қариб дар амал татбиқ карда намешавад: он оҳиста дар санҷишҳое кор мекунад, ки дар онҳо унсурҳои хурд (онҳоро черепахами меноманд) дар охири массив истодаанд. Аммо, бисер усулҳои дигар ба он асос ефтаанд, ба монанди ҷобаҷогузории ларзиш ва ҷобаҷогузории шона.', NULL, 3, NULL)
	 ,(9, 6, N'', NULL, 4, 5)
	 ,(9, 7, N'Бояд қайд кард, ки мураккабии муваққатии ин алгоритми O(n^2).', NULL, 5, NULL)
	 
	 ,(10, 2, N'Аввалан, шумо бояд зергурӯҳи массивро баррасӣ кунед ва дар он ҳадди аксар (е ҳадди аққал) пайдо кунед. Сипас арзиши интихобшуда бо арзиши унсури якуми ҷудонашуда иваз карда мешавад. Ин қадам бояд то ба охир расидани зермассивҳои ҷудонашуда дар массив такрор карда шавад.', NULL, 1, NULL)
	 ,(10, 4, N'https://unicoding.dev/upload/photos/2021/06/ZhMwAZcAI2wY3w435J12_30_621e7bff7f37a5fe105693bb7d9888ac_image.gif', NULL, 2, NULL)
	 ,(10, 6, N'', NULL, 3, 6)
	 ,(10, 7, N'мураккабии муваққатии ин алгоритми O(n^2).', NULL, 4, NULL)
	 
	 ,(11, 2, N'Ин алгоритм аз се марҳила иборат аст. Аввалан, шумо бояд як унсурро аз массив интихоб кунед-онро одатан дастгирӣ меноманд. Сипас унсурҳои дигари массивро тавре тақсим мекунанд, ки унсурҳои камтар аз унсурҳои такягоҳ пеш аз он ва калон е баробар пас аз он бошанд. Ва минбаъд ду қадами аввалро ба зермассивҳои рост ва чапи арзиши такягоҳ рекурсивӣ истифода мебаранд.', NULL, 1, NULL)
	 ,(11, 4, N'https://yastatic.net/s3/education-portal/media/184_11_3c7583c6cd_59878a71a8.gif', NULL, 2, NULL)
	 ,(11, 2, N'Ҷамъбасти зудро соли 1960 барои тарҷумаи мошинӣ ихтироъ карданд: он вақт луғатҳо дар лентаҳои магнитӣ нигоҳ дошта мешуданд ва ҷамъбасти калимаҳои матни коркардшуда имкон медод, ки тарҷумаҳоро дар як пешбурди лента бидуни бозгашт ба даст оранд.', NULL, 3, NULL)
	 ,(11, 6, N'', NULL, 4, 7)
	 ,(11, 7, N'мураккабии муваққатии ин алгоритми O(n^2).', NULL, 5, NULL)

	 ,(12, 2, N'BFS, ё Breadth First Search алгоритми канори граф дар паҳнои. Граф ин сохтори "қуллаҳо" ва "канорҳо" мебошад, ки қуллаҳоро бо ҳам мепайвандад. Дар канори он аз як қулла ба қуллаи дигар ҳаракат кардан мумкин аст ВА BFS ин корро сатҳӣ мекунад: аввал аз тамоми қуллаҳои наздиктарин аз нуқтаи ибтидоӣ мегузарад, сипас чуқуртар поен меравад.', NULL, 1, NULL)
	 ,(12, 2, N'Чунин ба назар мерасад: алгоритм дар қуллаи пешакӣ интихобшуда оғоз меебад ва аввал "ташриф меорад" ва ҳамаи ҳамсояҳои ин қулларо қайд мекунад. Сипас он ба ҳамсояҳои қуллаҳои ташриф овардашуда мегузарад, сипас минбаъд бо ҳамон принсип. Аз сабаби хусусияти паҳншавии ба мавҷ монанд, алгоритмро мавҷӣ низ меноманд. BFS яке аз ду алгоритми маъмули гузариш аст. Дуюм DFS ном дорад ва ба чуқурӣ гузаштанро дар назар дорад: аввал алгоритм аз канори граф ба чуқурӣ мегузарад.', NULL, 2, NULL)
	 ,(12, 3, N'BFS барои чӣ лозим', NULL, 3, NULL)
	 ,(12, 5, N'Барои ҳалли масъалаҳои ҷустуҷӯи роҳи оптималӣ. Вазифаи классикӣ ҷустуҷӯи автоматикунонидашудаи баромадан аз лабиринт ҳисобида мешавад.'+char(10)+N'Барои ҳалли масъалаҳои бевосита бо назарияи графҳо алоқаманд, масалан барои ҷустуҷӯи ҷузъи пайвастшавӣ. Ин масъалаҳо дар навбати Худ дар илми Маълумот, назарияи шабакаҳо ва электроника ҳал карда мешаванд.'+char(10)+N'Барои масъалаҳои зеҳни сунъӣ, ки бо ҷустуҷӯи ҳалли камтарин ҳаракатҳо алоқаманданд. Дар ин ҳолат ҳолати "мошини оқил" ҳамчун қуллаҳо ва гузаришҳо байни онҳо ҳамчун канораҳо ифода карда мешаванд.'+char(10)+N'Барои оптимизатсияи хотира ҳангоми гузаштан аз граф дар баъзе ҳолатҳо, масалан барои баъзе сохторҳои мушаххас.'+char(10)+N'Барои кор бо иттилоот дар сохторҳои муайяни маълумот, ба монанди дарахтон. Онҳоро низ бо алгоритми BFS убур кардан мумкин аст, зеро онҳо зергурӯҳи графҳо мебошанд.', NULL, 4, NULL)
	 ,(12, 1, N'Хусусиятҳои BFS', NULL, 5, NULL)
	 ,(12, 5, N'Шумораи доимии амалҳо барои ҳар як канор е қулла. Ин ҳангоми ҳисоб кардани мураккабии алгоритм ҳангоми интихоби усули оптималии ҳалли ин е он масъала муҳим аст.'+char(10)+N'Набудани мушкилоти "сикли беохир": алгоритм бо сабаби хусусиятҳои корӣ дар ягон шароит ба он дохил намешавад.'+char(10)+N'Дақиқии баланд ва меъмории боэътимод, ки ба шумо имкон медиҳад, ки ба ин алгоритм барои ҳалли масъалаҳои гуногун такя кунед.'+char(10)+N'Қобилияти кор кардан бо графҳои нигаронидашуда ва ғайримутамарказ. Дар бораи он, ки онҳо аз ҳам фарқ мекунанд, дар мақола дар бораи графикаи нигаронидашуда хондан мумкин аст.'+char(10)+N'Пуррагии алгоритм он ҳалли худро меебад, яъне роҳи кӯтоҳтаринро пайдо мекунад ва дар ҳар графаи ниҳоӣ ба анҷом мерасад. Агар граф беохир бошад, ҳалли он танҳо дар сурате пайдо мешавад, ки агар ягон роҳи он ниҳоӣ бошад.'+char(10)+N'Имконияти пайдо кардани роҳи кӯтоҳтарин дар граф, агар ҳамаи канораҳо дарозии якхела дошта бошанд. Агар дарозии қабурғаҳо гуногун бошанд, BFS роҳи камтарини қабурғаҳоро пайдо мекунад, аммо он ҳатман кӯтоҳтарин нахоҳад буд. Барои ҷустуҷӯи роҳи кӯтоҳтарин дар ин ҳолат алгоритми Дейкстра беҳтар хоҳад буд.', NULL, 6, NULL)
	 ,(12, 3, N'Алгоритми BFS чӣ гуна кор мекунад', NULL, 7, NULL)
	 ,(12, 2, N'Алгоритм оддӣ ва беихтиерона аст. Он аз болои қуллаҳои граф мегузарад, то он даме ки қуллаҳои ташриф наоварда боқӣ монанд ва роҳи кӯтоҳтаринро то қуллаи мақсаднок ҳисоб мекунад. Барои ба таври равшантар нишон додани кори он, алгоритмро зина ба зина муаррифӣ мекунем.', NULL, 8, NULL)
	 ,(12, 2, N'Оғози кор. Шумо метавонед ҳар як қулларо ҳамчун қуллаи ибтидоӣ интихоб кунед. Дар лаҳзаи оғози кори алгоритм, ҳамаи қуллаҳо ҳамчун ташриф наоварда қайд карда шудаанд онҳоро сафед меноманд. Аввалин чизе, ки алгоритм мекунад, ин аст, ки қуллаи ибтидоиро ҳамчун ташриф овардашуда қайд мекунад (инчунин истилоҳоти кушода е хокистарӣ истифода мешаванд). Агар он мақсаднок бошад, ин алгоритмро ба анҷом мерасонад. Аммо аксар вақт ин тавр нест.', NULL, 9, NULL)
	 ,(12, 2, N'Ҷустуҷӯи ҳамсояҳо. Алгоритм месанҷад, ки кадом ҳамсояҳо дар қуллаи ибтидоӣ ҳастанд. Онҳо ба "навбати амалҳо" бо тартиби алгоритме, ки онҳоро пайдо кардааст, илова карда мешаванд ва инчунин ҳамчун "сабз"қайд карда мешаванд. Ин то он даме идома меебад, ки дар қуллаи ибтидоӣ ҳамсояҳои "сафед" боқӣ монанд.', NULL, 10, NULL)
	 ,(12, 2, N'Гузариш ба қуллаи навбатӣ. Вақте ки алгоритм аз тамоми ҳамсояҳои қуллаи ибтидоӣ мегузарад, он онро пурра аз байн мебарад. Чунин қуллаҳоро "сиеҳ" низ меноманд: алгоритм ба онҳо барнамегардад. Сипас он ба яке аз қуллаҳои "хокистарӣ" — и ҳамсояҳои ибтидоӣ мегузарад. Алгоритм қуллаи аввалро дар навбат интихоб мекунад. Сипас амалҳо такрор мешаванд:" ҳамсояҳо "- и қулла, ба ғайр аз" сиеҳ", ба навбат ворид карда мешаванд.', NULL, 12, NULL)
	 ,(12, 2, N'Вақте ки ин қулла низ аз он мегузарад, гузариш бо ҳамон принсип такрор мешавад — қуллаи аввал дар навбат. Дар ин ҳолат, он ҳамсояи дуюми қуллаи ибтидоӣ хоҳад буд-мо дар хотир дорем, ки онҳо аввал ба навбат илова карда шуданд. Ва танҳо вақте ки ҳамсояҳои қуллаи ибтидоӣ дар навбат ба охир мерасанд, алгоритм аз рӯи "сатҳи" қуллаҳои навбатӣ мегузарад. Ҳамин тавр, ба паҳноии он роҳ дода мешавад.', NULL, 13, NULL)
	 ,(12, 2, N'Охири алгоритм. Агар навбат холӣ бошад, ин маънои онро дорад, ки қуллаҳои "сафед" ва "сафед" дигар боқӣ намондаанд. Алгоритм ба охир мерасад. Агар дар ин ҳолат қуллаи мақсаднок ба даст наояд, ин маънои онро дорад, ки ба он аз нуқтаи ибтидоӣ дастрасӣ вуҷуд надорад.', NULL, 14, NULL)
	 ,(12, 2, N'Агар қуллаи мақсаднок пеш аз он ки алгоритм аз тамоми граф гузарад, ба даст оварда шавад, ин метавонад маънои онро дошта бошад, ки он ба анҷом мерасад. Алгоритм қатъ мешавад, зеро вазифа иҷро мешавад: роҳи кӯтоҳтарин ба болои ҳадаф пайдо мешавад.', NULL, 15, NULL)
	 ,(12, 6, N'', NULL, 16, 8)


	 
	 ,(17, 1, N'Алгоритми Евклид: дарефти бузургтарин тақсимкунандаи умумӣ', NULL, 1, NULL)
	 ,(17, 2, N'Алгоритми Эвклид яке аз алгоритмҳои қадимтарин ва самараноктарин барои ёфтани калонтарин тақсимкунандаи умумии (КТУ) ду рақам мебошад. Дар тӯли асрҳо он яке аз воситаҳои асосии математикӣ боқӣ мемонад ва дар бисёр соҳаҳо, аз ҷумла алгебра, криптография, информатика ва ғайра истифода мешавад.', NULL, 2, NULL)
	 ,(17, 2, N'Алгоритм ба номи математики юнони қадим Эвклид номгузорӣ шудааст, ки онро дар рисолаи худ "Оғоз" тасвир кардааст, ки тақрибан соли 300 то милод навишта шудааст. соддагӣ ва самаранокии он онро махсусан барои истифода дар вазифаҳои гуногун ҷолиб месозад.', NULL, 3, NULL)
	 ,(17, 2, N'Принсипи кори алгоритми Эвклид ба идеяи оддӣ асос ёфтааст: агар a аз b калонтар бошад, пас КТУ a ва b ба КТУ b ва a mod b баробар аст, ки дар он mod амалиети гирифтани боқимондаи тақсимотро ифода мекунад. Ин раванд такрор мешавад, то яке аз рақамҳо ба 0 баробар шавад. Вақте ки яке аз ададҳо ба 0 баробар мешавад, адади боқимонда бузургтарин тақсимкунандаи умумии ададҳои ибтидоӣ хоҳад буд.', NULL, 4, NULL)
	 ,(17, 2, N'Намунаи код барои татбиқи алгоритми Эвклид:', NULL, 5, NULL)
	 ,(17, 6, N'', NULL, 6, 2)
	 ,(17, 2, N'Дар ин мисол, функсияи `euclidean_algorithm` ду рақами `a` ва` b` - ро ба вуруд қабул мекунад ва алгоритми Эвклидро барои ефтани тақсимкунандаи умумии калонтарини Онҳо истифода мебарад. То он даме, ки рақами дуюм ба 0 баробар шавад, он бо боқимондаи тақсимоти рақами аввал ба рақами дуюм иваз карда мешавад. Ин раванд то он даме идома меебад, ки яке аз рақамҳо ба 0 баробар шавад ва адади боқимонда бузургтарин тақсимкунандаи умумӣ бошад.', NULL, 7, NULL)
	 ,(17, 2, N'Алгоритми Эвклид яке аз усулҳои самаранок ва универсалии ефтани тақсимкунандаи умумии калонтарин мебошад ва қисми ҷудонопазири арсенали математикӣ боқӣ мемонад.', NULL, 8, NULL)

	 
	 ,(20, 1, N'Манораи ханой: Машқ ва якчанд роҳҳои татбиқ', NULL, 1, NULL)
	 ,(20, 2, N'Бурҷи ханой як мушкили классикӣ аст, ки аксар вақт барои таълим ва нишон додани принсипҳои рекурсия истифода мешавад. Вазифа аз он иборат аст, ки стеки дискҳои диаметри гуногунро аз як асо ба асои дигар бо истифода аз асои сеюм ҳамчун мобайнӣ интиқол диҳед, ба шарте ки дар ҳар як қадам танҳо як дискро интиқол додан мумкин бошад ва диски калонтар ҳеҷ гоҳ дар болои диски хурдтар ҷойгир карда нашавад.', NULL, 2, NULL)
	 ,(20, 2, N'Принсипи кори вазифаи бурҷи Ханой ба қадри кофӣ содда аст: барои интиқол додани стеки дискҳо аз як асо ба асои дигар, мо аввал дискҳои болоии `n-1`-ро ба асои мобайнӣ интиқол медиҳем, сипас диски калонтаринро ба асои ҳадаф интиқол медиҳем ва дар ниҳоят дискҳои `n-1` - ро аз асои мобайнӣ ба асои ҳадаф интиқол медиҳем. Ин раванд барои ҳар як пойгоҳи диск рекурсивӣ такрор карда мешавад, то он даме ки ҳамаи дискҳо ба асои ҳадаф интиқол дода шаванд.', NULL, 3, NULL)
	 ,(20, 3, N'Усули 1: ҳалли рекурсивӣ', NULL, 4, NULL)
	 ,(20, 2, N'Намунаи рамзи барои ҳалли рекурсивии масъалаи Манораи Ханой:', NULL, 5, NULL)
	 ,(20, 6, N'', NULL, 6, 9)
	 ,(20, 3, N'Усули 2: ҳалли такрорӣ', NULL, 7, NULL)
	 ,(20, 2, N'Намунаи рамзи барои ҳалли такрории масъалаи манораи Ханой:', NULL, 8, NULL)
	 ,(20, 6, N'', NULL, 9, 10)
	 ,(20, 2, N'Ҳарду роҳи ҳалли масъалаи Манораи Ханой самаранок буда, принсипҳои рекурсия ва итерасияро нишон медиҳанд. Интихоби усул аз афзалиятҳо ва талаботи мушаххаси лоиҳаи шумо вобаста аст.', NULL, 10, NULL)
	 



	 ,(19, 1, N'Татбиқи такрории экспонентатсияи зуд', NULL, 1, NULL)
	 ,(19, 2, N'Экспонентатсияи зуд усулест, ки ба шумо имкон медиҳад, ки арзиши рақами ба дараҷа бардошташударо самаранок ҳисоб кунед. Баръакси усули рекурсивӣ, татбиқи итеративӣ ба даври итеративӣ асос ёфтааст, ки рақамро ба худ пай дар пай зарб мекунад, то он даме ки ба дараҷаи зарурӣ мерасад.', NULL, 1, NULL)
	 ,(19, 2, N'Принсипи кори татбиқи итеративии экспонентатсияи зуд оддӣ аст: мо бо натиҷаи баробар ба 1 оғоз мекунем ва сипас онро пай дар пай ба пойгоҳ зарб карда, нишондиҳандаи дараҷаро дар ҳар қадам дучанд мекунем. Ин ба мо имкон медиҳад, ки шумораи амалиетҳои барои ҳисоб кардани дараҷа заруриро кам кунем.', NULL, 2, NULL)
	 ,(19, 2, N'Намунаи код:', NULL, 3, NULL)
	 ,(19, 6, N'', NULL, 4, 11)
	 ,(19, 2, N'Дар ин рамз функсияи `power` асоси `base` ва нишондиҳандаи дараҷаи `exponent` - ро ба вуруд қабул мекунад, сипас натиҷаи ба дараҷа баровардани рақамро итеративӣ ҳисоб мекунад. То он даме, ки нишондиҳанда аз 0 зиед аст, мо месанҷем, ки он ҷуфт ё тоқ аст. Агар он баробар бошад, мо асосро ба худ зарб мекунем ва нишондиҳандаро ду баробар кам мекунем. Агар он тоқ бошад, натиҷаро ба пойгоҳ зарб кунед ва нишондиҳандаро ба 1 кам кунед. Ин раванд то ба 0 баробар шудани нишондиҳанда такрор мешавад.', NULL, 5, NULL)
	 ,(19, 2, N'Татбиқи итеративии экспонентатсияи зуд усули муассир ва ба осонӣ фаҳмо барои кор бо ҳисоб кардани дараҷа мебошад.', NULL, 6, NULL)


	 
	 ,(16, 2, N'Алгоритми Краскал (Kruskals Algorithm) ин алгоритми ефтани дарахти ҳадди ақали сутун дар графаи пайвастаи тарозу мебошад. Дарахти остии оптималӣ ин зерграфи графи ибтидоӣ мебошад, ки ҳамаи қуллаҳоро дар бар мегирад, ки аз рӯи вазни канори он ҳадди ақал аст.', NULL, 1, NULL)
	 ,(16, 1, N'Ин аст алгоритми Краскал чӣ гуна кор мекунад:', NULL, 2, NULL)
	 ,(16, 2, N'Қадамҳои асосии алгоритми Краскал:', NULL, 3, NULL)
	 ,(16, 2, N'1. Оғози кор:', NULL, 4, NULL)
	 ,(16, 5, N'Мо ҷангал месозем, ки дар он ҳар як қуллаи граф дарахти алоҳида аст.', NULL, 5, NULL)
	 ,(16, 2, N'2. Ҷобаҷогузории қабурғаҳо:', NULL, 6, NULL)
	 ,(16, 5, N'Канори граф аз рӯи афзоиши вазнҳо ҷудо карда мешавад.', NULL, 7, NULL)
	 ,(16, 2, N'3. Якҷоя кардани дарахтон:', NULL, 8, NULL)
	 ,(16, 5, N'Қабурғаҳои вазни ҳадди ақал пай дар пай интихоб карда мешаванд.'+char(10)+N'Агар илова кардани қабурға дар дарахти пояи ҷорӣ даврае ба вуҷуд наорад, он ба поя илова карда мешавад. Алгоритми ҷустуҷӯи амиқ е равиши дигарро барои санҷиши давра истифода бурдан мумкин аст.', NULL, 9, NULL)
	 ,(16, 2, N'4. Такрор:', NULL, 10, NULL)
	 ,(16, 5, N'Қадамҳои 3 такрор мешаванд, то ҳама қуллаҳо баста шаванд ва дарахти камтарин пурра бошад.', NULL, 12, NULL)
	 ,(16, 6, N'', NULL, 13, 12)
	 ,(16, 2, N'Алгоритми Краскал усули самараноки пайдо кардани дарахти ҳадди ақали сутун дар граф аст. Он дар соҳаҳои гуногун васеъ истифода мешавад, ки дар он ҷо бояд зергурӯҳи оптималии дарахтро бо арзиши ҳадди ақали умумӣ пайдо кард.', NULL, 14, NULL)

	 
	 ,(13, 2, N'DFS, ё Depth First Search, ҷустуҷӯи чуқурӣ, ки ба шумо имкон медиҳад, ки хатсайрро аз нуқтаи A то нуқтаи B пайдо кунед.Дар графҳои сохторҳои махсус, ки аз нуқтаҳои қуллаҳо ва канори роҳҳо иборат Мебошанд, Истифода Мешавад. DFS дар ҷустуҷӯи хатсайри графикӣ ба чуқурӣ аст: дар ҳар қадам дуртар меравад.', NULL, 1, NULL)
	 ,(13, 2, N'Намунаи классикии истифодаи алгоритм ҷустуҷӯи роҳи тасодуфӣ дар лабиринт. DFS корро дар нуқтаи додашуда оғоз мекунад, дар ҳар қадам аз лабиринт то гардиши навбатӣ мегузарад ва самтро интихоб мекунад. Агар роҳ сарбаста бошад, алгоритм ба гардиши қаблӣ бармегардад ва самти навро меозмояд. Дар натиҷа, дер е зуд роҳи дуруст аст.', NULL, 2, NULL)
	 ,(13, 4, N'https://blog.skillfactory.ru/wp-content/uploads/2023/02/dfs_maze-8816737.gif', NULL, 3, NULL)
	 ,(13, 3, N'Принсипи гузариши граф ба чуқурӣ', NULL, 4, NULL)
	 ,(13, 2, N'Мо алгоритми рекурсивии стандартии гузаришро дида мебароем. Дар бораи татбиқи ғайримуқаррарӣ дар зер сӯҳбат хоҳем кард: якчанд ҳастанд ва ҳар яки онҳо хусусиятҳои худро доранд. Принсипи стандартиро фаҳмидан хеле осон аст ва татбиқи он осон аст.', NULL, 5, NULL)
	 ,(13, 4, N'https://blog.skillfactory.ru/wp-content/uploads/2023/02/dfs-1-8650838.png', NULL, 6, NULL)
	 ,(13, 2, N'Қадами аввал. Вақте ки алгоритм ба кор шурӯъ мекунад, ҳамаи қуллаҳо "сафед" ҳисобида мешаванд, ки ба он ташриф намеоранд. DFS роҳро дар қуллаи пешакӣ муайяншудаи v оғоз мекунад ва бояд аз он ба қуллаи дигари додашуда роҳ ебад е харитаи графро пурра тартиб диҳад.', NULL, 7, NULL)
	 ,(13, 2, N'Аввалин чизе, ки DFS мекунад, ранг кардани болои он аст, ки дар он хокистарӣ аст. Ин нишон медиҳад, ки алгоритм аллакай дар он буд. пас аз он DFS ҳамсоягонро месанҷад-қуллаҳое, ки ба он ҷое, ки он ҷойгир аст, пайвастанд.', NULL, 8, NULL)
	 ,(13, 2, N'Гузариш. Агар яке аз қуллаҳои ҳамсоя сафед бошад, алгоритм ба он мегузарад ва ҳамон амалҳоро такрор мекунад: ба хокистарӣ ранг мекунад, ҳамсояҳоро меҷӯяд. Ин на ба таври даврӣ, балки ба таври рекурсивӣ сурат мегирад: агар DFS-ро ҳамчун функсия муаррифӣ кунем, пас ин функсия дар рафти иҷро худашро ба вуҷуд меорад, аммо барои қуллаи дигар. Аз ин рӯ, алгоритм аввал бо як ҳамсояи интихобшуда кор мекунад ва танҳо дар сурати ба бунбаст афтодан, бармегардад ва кӯшиш мекунад, ки роҳи дигарро тай кунад.', NULL, 9, NULL)
	 ,(13, 2, N'Интихоби ҳамсоя тасодуфан е бо меъерҳои пешакӣ муайяншуда сурат мегирад-масалан, он метавонад қуллаи чаптарин е росттарин бошад. Дар боло мо "қоидаи дасти чап" - ро зикр кардем: он аслан чунин меъер аст.', NULL, 10, NULL)
	 ,(13, 2, N'Агар дар болои он ҳамсояҳои номаълум боқӣ намонанд, он ҳамчун пурра ташриф овардашуда сиеҳ ранг карда мешавад.', NULL, 11, NULL)
	 ,(13, 2, N'Анҷом додани гардиш. Алгоритм агар ба нуқтаи зарурӣ бирасад, ба анҷом мерасад. Дар ин ҳолат, ҳамаи "намунаҳои" функсияҳои даъватшуда ба таври навбатӣ ба анҷом мерасанд: аз охирин то аввалин даъватшуда. Агар вазифа пурра аз болои граф гузарад, пас меъери ба итмом расонидани графи дигар: ҳамаи қуллаҳо бояд сиеҳ шаванд.', NULL, 12, NULL)
	 ,(13, 3, N'Чӣ тавр амалӣ кардани алгоритми DFS', NULL, 13, NULL)
	 ,(13, 2, N'Соддатарин татбиқи рекурсивӣ сохтани граф дар шакли рӯйхати алоқаманд е сохтори дигари маълумот ва сипас навиштани функсия барои гузаштан аз он мебошад. Чӣ тавр амалӣ кардани худи граф аз забони барномасозӣ вобаста аст: одатан намудҳое истифода мешаванд, ки ба нигоҳ доштани арзишҳои гуногун имкон медиҳанд. Ҳар як унсури чунин навъи комплексӣ қулла аст ва дар дохили қулла истинодҳо ба унсурҳои дигар е рақамҳои онҳо нигоҳ дошта мешаванд ҳамин тавр роҳҳо амалӣ карда мешаванд.', NULL, 14, NULL)
	 ,(13, 2, N'Худи функсия, ки шартан DFS (v) номида мешавад, хеле оддӣ аст ва аз рӯи мантиқи зерин амал мекунад.', NULL, 15, NULL)
	 ,(13, 5, N'Ба даромадгоҳ қуллаи сафед v ворид мешавад.'+char(10)+N'Дар болои v ранги хокистарӣ дорад.'+char(10)+N'Қуллаи w, ки бо v ва сафед ҳамсоя аст, ҷустуҷӯ карда мешавад.'+char(10)+N'Аз дохили DFS (v) dfs (w) рекурсивӣ даъват карда мешавад.'+char(10)+N'Вақте ки функсия ба итмом мерасад, болои v сиеҳ ранг карда мешавад.', NULL, 16, NULL)
	 ,(13, 2, N'"Рангкунӣ" метавонад бо ерии ягон тағиребанда дар дохили қулла амалӣ карда шавад: масалан, арзиши 0 сафед, 1 хокистарӣ ва ғайра', NULL, 17, NULL)
	 ,(13, 6, N'', NULL, 18, 13)

	 
	 ,(18, 1, N'Татбиқи рекурсивии экспонентатсияи зуд', NULL, 1, NULL)
	 ,(18, 2, N'Экспонентатсияи зуд роҳи самараноки зуд ҳисоб кардани арзиши рақами ба дараҷа бардошташуда мебошад. Татбиқи рекурсивии ин алгоритм ба идеяи оддӣ асос ефтааст: агар мо хоҳем, ки рақами а-ро ба дараҷаи n гузорем, мо метавонем n-ро ба ду тақсим кунем ва а-ро ба дараҷаи n/2 ҳисоб кунем ва сипас натиҷаи бадастомадаро квадрат кунем. Ин раванд то расидан ба дараҷаи 1 такрор мешавад.', NULL, 2, NULL)
	 ,(18, 2, N'Намунаи код:', NULL, 3, NULL)
	 ,(18, 6, N'', NULL, 4, 14)
	 ,(18, 2, N'Дар ин код функсияи `power` асоси `base` ва нишондиҳандаи дараҷаи `exponent` - ро қабул мекунад, сипас натиҷаи ба дараҷа баровардани рақамро рекурсивӣ ҳисоб мекунад. Агар нишондиҳанда 0 бошад, функсия 1-ро бармегардонад. Агар нишондиҳанда ҷуфт бошад, функсия арзиши base^{exponent/2} - ро ҳисоб мекунад ва онро квадрат мекунад. Агар нишондиҳанда ночиз бошад, функсия арзиши base^{(exponent-1)/2} - ро ҳисоб мекунад ва онро ба асос зарб мекунад. Ин раванд то расидан ба ҳолати асосӣ, ки нишондиҳандаи дараҷа 0 аст, такрор мешавад.', NULL, 5, NULL)
	 ,(18, 2, N'Татбиқи рекурсивии экспонентатсияи зуд роҳи самараноки ҳисоб кардани дараҷа мебошад, алахусус ҳангоми кор бо нишондиҳандаҳои калон.', NULL, 6, NULL)
	 

	 
	 ,(4, 1, N'Усули ду нишондиҳанда: Таъриф ва намунаҳои истифода', NULL, 1, NULL)
	 ,(4, 2, N'Усули ду нишондиҳанда (two-pointer technique) як усули маъмули алгоритмӣ мебошад, ки барои ҳалли масъалаҳо дар массивҳо е сатрҳо истифода мешавад. Ин усул аз истифодаи ду индекс (нишондиҳандаҳо) иборат аст, ки дар массив е сатр бо суръати гуногун е дар самтҳои гуногун ҳаракат мекунанд. Усули ду нишондиҳанда имкон медиҳад, ки масъалаҳои марбут ба ҷустуҷӯи зермассивҳо, санҷиши палиндромҳо, пайдо кардани ҷуфтҳо бо суммаи додашуда ва дигар вазифаҳо самаранок ҳал карда шаванд, ки аксар вақт мураккабии муваққатии қарорҳоро беҳтар мекунанд.', NULL, 2, NULL)
	 ,(4, 2, N'Намунаҳои вазифаҳо ва қарорҳо бо истифода аз усули ду нишондиҳанда', NULL, 3, NULL)
	 ,(4, 2, N'Мисоли 1: санҷиши сатр барои палиндром', NULL, 4, NULL)
	 ,(4, 2, N'Палиндром сатрест, ки аз чап ба рост ва аз рост ба чап баробар хонда мешавад. Усули ду нишоннамо ба осонӣ тафтиш мекунад, ки сатр палиндром аст е не, бо ду нишоннамо, ки аз аввал ва охири сатр оғоз ефта, ба сӯи якдигар ҳаракат мекунанд', NULL, 5, NULL)
	 ,(4, 6, N'', NULL, 6, 15)
	 ,(4, 2, N'Мисоли 2: ёфтани ҷуфти рақамҳо бо суммаи додашуда', NULL, 7, NULL)
	 ,(4, 2, N'Ин масъала аз ефтани ду рақам дар массиви мураттабшуда иборат аст, ки суммаи онҳо ба рақами додашуда баробар аст. Усули ду нишондиҳанда имкон медиҳад, ки ин масъаларо дар вақти хаттӣ ҳал кунад.', NULL, 8, NULL)
	 ,(4, 6, N'', NULL, 9, 16)
	 ,(4, 2, N'Мисоли 3: Якҷоя кардани ду массиви мураттабшуда', NULL, 10, NULL)
	 ,(4, 2, N'Усули ду нишондиҳанда инчунин метавонад барои якҷоя кардани ду массиви мураттаб ба як массиви мураттаб истифода шавад.', NULL, 11, NULL)
	 ,(4, 6, N'', NULL, 12, 17)
	 ,(4, 3, N'Хулоса', NULL, 13, NULL)
	 ,(4, 2, N'Усули ду нишондиҳанда як усули пурқуввати алгоритмист, ки барои ҳалли масъалаҳои гуногун дар массивҳо ва сатрҳо истифода мешавад. Дар ин мақола, мо якчанд мисолҳоро дида баромадем, ки чӣ гуна ин усулро барои санҷиши сатр дар палиндром, ефтани ҷуфти рақамҳо бо суммаи додашуда ва якҷоя кардани ду массиви мураттаб истифода бурдан мумкин аст. Истифодаи усули ду нишондиҳанда аксар вақт имкон медиҳад, ки мураккабии муваққатии қарорҳо ба таври назаррас беҳтар ва самараноктар карда шавад.', NULL, 14, NULL)

	 
	 ,(14, 1, N'Алгоритми Дейкстра: Таъриф Ва намунаҳои истифода', NULL, 1, NULL)
	 ,(14, 2, N'Алгоритми Дейкстра алгоритми классикии графҳо мебошад, ки барои ефтани роҳҳои кӯтоҳтарин аз як қулла то ҳамаи қуллаҳои дигари граф бо вазни манфии канораҳо истифода мешавад. Ин алгоритмро Эдсгер Дейкстрой соли 1956 пешниҳод кард ва яке аз алгоритмҳои васеъ истифодашаванда дар назарияи графҳо ва барномаҳои шабакавӣ боқӣ мемонад.', NULL, 2, NULL)
	 ,(14, 3, N'Принсипи кори алгоритм', NULL, 3, NULL)
	 ,(14, 2, N'Алгоритми Дейкстра аз рӯи принсипи тамаъкорӣ кор мекунад, ки тадриҷан маҷмӯи роҳҳои кӯтоҳтаринро аз қуллаи ибтидоӣ ба қуллаҳои дигар месозад. Дар ҳар қадам алгоритм қулларо бо арзиши камтарини маълум интихоб мекунад, арзиши роҳҳоро ба ҳамсоягони худ нав мекунад ва равандро то пайдо шудани роҳҳои кӯтоҳтарин ба ҳамаи қуллаҳо такрор мекунад.', NULL, 4, NULL)
	 ,(14, 2, N'Қадамҳои алгоритми Дейкстра', NULL, 5, NULL)
	 ,(14, 2, N'1. Оғози кор:', NULL, 6, NULL)
	 ,(14, 5, N'Қуллаи ибтидоӣ дода мешавад, ки масофаи он 0 аст.'+char(10)+N'Масофа то ҳамаи қуллаҳои дигар ба беохирӣ муқаррар карда мешавад.'+char(10)+N'Бисер қуллаҳои ташрифоварда сохта мешаванд, ки дар аввал холӣ буданд.', NULL, 7, NULL)
	 ,(14, 2, N'2. Давраи асосӣ:', NULL, 8, NULL)
	 ,(14, 5, N'Қуллаи бе ташриф бо масофаи камтарини ҷорӣ интихоб карда мешавад.'+char(10)+N'Масофаҳо ба ҳамсоягонаш нав карда мешаванд, агар роҳро тавассути қуллаи кунунӣ беҳтар кардан мумкин бошад.'+char(10)+N'Қуллаи ҷорӣ ба шумораи зиеди меҳмонон илова карда мешавад.', NULL, 9, NULL)
	 ,(14, 2, N'3. Анҷом:', NULL, 10, NULL)
	 ,(14, 5, N'Алгоритм вақте ба анҷом мерасад, ки ҳамаи қуллаҳо ба он ҷо ташриф овардаанд е вақте ки ҳамаи қуллаҳои боқимондаи ба он ҷо нарафта дастрас нестанд (масофаи беохир доранд).', NULL, 11, NULL)
	 ,(14, 2, N'Татбиқи алгоритми Дейкстра', NULL, 12, NULL)
	 ,(14, 6, N'', NULL, 13, 18)
	 ,(14, 3, N'Истифодаи алгоритми Дейкстра', NULL, 14, NULL)
	 ,(14, 2, N'Алгоритми Дейкстра дар соҳаҳои гуногун васеъ истифода мешавад, аз ҷумла:', NULL, 15, NULL)
	 ,(14, 5, N'Роутерҳои шабакавӣ: Муайян кардани роҳҳои кӯтоҳтарин барои интиқоли маълумот тавассути шабака;'+char(10)+N'Системаҳои навигатсионӣ: сохтани хатсайрҳо дар харитаҳо ва GPS;'+char(10)+N'Системаҳои нақлиетӣ: Оптимизатсияи хатсайрҳо барои нақлиети ҷамъиятӣ ва логистика;'+char(10)+N'Барномаҳои бозӣ: дарефти роҳҳо барои аломатҳо ва объектҳо дар бозиҳо.', NULL, 16, NULL)
	 ,(14, 3, N'Хулоса', NULL, 17, NULL)
	 ,(14, 2, N'Алгоритми Дейкстра воситаи пурқувват ва самаранок барои ефтани роҳҳои кӯтоҳтарин дар графҳо мебошад. Он дар соҳаҳои гуногун, аз алоқаи шабакавӣ то бозиҳо то системаҳои навигатсионӣ васеъ истифода мешавад. Бо истифода аз алгоритми Дейкстра, шумо метавонед вазифаҳои мураккаби оптимизатсия ва ҷустуҷӯи роҳҳоро ҳал кунед, дар ҳоле ки иҷрои баланд ва дақиқии қарорҳоро таъмин кунед.', NULL, 18, NULL)

	 
	 ,(22, 1, N'Ҷойгиркунии n-маликаҳо дар тахтаи шоҳмот: мушкилот ва усулҳои ҳалли', NULL, 1, NULL)
	 ,(22, 2, N'Масъалаи Ҷойгиркунии n-ферзҳо дар тахтаи шоҳмот яке аз масъалаҳои классикии оптимизатсияи комбинаторӣ мебошад. Ин масъала талаб Мекунад, ки N ферз дар тахтаи Андозаи N×N ҷойгир карда шавад, то ки ҳеҷ кадоме аз онҳо зери ҳамлаи ферзи дигар набошад. Ферз метавонад ба ҳар як фигураи дар ҳамон уфуқ, амудӣ е диагоналӣ ҷойгиршуда ҳамла кунад.', NULL, 2, NULL)
	 ,(22, 2, N'Муқаррар кардани вазифа', NULL, 3, NULL)
	 ,(22, 2, N'Бигзор тахтаи шоҳмот Бо Андозаи N×N дода Шавад. Вазифа аз ин иборат Аст:', NULL, 4, NULL)
	 ,(22, 5, N'N маликаро дар тахта тавре ҷойгир кунед, ки ҳеҷ яке аз онҳо зери ҳамлаи дигаре набошад.'+char(10)+N'Ҳар як сатр ва ҳар як сутун бояд маҳз як малика дошта бошад.', NULL, 5, NULL)
	 ,(22, 2, N'Усулҳои ҳалли:', NULL, 6, NULL)
	 ,(22, 2, N'Якчанд усулҳои ҳалли масъалаи Ҷойгиркунии n-ферзҳо мавҷуданд, аз ҷумла алгоритмҳои рекурсивӣ, усулҳои ҷустуҷӯи бозгашт ва равишҳои эвристикӣ. Дар зер ду усули маъмулро дида мебароем: алгоритми рекурсивӣ ва усули "алгоритми Генетикӣ".', NULL, 7, NULL)
	 ,(22, 3, N'1. Алгоритми рекурсивӣ', NULL, 8, NULL)
	 ,(22, 2, N'Яке аз роҳҳои маъруф ва осонтарини ҳалли масъалаи ҷойгиркунии n-ферзҳо алгоритми рекурсивии баргардонидашуда мебошад. Ин усул кӯшиши ҷойгир кардани ҳар як малика дар навбати аввал аз қатори аввал иборат аст. Дар ин ҳолат барои ҳар як қатор санҷида мешавад, ки ое ферз дар хатари ҳамлаи ферзи дигар қарор дорад е не. Агар малика дар хатар бошад, вай ба мавқеи навбатии дастрас мегузарад. Агар чунин мавқеъ пайдо нашавад, алгоритм ба қафо бармегардад ва ҷойгиршавии ферзи пештараро тағйир медиҳад.', NULL, 9, NULL)
	 ,(22, 2, N'Намунаи татбиқ:', NULL, 10, NULL)
	 ,(22, 6, N'', NULL, 11, 19)
	 ,(22, 3, N'2. Усули "алгоритми Генетикӣ"', NULL, 12, NULL)
	 ,(22, 2, N'Роҳи дигари ҳалли масъалаи Ҷойгиркунии n-ферзҳо истифодаи усули эвристикӣ, ба монанди алгоритми Генетикӣ мебошад. Дар ин усул шумораи ибтидоии ҷойгиркунии ферзҳо дар тахта ба вуҷуд меояд. Сипас амалиети салибкунӣ, мутатсия ва интихоб барои эҷоди наслҳои нави ҷойгиркунӣ истифода мешаванд. Эволютсия то пайдо шудани ҳалли масъала е ба даст овардани шумораи максималии наслҳо идома меебад.', NULL, 13, NULL)
	 ,(22, 2, N'Намунаи татбиқ:', NULL, 14, NULL)
	 ,(22, 6, N'', NULL, 15, 20)

	 
	 ,(23, 1, N'Рақамҳои ибтидоӣ: Таъриф Ва усулҳои санҷиш', NULL, 1, NULL)
	 ,(23, 2, N'Рақамҳои ибтидоӣ рақамҳои табиӣ мебошанд, ки маҳз ду тақсимкунандаи гуногуни табиӣ доранд: 1 ва худи ин рақам. Ба ибораи дигар, адади оддӣ ададест, ки танҳо ба 1 ва ба худ тақсим мешавад. Масалан, рақамҳои 2, 3, 5, 7 ва 11 оддӣ мебошанд, дар ҳоле ки рақамҳои 4, 6, 8 ва 9 оддӣ нестанд, зеро онҳо зиеда аз ду тақсимкунанда доранд.', NULL, 2, NULL)
	 ,(23, 2, N'Рақамҳои ибтидоӣ дар соҳаҳои гуногуни математика ва илмҳои компютерӣ, махсусан дар соҳаҳое, ба монанди криптография, ки онҳо барои рамзгузории маълумот истифода мешаванд, нақши калидӣ доранд.', NULL, 3, NULL)
	 ,(23, 2, N'Тафтиши рақам барои соддагӣ', NULL, 4, NULL)
	 ,(23, 2, N'Барои оғоз кардан, алгоритми оддиро дида мебароем, ки санҷидани он, ки ое рақам оддӣ аст, аз 1 то N гузаштани ҳамаи рақамҳо.', NULL, 5, NULL)
	 ,(23, 6, N'', NULL, 6, 21)
	 ,(23, 2, N'Ин рамз ҳар як рақамро аз 1 То N бо истифода аз функсияи `is_prime`пай дар пай месанҷад. Агар рақам ба ягон рақам аз 2 то n-1 тақсим карда шавад, он оддӣ нест.', NULL, 7, NULL)
	 ,(23, 3, N'Оптимизатсия: Санҷиш то N/2', NULL, 8, NULL)
	 ,(23, 2, N'Мо метавонем ин алгоритмро бо санҷиши тақсимкунандагон танҳо То N/2 оптимизатсия кунем. Ин аз он сабаб аст, ки рақамҳое, ки аз n/2 калонтар ва Аз N хурдтаранд, Ба N тақсим намешаванд.', NULL, 9, NULL)
	 ,(23, 6, N'', NULL, 10, 22)
	 ,(23, 3, N'Оптимизатсия: Санҷиш ба √(N)', NULL, 11, NULL)
	 ,(23, 2, N'Барои оптимизатсияи боз ҳам бештар тақсимкунандаҳоро танҳо то √(N) санҷидан мумкин аст. Агар адад оддӣ набошад, пас он ҳадди аққал ду адад дорад, ки бояд аз решаи адади ибтидоӣ камтар(ё баробар) бошанд, вагарна ҳосили онҳо аз адади ибтидоӣ калонтар хоҳад буд, аз ин рӯ, аз рақамҳои минбаъда гузаштан маъно надорад.', NULL, 12, NULL)
	 ,(23, 6, N'', NULL, 13, 23)
	 ,(23, 2, N'Хулоса', NULL, 14, NULL)
	 ,(23, 2, N'Рақамҳои ибтидоӣ дар математика ва илмҳои компютерӣ асосӣ мебошанд. Мо усулҳои гуногуни санҷиши рақамро барои соддагӣ, аз алгоритми оддӣ сар карда, ҳамаи тақсимкунандаҳои имконпазирро то усулҳои оптимизатсияшуда бо истифода аз хосиятҳои тақсимшаванда баррасӣ кардем. Усули охирин, ки тақсимкунандаҳоро то `√(N)` месанҷад, аз ҳама самараноктарин аст ва дар амал васеъ истифода мешавад.', NULL, 15, NULL)

	 
	 ,(24, 1, N'Алгоритмҳои тасодуфӣ: Мафҳум ва татбиқ', NULL, 1, NULL)
	 ,(24, 2, N'Алгоритмҳои тасодуфӣ алгоритмҳое мебошанд, ки рақамҳои тасодуфиро барои қабули қарорҳо дар ҷараени иҷро истифода мебаранд. Баръакси алгоритмҳои муайяншуда, ки ҳамеша ҳамон амалҳоро барои як вуруд иҷро мекунанд, алгоритмҳои тасодуфӣ метавонанд дар ҳар як оғози ҳамон маълумот гуногун рафтор кунанд. Ин онҳоро абзорҳои тавоно барои ҳалли мушкилоти гуногун месозад, ки дар он ҷо тасодуфӣ метавонад иҷроишро ба таври назаррас беҳтар кунад е татбиқи онро осонтар кунад.', NULL, 2, NULL)
	 ,(24, 2, N'Принсипҳои алгоритмҳои тасодуфӣ', NULL, 3, NULL)
	 ,(24, 2, N'Алгоритмҳои тасодуфӣ ба ду категорияи асосӣ тақсим мешаванд:', NULL, 4, NULL)
	 ,(24, 5, N'Лас Вегас алгоритмҳо: дурустии ҳалли масъаларо Кафолат Медиҳанд, аммо вақти иҷро миқдори тасодуфӣ мебошад. Мисол: намунаи тасодуфӣ барои ҷобаҷогузорӣ;'+char(10)+N'Монте-Карло алгоритмҳо: дурустии қарорро кафолат Намедиҳанд, аммо дар вақти муайян кор мекунанд. Мисол: санҷиши соддагии рақам.', NULL, 5, NULL)
	 ,(24, 2, N'Намунаҳои татбиқ:', NULL, 6, NULL)
	 ,(24, 5, N'Ҷобаҷогузорӣ ва ҷустуҷӯ: ҷобаҷогузории Зуд (Quicksort) бо интихоби тасодуфии унсури дастгирӣ.'+char(10)+N'Оптимизатсия: Алгоритмҳои Ба Монте Карло асосефта барои ҷустуҷӯи оптимуми глобалӣ дар функсияҳои мураккаб.'+char(10)+N'Тавлиди рақамҳо: истифодаи алгоритмҳои тасодуфӣ барои тавлиди рақамҳои тасодуфӣ.'+char(10)+N'Криптография: Тавлиди калидҳо ва дигар амалиети криптографӣ, ки дар он тасодуфӣ нақши калидӣ мебозад.', NULL, 7, NULL)
	 ,(24, 2, N'Намунаи алгоритми тасодуфӣ: ҷамъбасти Зуд', NULL, 8, NULL)
	 ,(24, 2, N'Ҷамъбасти зуд(Quicksort) алгоритми маъмули ҷудокунӣ мебошад, ки ба ҳисоби миена мураккабии Вақти O (n log n) дорад. Ҳангоми истифодаи тасодуфӣ, Quicksort унсури асосиро ба таври тасодуфӣ интихоб мекунад, ки эҳтимолияти бадтарин ҳолатро коҳиш медиҳад, ки мураккабии Муваққатии O(n^2) дорад.', NULL, 9, NULL)
	 ,(24, 2, N'Татбиқи Quicksort', NULL, 10, NULL)
	 ,(24, 6, N'', NULL, 11, 24)
	 ,(24, 2, N'Афзалиятҳои алгоритмҳои тасодуфӣ', NULL, 12, NULL)
	 ,(24, 5, N'Осонии татбиқ: дар баъзе ҳолатҳо, тасодуфӣ метавонад алгоритмро хеле содда кунад.'+char(10)+N'Баланд бардоштани ҳосилнокӣ: интихоби Тасодуфӣ метавонад бадтарин ҳолатҳоро пешгирӣ кунад ва иҷрои миенаро беҳтар кунад.'+char(10)+N'Универсалӣ: алгоритмҳои Тасодуфӣ метавонанд дар соҳаҳои гуногун, аз ҷобаҷогузорӣ то криптография то омӯзиши мошинсозӣ татбиқ карда шаванд.', NULL, 13, NULL)
	 ,(24, 2, N'Камбудиҳои алгоритмҳои тасодуфӣ', NULL, 14, NULL)
	 ,(24, 5, N'Номуайянӣ: Азбаски натиҷаҳо метавонанд дар ҳар як оғоз фарқ кунанд, ислоҳ ва озмоиши чунин алгоритмҳо душвор буда метавонад.'+char(10)+N'Талаботи генераторҳои рақамҳои тасодуфӣ: Самаранокии алгоритмҳои тасодуфӣ аз сифати генераторҳои рақамҳои тасодуфӣ вобаста аст.', NULL, 15, NULL)
	 ,(24, 3, N'Хулоса', NULL, 16, NULL)
	 ,(24, 2, N'Алгоритмҳои тасодуфӣ воситаи пурқувват дар арсенали барномасозон ва муҳаққиқон барои ҳалли масъалаҳои мураккаб самараноктар ва соддатар мебошанд. Истифодаи рақамҳои тасодуфӣ метавонад иҷрои алгоритмҳо ва мутобиқати онҳоро ба ҳолатҳои гуногун ба таври назаррас беҳтар кунад. Фаҳмидани ҳам афзалиятҳо ва ҳам маҳдудиятҳои ин алгоритмҳо барои истифодаи беҳтарини онҳо муҳим аст.', NULL, 17, NULL)


	 
	 ,(25, 1, N'Мушкилоти ҷузвдон: Мафҳум ва усулҳои ҳалли', NULL, 1, NULL)
	 ,(25, 2, N'Масъалаи халта (Knapsack Problem) яке аз масъалаҳои классикии оптимизатсияи комбинаторӣ мебошад. Дар ин масъала бояд аз бисер ашеҳо зергурӯҳеро интихоб кард, ки арзиши умумии он ҳадди аксар аст ва вазни умумии он аз маҳдудияти додашуда зиед нест.', NULL, 2, NULL)
	 ,(25, 2, N'Муқаррар кардани вазифа', NULL, 3, NULL)
	 ,(25, 2, N'Маҷмӯи ашеҳо мавҷуданд, ки ҳар кадоми онҳо вазн ва арзиши муайян доранд. Ин маҷмӯи ашеро интихоб кардан лозим аст, то ки арзиши умумии онҳо ҳадди аксар бошад ва вазни умумии онҳо аз маҳдудияти додашуда зиед набошад.', NULL, 4, NULL)
	 ,(25, 2, N'Танзимоти расмӣ', NULL, 5, NULL)
	 ,(25, 5, N'Бигзор N — шумораи ашё.'+char(10)+N'Бигзор wi — вазни ашёi.'+char(10)+N'Бигзор vi — арзиши ашё i.'+char(10)+N'Бигзор W — вазни максималии иҷозатдодашуда.', NULL, 6, NULL)
	 ,(25, 2, N'Мо бояд зергурӯҳи ашеи S-ро пайдо кунем, ки:', NULL, 7, NULL)
	 ,(25, 2, N'$$\sum_{i \in S} w_i \leq W$$', NULL, 8, NULL)
	 ,(25, 2, N'ва', NULL, 9, NULL)
	 ,(25, 2, N'$$\sum_{i \in S} v_i$$', NULL, 10, NULL)
	 ,(25, 2, N'ба қадри имкон.', NULL, 11, NULL)
	 ,(25, 3, N'Усулҳои ҳалли', NULL, 12, NULL)
	 ,(25, 2, N'Якчанд равишҳо барои ҳалли масъалаи ҷузвдон мавҷуданд:', NULL, 13, NULL)
	 ,(25, 5, N'Алгоритми тамаъҷӯӣ.'+char(10)+N'Усули барномасозии динамикӣ.'+char(10)+N'Алгоритмҳои комбинатсионӣ.', NULL, 14, NULL)
	 ,(25, 2, N'Биеед ҳар яке аз ин усулҳоро муфассалтар дида бароем.', NULL, 15, NULL)
	 ,(25, 3, N'1. Алгоритми тамаъҷӯӣ', NULL, 16, NULL)
	 ,(25, 2, N'Алгоритми тамаъҷӯӣ аксар вақт барои ҳалли масъалаи халта бо ашеи хароб (Fractional Knapsack Problem) истифода мешавад, ки дар он ашеро шикастан мумкин аст. Дар ин ҳолат усули зерин истифода мешавад:', NULL, 17, NULL)
	 ,(25, 5, N'Арзиши воҳиди вазнро барои ҳар як ашеи `vi / wi` ҳисоб кунед.'+char(10)+N'Ашеро аз рӯи камшавии ин арзиш ҷобаҷо кунед.'+char(10)+N'То он даме, ки маҳдудияти вазн имкон медиҳад, ашеро ба ҷузвдон пайваста илова кунед.', NULL, 18, NULL)
	 ,(25, 2, N'Намунаи татбиқи алгоритми тамаъҷӯӣ:', NULL, 19, NULL)
	 ,(25, 6, N'', NULL, 20, 25)
	 ,(25, 1, N'2. Усули барномасозии динамикӣ', NULL, 21, NULL)
	 ,(25, 2, N'Усули барномасозии динамикӣ барои ҳалли масъалаи халта, ки дар он ашеро шикастан мумкин нест (0/1 Knapsack Problem) мувофиқ аст. Ин усул массиви дуҷонибаро барои нигоҳ доштани арзиши максималии аше барои ҳар як вазни имконпазир истифода мебарад.', NULL, 22, NULL)
	 ,(25, 2, N'Намунаи татбиқи барномасозии динамикӣ:', NULL, 23, NULL)
	 ,(25, 6, N'', NULL, 24, 26)
	 ,(25, 2, N'3. Алгоритмҳои комбинатсионӣ', NULL, 25, NULL)
	 ,(25, 2, N'Алгоритмҳои комбинаторӣ усулҳои пурра ва шохаҳо ва сарҳадҳоро дар бар мегиранд. Ин усулҳо меҳнатталабтаранд ва аксар вақт барои вазифаҳои хурд е ҳалли дақиқ ҳангоми имконнопазирии истифодаи усулҳои дигар истифода мешаванд.', NULL, 26, NULL)
	 ,(25, 3, N'Хулоса', NULL, 27, NULL)
	 ,(25, 2, N'Мушкилоти борхалта як масъалаи муҳими оптимизатсияи комбинатсия бо доираи васеи барномаҳо дар соҳаҳои гуногун, ба монанди иқтисод, логистика ва информатика мебошад. Вобаста аз шароити вазифа ва талабот ба дақиқии ҳалли он, усулҳои гуногун, аз қабили алгоритмҳои чашмгурусна, барномасозии динамикӣ е равишҳои комбинатсионӣ метавонанд истифода шаванд.', NULL, 28, NULL)

	 
	 ,(26, 1, N'Масофа дар шабака: барномасозии Динамикӣ дар асоси шабака', NULL, 1, NULL)
	 ,(26, 2, N'Масофа дар шабака (Grid Based Distance) ин синфи масъалаҳоест, ки бо барномасозии динамикӣ ҳал карда мешаванд, ки дар он шумо бояд роҳи беҳтарин е масофаи ҳадди ақалро дар шабакаи дуҷониба пайдо кунед. Ин равиш аксар вақт барои ҳалли мушкилот дар графикҳо, масир ва оптимизатсия истифода мешавад.', NULL, 2, NULL)
	 ,(26, 3, N'Муқаррар кардани вазифа', NULL, 3, NULL)
	 ,(26, 2, N'Масъалаи ёфтани роҳи ҳадди ақалро аз кунҷи болоии чапи шабака ба кунҷи поении рост дида мебароем. Ҳар як ҳуҷайраи шабака арзиш дорад ва мушкилот дар он аст, ки роҳро бо арзиши ҳадди ақал пайдо кунед.', NULL, 4, NULL)
	 ,(26, 3, N'Намоиши расмӣ', NULL, 5, NULL)
	 ,(26, 2, N'Шабакаи андозаи <code>m × n</code> мавҷуд аст, ки дар он ҳар як ҳуҷайра <code>(i, j)</code> арзиши <code>grid[i][j]</code> дорад. Роҳро аз ҳуҷайра <code>(0, 0)</code> ба ҳуҷайра <code>(m-1, n-1)</code> бо арзиши ҳадди ақал пайдо кардан лозим аст.', NULL, 6, NULL)
	 ,(26, 3, N'Усули барномасозии динамикӣ', NULL, 7, NULL)
	 ,(26, 2, N'Барои ҳалли масъала бо истифода аз барномасозии динамикӣ массиви дуҷонибаи <code>dp</code> сохта мешавад, ки дар он <code>dp[i][j]</code> арзиши ҳадди ақали роҳро то ҳуҷайра <code>(i, j)</code> нигоҳ медорад.', NULL, 8, NULL)
	 ,(26, 2, N'Идеяи асосӣ:', NULL, 9, NULL)
	 ,(26, 5, N'Инициализатсия: ҳуҷайраи Ибтидоӣ <code>dp[0][0]</code> арзиши <code>grid[0][0]</code> - ро қабул мекунад.'+char(10)+N'Таносуби такрорӣ: барои ҳар як ҳуҷайра <code>(i, j)</code>, арзиши ҳадди ақали роҳ ба он ба арзиши ин ҳуҷайра ва ҳадди ақали арзиши роҳ ба ҳуҷайраҳои ҳамсоя аз боло ва чап баробар хоҳад буд: $$dp[i][j] = grid[i][j] + \min(dp[i-1][j], dp[i][j-1])$$'+char(10)+N'Сарҳадҳо: барои сатри аввал ва сутуни аввал, роҳ танҳо аз як ҳуҷайраи ҳамсоя имконпазир аст.', NULL, 10, NULL)
	 ,(26, 3, N'Намунаи татбиқ ', NULL, 11, NULL)
	 ,(26, 6, N'', NULL, 12, 27)
	 ,(26, 3, N'Афзалиятҳо ва нуқсонҳои равиш', NULL, 13, NULL)
	 ,(26, 2, N'Афзалиятҳо:', NULL, 14, NULL)
	 ,(26, 5, N'Оптималӣ: барномасозии Динамикӣ ҳалли оптималиро бо назардошти ҳамаи роҳҳои имконпазир пайдо мекунад.'+char(10)+N'Самаранокӣ: Истифодаи мемоизатсия имкон медиҳад, ки ҳисобҳои такрорӣ пешгирӣ карда шаванд, ки ин раванди ҳалли масъаларо суръат мебахшад.'+char(10)+N'Универсалӣ: Равишро барои намудҳои гуногуни шабакаҳо ва шароити иловагӣ мутобиқ кардан мумкин аст.', NULL, 15, NULL)
	 ,(26, 2, N'Камбудиҳо', NULL, 16, NULL)
	 ,(26, 5, N'Истеъмоли хотира: эҷоди массиви дуҷониба хароҷоти назарраси хотираро талаб мекунад, махсусан барои шабакаҳои калон.'+char(10)+N'Мушкилии татбиқ: вазифаҳои мураккаб коркарди ҳамаҷонибаи таносуби такрорӣ ва шароити сарҳадро талаб мекунанд.', NULL, 17, NULL)
	 ,(26, 3, N'Хулоса', NULL, 18, NULL)
	 ,(26, 2, N'Вазифаҳои шабакавӣ бо истифода аз барномасозии динамикӣ воситаи пурқувват барои ҳалли вазифаҳои гуногуни оптимизатсия мебошанд. Усул ба шумо имкон медиҳад, ки роҳҳои оптималӣ ва арзиши ҳадди ақалро бо истифодаи самараноки захираҳо ва бо назардошти ҳамаи имконоти имконпазир пайдо кунед. Равишро дар доираи васеи соҳаҳо, аз масир ва логистика то робототехника ва зеҳни сунъӣ татбиқ кардан мумкин аст.', NULL, 19, NULL)


GO

INSERT INTO CodeInLang(CodeListId, LanguageId, Code)
VALUES(1, 1, N'def linear_search(arr, target):'+char(10)+N'    for i in range(len(arr)):'+char(10)+N'        if arr[i] == target:'+char(10)+N'            return i'+char(10)+N'    return -1'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'arr = [10, 20, 30, 40, 50]'+char(10)+N'target = 30'+char(10)+N'result = linear_search(arr, target)'+char(10)+N'if result != -1:'+char(10)+N'    print("Элементи", target, "ёфта шуд дар индекси", result)'+char(10)+N'else:'+char(10)+N'    print("Элементи", target, "ёфта нашуд")')
,(1, 2, '#include <iostream>'+char(10)+N'using namespace std;'+char(10)+N'int main() {'+char(10)+N'    int arr[7] = { 1, 3, 5, 7, 9, 11, 13 };'+char(10)+N'    int target = 7, result = -1;'+char(10)+N'    for(int i=0; i < 7; i++) {'+char(10)+N'        if(arr[i] == target) {'+char(10)+N'            result = i;'+char(10)+N'            cout << "Элемент найден в позиции " << i << ".";'+char(10)+N'            break;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    if(result != -1)'+char(10)+N'        cout << "Элемент ёфта шуд дар индекси " << i << ".";'+char(10)+N'    else'+char(10)+N'        cout << "Элемент ёфта нашуд.";'+char(10)+N'}')
,(1, 3, N'using System;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        int[] arr = { 1, 3, 5, 7, 9, 11, 13 };'+char(10)+N'        int target = 7;'+char(10)+N'        int result = -1;'+char(10)+N''+char(10)+N'        for (int i = 0; i < 7; i++)'+char(10)+N'        {'+char(10)+N'            if (arr[i] == target)'+char(10)+N'            {'+char(10)+N'                result = i;'+char(10)+N'                break;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        if (result != -1)'+char(10)+N'        {'+char(10)+N'            Console.WriteLine("Элемент ёфта шуд дар индекси " + i + ".");'+char(10)+N'        }'+char(10)+N'        else'+char(10)+N'        {'+char(10)+N'            Console.WriteLine("Элемент ёфта нашуд.");'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(1, 4, N'public class Main {'+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int[] arr = { 1, 3, 5, 7, 9, 11, 13 };'+char(10)+N'        int target = 7;'+char(10)+N'        int result = -1;'+char(10)+N''+char(10)+N'        for (int i = 0; i < arr.length; i++) {'+char(10)+N'            if (arr[i] == target) {'+char(10)+N'                result = i;'+char(10)+N'                break;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        if (result != -1) {'+char(10)+N'            System.out.println("Элемент ёфта шуд дар индекси " + result + ".");'+char(10)+N'        } else {'+char(10)+N'            System.out.println("Элемент ёфта нашуд.");'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(1, 5, N'DIM arr(6) AS INTEGER'+char(10)+N'DIM target AS INTEGER'+char(10)+N'DIM result AS INTEGER'+char(10)+N'DIM i AS INTEGER'+char(10)+char(10)+NCHAR(39)+N' Оғоз кардани массив'+char(10)+N'arr(0) = 1'+char(10)+N'arr(1) = 3'+char(10)+N'arr(2) = 5'+char(10)+N'arr(3) = 7'+char(10)+N'arr(4) = 9'+char(10)+N'arr(5) = 11'+char(10)+N'arr(6) = 13'+char(10)+N''+char(10)+N'target = 7'+char(10)+N'result = -1'+char(10)+N''+char(10)+N'FOR i = 0 TO 6'+char(10)+N'    IF arr(i) = target THEN'+char(10)+N'        result = i'+char(10)+N'        EXIT FOR'+char(10)+N'    END IF'+char(10)+N'NEXT i'+char(10)+N''+char(10)+N''' Вывод результата'+char(10)+N'IF result <> -1 THEN'+char(10)+N'    PRINT "Элемент ёфта шуд дар индекси " + i + "."'+char(10)+N'ELSE'+char(10)+N'    PRINT "Элемент ёфта нашуд."'+char(10)+N'END IF')

,(2, 1, N'def euclidean_algorithm(a, b):'+char(10)+N'    while b != 0:'+char(10)+N'        a, b = b, a % b'+char(10)+N'    return a'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'num1 = 48'+char(10)+N'num2 = 18'+char(10)+N'gcd = euclidean_algorithm(num1, num2)'+char(10)+N'print("Калонтарин тақсимкунандаи умумии рақамҳои", num1, "ва", num2, "бароюар аст ба", gcd)')
,(2, 2, N'#include <iostream>'+char(10)+N''+char(10)+N'int euclidean_algorithm(int a, int b) {'+char(10)+N'    while (b != 0) {'+char(10)+N'        int temp = b;'+char(10)+N'        b = a % b;'+char(10)+N'        a = temp;'+char(10)+N'    }'+char(10)+N'    return a;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    int num1 = 48;'+char(10)+N'    int num2 = 18;'+char(10)+N'    int gcd = euclidean_algorithm(num1, num2);'+char(10)+N'    std::cout << "Калонтарин тақсимкунандаи умумии рақамҳои " << num1 << " ва " << num2 << " бароюар аст ба " << gcd << std::endl;'+char(10)+N'    return 0;'+char(10)+N'}')
,(2, 3, N'using System;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static int EuclideanAlgorithm(int a, int b)'+char(10)+N'    {'+char(10)+N'        while (b != 0)'+char(10)+N'        {'+char(10)+N'            int temp = b;'+char(10)+N'            b = a % b;'+char(10)+N'            a = temp;'+char(10)+N'        }'+char(10)+N'        return a;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        int num1 = 48;'+char(10)+N'        int num2 = 18;'+char(10)+N'        int gcd = EuclideanAlgorithm(num1, num2);'+char(10)+N'        Console.WriteLine($"Калонтарин тақсимкунандаи умумии рақамҳои {num1} ва {num2} бароюар аст ба {gcd}");'+char(10)+N'    }'+char(10)+N'}')
,(2, 4, N'public class Main {'+char(10)+N'    static int euclideanAlgorithm(int a, int b) {'+char(10)+N'        while (b != 0) {'+char(10)+N'            int temp = b;'+char(10)+N'            b = a % b;'+char(10)+N'            a = temp;'+char(10)+N'        }'+char(10)+N'        return a;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int num1 = 48;'+char(10)+N'        int num2 = 18;'+char(10)+N'        int gcd = euclideanAlgorithm(num1, num2);'+char(10)+N'        System.out.println("Калонтарин тақсимкунандаи умумии рақамҳои " + num1 + " ва " + num2 + " бароюар аст ба " + gcd);'+char(10)+N'    }'+char(10)+N'}')
,(2, 5, N'FUNCTION EuclideanAlgorithm(a, b)'+char(10)+N'    WHILE b <> 0'+char(10)+N'        temp = b'+char(10)+N'        b = a MOD b'+char(10)+N'        a = temp'+char(10)+N'    WEND'+char(10)+N'    EuclideanAlgorithm = a'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Намунаи истифода'+char(10)+N'num1 = 48'+char(10)+N'num2 = 18'+char(10)+N'gcd = EuclideanAlgorithm(num1, num2)'+char(10)+N'PRINT "Калонтарин тақсимкунандаи умумии рақамҳои "; num1; " ва "; num2; " бароюар аст ба "; gcd')

,(3, 1, N'import heapq'+char(10)+'from collections import defaultdict'+char(10)+''+char(10)+'def huffman_coding(freq):'+char(10)+'    heap = [[weight, [symbol, ""]] for symbol, weight in freq.items()]'+char(10)+'    heapq.heapify(heap)'+char(10)+'    while len(heap) > 1:'+char(10)+'        lo = heapq.heappop(heap)'+char(10)+'        hi = heapq.heappop(heap)'+char(10)+'        for pair in lo[1:]:'+char(10)+'            pair[1] = "0" + pair[1]'+char(10)+'        for pair in hi[1:]:'+char(10)+'            pair[1] = "1" + pair[1]'+char(10)+'        heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])'+char(10)+'    return sorted(heapq.heappop(heap)[1:], key=lambda p: (len(p[-1]), p))'+char(10)+''+char(10)+N'# Пример использования'+char(10)+'data = "hello"'+char(10)+'freq = defaultdict(int)'+char(10)+'for symbol in data:'+char(10)+'    freq[symbol] += 1'+char(10)+'huff_codes = huffman_coding(freq)'+char(10)+N'print("Символ\tЧастота\tКод Хаффмана")'+char(10)+'for symbol, f in freq.items():'+char(10)+'    code = [x[1] for x in huff_codes if x[0] == symbol][0]'+char(10)+'    print(f"{symbol}\t{f}\t{code}")')
,(3, 2, N'#include <iostream>'+char(10)+N'#include <queue>'+char(10)+N'#include <map>'+char(10)+N'#include <vector>'+char(10)+N'#include <algorithm>'+char(10)+N''+char(10)+N'using namespace std;'+char(10)+N''+char(10)+N'struct HuffmanNode {'+char(10)+N'    char symbol;'+char(10)+N'    int frequency;'+char(10)+N'    string code;'+char(10)+N'    HuffmanNode* left;'+char(10)+N'    HuffmanNode* right;'+char(10)+N''+char(10)+N'    HuffmanNode(char symbol, int frequency) : symbol(symbol), frequency(frequency), code(""), left(nullptr), right(nullptr) {}'+char(10)+N''+char(10)+N'    bool operator<(const HuffmanNode& other) const {'+char(10)+N'        return frequency > other.frequency; // Барои min-heap'+char(10)+N'    }'+char(10)+N'};'+char(10)+N''+char(10)+N'vector<HuffmanNode> HuffmanCoding(map<char, int>& freq) {'+char(10)+N'    priority_queue<HuffmanNode> heap;'+char(10)+N'    for (auto& pair : freq) {'+char(10)+N'        heap.push(HuffmanNode(pair.first, pair.second));'+char(10)+N'    }'+char(10)+N''+char(10)+N'    while (heap.size() > 1) {'+char(10)+N'        HuffmanNode* lo = new HuffmanNode(heap.top().symbol, heap.top().frequency);'+char(10)+N'        heap.pop();'+char(10)+N'        HuffmanNode* hi = new HuffmanNode(heap.top().symbol, heap.top().frequency);'+char(10)+N'        heap.pop();'+char(10)+N''+char(10)+N'        lo->code = "0" + lo->code;'+char(10)+N'        hi->code = "1" + hi->code;'+char(10)+N''+char(10)+N'        heap.push(HuffmanNode(''\0'', lo->frequency + hi->frequency));'+char(10)+N'        heap.top().left = lo;'+char(10)+N'        heap.top().right = hi;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    vector<HuffmanNode> result(heap.size());'+char(10)+N'    int i = 0;'+char(10)+N'    while (!heap.empty()) {'+char(10)+N'        result[i++] = heap.top();'+char(10)+N'        heap.pop();'+char(10)+N'    }'+char(10)+N''+char(10)+N'    // Рамзҳоро аз рӯи дарозӣ ва аломат ҷудо кунед'+char(10)+N'    sort(result.begin(), result.end(), [](const HuffmanNode& a, const HuffmanNode& b) {'+char(10)+N'        if (a.code.length() != b.code.length())'+char(10)+N'            return a.code.length() < b.code.length();'+char(10)+N'        return a.symbol < b.symbol;'+char(10)+N'    });'+char(10)+N''+char(10)+N'    return result;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    string data = "hello";'+char(10)+N'    map<char, int> freq;'+char(10)+N'    for (char symbol : data) {'+char(10)+N'        freq[symbol]++;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    vector<HuffmanNode> huffCodes = HuffmanCoding(freq);'+char(10)+N'    cout << "Рамз  Басомад  Рамзи Хаффман" << endl;'+char(10)+N'    for (auto& node : huffCodes) {'+char(10)+N'        cout << node.symbol << "  " << node.frequency << "  " << node.code << endl;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    return 0;'+char(10)+N'}')
,(3, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N'using System.Linq;'+char(10)+N''+char(10)+N'public class HuffmanNode : IComparable<HuffmanNode>'+char(10)+N'{'+char(10)+N'    public char Symbol { get; set; }'+char(10)+N'    public int Frequency { get; set; }'+char(10)+N'    public string Code { get; set; }'+char(10)+N'    public HuffmanNode Left { get; set; }'+char(10)+N'    public HuffmanNode Right { get; set; }'+char(10)+N''+char(10)+N'    public HuffmanNode(char symbol, int frequency)'+char(10)+N'    {'+char(10)+N'        Symbol = symbol;'+char(10)+N'        Frequency = frequency;'+char(10)+N'        Code = "";'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public int CompareTo(HuffmanNode other)'+char(10)+N'    {'+char(10)+N'        return Frequency.CompareTo(other.Frequency);'+char(10)+N'    }'+char(10)+N'}'+char(10)+N''+char(10)+N'public class Program'+char(10)+N'{'+char(10)+N'    public static List<HuffmanNode> HuffmanCoding(Dictionary<char, int> freq)'+char(10)+N'    {'+char(10)+N'        var nodes = freq.Select(x => new HuffmanNode(x.Key, x.Value)).ToList();'+char(10)+N'        var heap = new PriorityQueue<HuffmanNode, int>(nodes, Comparer<HuffmanNode>.Default);'+char(10)+N''+char(10)+N'        while (heap.Count > 1)'+char(10)+N'        {'+char(10)+N'            var lo = heap.Dequeue();'+char(10)+N'            var hi = heap.Dequeue();'+char(10)+N''+char(10)+N'            lo.Code = "0" + lo.Code;'+char(10)+N'            hi.Code = "1" + hi.Code;'+char(10)+N''+char(10)+N'            heap.Enqueue(new HuffmanNode(''\0'', lo.Frequency + hi.Frequency) '+char(10)+N'            { '+char(10)+N'                Left = lo, '+char(10)+N'                Right = hi, '+char(10)+N'                Code = "" '+char(10)+N'            });'+char(10)+N'        }'+char(10)+N''+char(10)+N'        var result = new List<HuffmanNode>(heap);'+char(10)+N''+char(10)+N'        // Рамзҳоро аз рӯи дарозӣ ва аломат ҷудо кунед'+char(10)+N'        result.Sort((a, b) =>'+char(10)+N'        {'+char(10)+N'            if (a.Code.Length != b.Code.Length)'+char(10)+N'                return a.Code.Length - b.Code.Length;'+char(10)+N'            return a.Symbol.CompareTo(b.Symbol);'+char(10)+N'        });'+char(10)+N''+char(10)+N'        return result;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        string data = "hello";'+char(10)+N'        var freq = new Dictionary<char, int>();'+char(10)+N'        foreach (char symbol in data)'+char(10)+N'        {'+char(10)+N'            if (freq.ContainsKey(symbol))'+char(10)+N'                freq[symbol]++;'+char(10)+N'            else'+char(10)+N'                freq.Add(symbol, 1);'+char(10)+N'        }'+char(10)+N''+char(10)+N'        var huffCodes = HuffmanCoding(freq);'+char(10)+N'        Console.WriteLine("Рамз  Басомад  Рамзи Хаффман");'+char(10)+N'        foreach (var node in huffCodes)'+char(10)+N'        {'+char(10)+N'            Console.WriteLine($"{node.Symbol}  {node.Frequency}  {node.Code}");'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(3, 4, N'import java.util.*;'+char(10)+N''+char(10)+N'class HuffmanNode implements Comparable<HuffmanNode> {'+char(10)+N'    char symbol;'+char(10)+N'    int frequency;'+char(10)+N'    String code;'+char(10)+N'    HuffmanNode left;'+char(10)+N'    HuffmanNode right;'+char(10)+N''+char(10)+N'    public HuffmanNode(char symbol, int frequency) {'+char(10)+N'        this.symbol = symbol;'+char(10)+N'        this.frequency = frequency;'+char(10)+N'        this.code = "";'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public int compareTo(HuffmanNode other) {'+char(10)+N'        return Integer.compare(this.frequency, other.frequency);'+char(10)+N'    }'+char(10)+N'}'+char(10)+N''+char(10)+N'public class Main {'+char(10)+N'    public static List<HuffmanNode> huffmanCoding(Map<Character, Integer> freq) {'+char(10)+N'        List<HuffmanNode> nodes = new ArrayList<>();'+char(10)+N'        for (Map.Entry<Character, Integer> entry : freq.entrySet()) {'+char(10)+N'            nodes.add(new HuffmanNode(entry.getKey(), entry.getValue()));'+char(10)+N'        }'+char(10)+N'        PriorityQueue<HuffmanNode> heap = new PriorityQueue<>(nodes);'+char(10)+N''+char(10)+N'        while (heap.size() > 1) {'+char(10)+N'            HuffmanNode lo = heap.poll();'+char(10)+N'            HuffmanNode hi = heap.poll();'+char(10)+N''+char(10)+N'            lo.code = "0" + lo.code;'+char(10)+N'            hi.code = "1" + hi.code;'+char(10)+N''+char(10)+N'            heap.add(new HuffmanNode(''\0'', lo.frequency + hi.frequency) {{'+char(10)+N'                left = lo;'+char(10)+N'                right = hi;'+char(10)+N'                code = "";'+char(10)+N'            }});'+char(10)+N'        }'+char(10)+N''+char(10)+N'        List<HuffmanNode> result = new ArrayList<>(heap);'+char(10)+N''+char(10)+N'        // Рамзҳоро аз рӯи дарозӣ ва аломат ҷудо кунед'+char(10)+N'        result.sort((a, b) -> {'+char(10)+N'            if (a.code.length() != b.code.length()) {'+char(10)+N'                return a.code.length() - b.code.length();'+char(10)+N'            }'+char(10)+N'            return Character.compare(a.symbol, b.symbol);'+char(10)+N'        });'+char(10)+N''+char(10)+N'        return result;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        String data = "hello";'+char(10)+N'        Map<Character, Integer> freq = new HashMap<>();'+char(10)+N'        for (char symbol : data.toCharArray()) {'+char(10)+N'            freq.put(symbol, freq.getOrDefault(symbol, 0) + 1);'+char(10)+N'        }'+char(10)+N''+char(10)+N'        List<HuffmanNode> huffCodes = huffmanCoding(freq);'+char(10)+N'        System.out.println("Рамз  Басомад  Рамзи Хаффман");'+char(10)+N'        for (HuffmanNode node : huffCodes) {'+char(10)+N'            System.out.println(node.symbol + "  " + node.frequency + "  " + node.code);'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')

,(4, 1, N'def binary_search(arr, target):'+char(10)+N'    # Оғози сарҳади чап ва рости массив'+char(10)+N'    left, right = 0, len(arr) - 1'+char(10)+N'    # То сарҳади чап аз сарҳади рост зиёд набошад'+char(10)+N'    while left <= right:'+char(10)+N'        # Индекси миёнаи массивро пайдо мекунад'+char(10)+N'        mid = (left + right) // 2'+char(10)+N'        # Агар унсури миёна ба унсури мақсаднок баробар бошад, индекси онро бармегардонем'+char(10)+N'        if arr[mid] == target:'+char(10)+N'            return mid'+char(10)+N'        # Агар унсури миена аз ҳадаф хурдтар бошад, ҷустуҷӯро ба нимаи рости массив кам кунед'+char(10)+N'        elif arr[mid] < target:'+char(10)+N'            left = mid + 1'+char(10)+N'        # Агар унсури миена аз ҳадаф калонтар бошад, майдони ҷустуҷӯро ба нимаи чапи массив танг кунед'+char(10)+N'        else:'+char(10)+N'            right = mid - 1'+char(10)+N'    # Агар элемент ёфт нашавад, мо бармегардем -1'+char(10)+N'    return -1'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'arr = [10, 20, 30, 40, 50, 60, 70]'+char(10)+N'target = 30'+char(10)+N'result = binary_search(arr, target)'+char(10)+N'if result != -1:'+char(10)+N'    print("Элементи", target, " ёфта шуд дар индекси ", result)'+char(10)+N'else:'+char(10)+N'    print("Элементи", target, " дар массив ёфта нашудааст ")')
,(4, 2, N'#include <iostream>'+char(10)+N'#include <vector>'+char(10)+N''+char(10)+N'int binary_search(const std::vector<int>& arr, int target) {'+char(10)+N'    int left = 0, right = arr.size() - 1;'+char(10)+N'    while (left <= right) {'+char(10)+N'        int mid = left + (right - left) / 2; // Индекси миёнаи массивро пайдо мекунад'+char(10)+N'        if (arr[mid] == target) {'+char(10)+N'            return mid;'+char(10)+N'        } else if (arr[mid] < target) {'+char(10)+N'            left = mid + 1;'+char(10)+N'        } else {'+char(10)+N'            right = mid - 1;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return -1;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::vector<int> arr = {1, 3, 5, 7, 9, 11, 13};'+char(10)+N'    int target = 7;'+char(10)+N'    int result = binary_search(arr, target);'+char(10)+N'    if (result != -1) {'+char(10)+N'        std::cout << "Элемент ёфта шуд дар индекси " << result << "." << std::endl;'+char(10)+N'    } else {'+char(10)+N'        std::cout << "Элемент дар массив ёфта нашудааст." << std::endl;'+char(10)+N'    }'+char(10)+N'    return 0;'+char(10)+N'}')
,(4, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static int BinarySearch(List<int> arr, int target)'+char(10)+N'    {'+char(10)+N'        int left = 0;'+char(10)+N'        int right = arr.Count - 1;'+char(10)+N''+char(10)+N'        while (left <= right)'+char(10)+N'        {'+char(10)+N'            int mid = left + (right - left) / 2; '+char(10)+N'            if (arr[mid] == target)'+char(10)+N'            {'+char(10)+N'                return mid;'+char(10)+N'            }'+char(10)+N'            else if (arr[mid] < target)'+char(10)+N'            {'+char(10)+N'                left = mid + 1;'+char(10)+N'            }'+char(10)+N'            else'+char(10)+N'            {'+char(10)+N'                right = mid - 1;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return -1;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        List<int> arr = new List<int>() { 1, 3, 5, 7, 9, 11, 13 };'+char(10)+N'        int target = 7;'+char(10)+N'        int result = BinarySearch(arr, target);'+char(10)+N'        if (result != -1)'+char(10)+N'        {'+char(10)+N'            Console.WriteLine("Элемент ёфта шуд дар индекси " + result + ".");'+char(10)+N'        }'+char(10)+N'        else'+char(10)+N'        {'+char(10)+N'            Console.WriteLine("Элемент ёфта нашуд.");'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(4, 5, N'DIM arr AS Variant'+char(10)+N'DIM target AS Integer'+char(10)+N'DIM result AS Integer'+char(10)+N'DIM left AS Integer'+char(10)+N'DIM right AS Integer'+char(10)+N'DIM mid AS Integer'+char(10)+N''+char(10)+N'arr = Array(1, 3, 5, 7, 9, 11, 13)'+char(10)+N''+char(10)+N'target = 7'+char(10)+N''+char(10)+N''' Функсияи ҷустуҷӯи дуӣ'+char(10)+N'FUNCTION BinarySearch(arr, target) AS Integer'+char(10)+N'    left = 0'+char(10)+N'    right = UBound(arr)'+char(10)+N''+char(10)+N'    DO WHILE left <= right'+char(10)+N'        mid = left + (right - left) \ 2'+char(10)+N'        IF arr(mid) = target THEN'+char(10)+N'            BinarySearch = mid'+char(10)+N'            EXIT DO'+char(10)+N'        ELSEIF arr(mid) < target THEN'+char(10)+N'            left = mid + 1'+char(10)+N'        ELSE'+char(10)+N'            right = mid - 1'+char(10)+N'        END IF'+char(10)+N'    LOOP'+char(10)+N'    BinarySearch = -1'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Ҷустуҷӯи элемент'+char(10)+N'result = BinarySearch(arr, target)'+char(10)+N''+char(10)+N''' Натиҷа'+char(10)+N'IF result <> -1 THEN'+char(10)+N'    PRINT "Элемент ёфта шуд дар индекси " + result + "."'+char(10)+N'ELSE'+char(10)+N'    PRINT "Элемент ёфта нашуд."'+char(10)+N'END IF')

,(5, 2, N'void BubbleSort(vector<int>& values) {'+char(10)+N'  for (size_t idx_i = 0; idx_i + 1 < values.size(); ++idx_i) {'+char(10)+N'    for (size_t idx_j = 0; idx_j + 1 < values.size() - idx_i; ++idx_j) {'+char(10)+N'      if (values[idx_j + 1] < values[idx_j]) {'+char(10)+N'        swap(values[idx_j], values[idx_j + 1]);'+char(10)+N'      }'+char(10)+N'    }'+char(10)+N'  }'+char(10)+N'}')
,(5, 1, N'def bubble_sort(values):'+char(10)+N'    for idx_i in range(len(values) - 1):'+char(10)+N'        for idx_j in range(len(values) - idx_i - 1):'+char(10)+N'            if values[idx_j + 1] < values[idx_j]:'+char(10)+N'                values[idx_j], values[idx_j + 1] = values[idx_j + 1], values[idx_j]'+char(10)+N''+char(10)+N'# Пример использования'+char(10)+N'values = [64, 34, 25, 12, 22, 11, 90]'+char(10)+N'bubble_sort(values)'+char(10)+N'print("Отсортированный список:", values)')
,(5, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N'using System.Linq;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static void BubbleSort(List<int> values)'+char(10)+N'    {'+char(10)+N'        for (int idx_i = 0; idx_i + 1 < values.Count; ++idx_i)'+char(10)+N'        {'+char(10)+N'            for (int idx_j = 0; idx_j + 1 < values.Count - idx_i; ++idx_j)'+char(10)+N'            {'+char(10)+N'                if (values[idx_j + 1] < values[idx_j])'+char(10)+N'                {'+char(10)+N'                    (values[idx_j], values[idx_j + 1]) = (values[idx_j + 1], values[idx_j]); '+char(10)+N'                }'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        List<int> values = new List<int>() { 5, 2, 9, 1, 7 };'+char(10)+N'        BubbleSort(values);'+char(10)+N'        Console.WriteLine(string.Join(", ", values)); '+char(10)+N'    }'+char(10)+N'}')
,(5, 4, N'import java.util.ArrayList;'+char(10)+N'import java.util.List;'+char(10)+N''+char(10)+N'public class Main {'+char(10)+N'    public static int binarySearch(List<Integer> arr, int target) {'+char(10)+N'        int left = 0;'+char(10)+N'        int right = arr.size() - 1;'+char(10)+N''+char(10)+N'        while (left <= right) {'+char(10)+N'            int mid = left + (right - left) / 2;'+char(10)+N'            if (arr.get(mid) == target) {'+char(10)+N'                return mid;'+char(10)+N'            } else if (arr.get(mid) < target) {'+char(10)+N'                left = mid + 1;'+char(10)+N'            } else {'+char(10)+N'                right = mid - 1;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return -1;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        List<Integer> arr = new ArrayList<>();'+char(10)+N'        arr.add(1);'+char(10)+N'        arr.add(3);'+char(10)+N'        arr.add(5);'+char(10)+N'        arr.add(7);'+char(10)+N'        arr.add(9);'+char(10)+N'        arr.add(11);'+char(10)+N'        arr.add(13);'+char(10)+N''+char(10)+N'        int target = 7;'+char(10)+N'        int result = binarySearch(arr, target);'+char(10)+N'        if (result != -1) {'+char(10)+N'            System.out.println("Элемент найден в позиции " + result + ".");'+char(10)+N'        } else {'+char(10)+N'            System.out.println("Элемент не найден.");'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(5, 5, N'DIM values AS Variant'+char(10)+N'DIM idx_i AS Integer'+char(10)+N'DIM idx_j AS Integer'+char(10)+N'DIM temp AS Integer'+char(10)+N''+char(10)+N'values = Array(5, 2, 9, 1, 7)'+char(10)+N''+char(10)+N'SUB BubbleSort(values)'+char(10)+N'    FOR idx_i = 0 TO UBound(values) - 1'+char(10)+N'        FOR idx_j = 0 TO UBound(values) - 1 - idx_i'+char(10)+N'            IF values(idx_j + 1) < values(idx_j) THEN'+char(10)+N'                temp = values(idx_j)'+char(10)+N'                values(idx_j) = values(idx_j + 1)'+char(10)+N'                values(idx_j + 1) = temp'+char(10)+N'            END IF'+char(10)+N'        NEXT idx_j'+char(10)+N'    NEXT idx_i'+char(10)+N'END SUB'+char(10)+N''+char(10)+N'Call BubbleSort(values)'+char(10)+N''+char(10)+N'PRINT "Массиви мураттабшуда: ";'+char(10)+N'FOR idx_i = 0 TO UBound(values)'+char(10)+N'    PRINT values(idx_i);'+char(10)+N'    IF idx_i < UBound(values) THEN'+char(10)+N'        PRINT ", ";'+char(10)+N'    END IF'+char(10)+N'NEXT idx_i')

,(6, 2, N'void SelectionSort(vector<int>& values) {'+char(10)+N'  for (auto i = values.begin(); i != values.end(); ++i) {'+char(10)+N'    auto j = std::min_element(i, values.end());'+char(10)+N'    swap(*i, *j);'+char(10)+N'  }'+char(10)+N'}')
,(6, 1, N'def selection_sort(values):'+char(10)+N'    for i in range(len(values)):'+char(10)+N'        min_index = i'+char(10)+N'        for j in range(i + 1, len(values)):'+char(10)+N'            if values[j] < values[min_index]:'+char(10)+N'                min_index = j'+char(10)+N'        values[i], values[min_index] = values[min_index], values[i]'+char(10)+N''+char(10)+N'values = [5, 2, 9, 1, 7]'+char(10)+N'selection_sort(values)'+char(10)+N'print(f"Массиви мураттабшуда: {values}")')
,(6, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N'using System.Linq;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static void SelectionSort(List<int> values)'+char(10)+N'    {'+char(10)+N'        for (int i = 0; i < values.Count; ++i)'+char(10)+N'        {'+char(10)+N'            int j = values.GetRange(i, values.Count - i).IndexOf(values.GetRange(i, values.Count - i).Min()) + i;'+char(10)+N'            (values[i], values[j]) = (values[j], values[i]);'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        List<int> values = new List<int>() { 5, 2, 9, 1, 7 };'+char(10)+N'        SelectionSort(values);'+char(10)+N'        Console.WriteLine(string.Join(", ", values)); '+char(10)+N'    }'+char(10)+N'}')
,(6, 4, N'import java.util.ArrayList;'+char(10)+N'import java.util.Collections;'+char(10)+N'import java.util.List;'+char(10)+N''+char(10)+N'public class SelectionSort {'+char(10)+N'    public static void selectionSort(List<Integer> values) {'+char(10)+N'        for (int i = 0; i < values.size(); ++i) {'+char(10)+N'            int minIndex = i;'+char(10)+N'            for (int j = i + 1; j < values.size(); ++j) {'+char(10)+N'                if (values.get(j) < values.get(minIndex)) {'+char(10)+N'                    minIndex = j;'+char(10)+N'                }'+char(10)+N'            }'+char(10)+N'            Collections.swap(values, i, minIndex);'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        List<Integer> values = new ArrayList<>();'+char(10)+N'        values.add(5);'+char(10)+N'        values.add(2);'+char(10)+N'        values.add(9);'+char(10)+N'        values.add(1);'+char(10)+N'        values.add(7);'+char(10)+N''+char(10)+N'        selectionSort(values);'+char(10)+N''+char(10)+N'        System.out.println(String.join(", ", values));'+char(10)+N'    }'+char(10)+N'}')
,(6, 5, N'DIM values AS Variant'+char(10)+N'DIM i AS Integer'+char(10)+N'DIM j AS Integer'+char(10)+N'DIM minIndex AS Integer'+char(10)+N'DIM temp AS Integer'+char(10)+N''+char(10)+N'values = Array(5, 2, 9, 1, 7)'+char(10)+N''+char(10)+N'SUB SelectionSort(values)'+char(10)+N'    FOR i = 0 TO UBound(values) - 1'+char(10)+N'        minIndex = i'+char(10)+N'        FOR j = i + 1 TO UBound(values)'+char(10)+N'            IF values(j) < values(minIndex) THEN'+char(10)+N'                minIndex = j'+char(10)+N'            END IF'+char(10)+N'        NEXT j'+char(10)+N'        temp = values(i)'+char(10)+N'        values(i) = values(minIndex)'+char(10)+N'        values(minIndex) = temp'+char(10)+N'    NEXT i'+char(10)+N'END SUB'+char(10)+N''+char(10)+N'Call SelectionSort(values)'+char(10)+N''+char(10)+N'PRINT "Массиви мураттабшуда: ";'+char(10)+N'FOR i = 0 TO UBound(values)'+char(10)+N'    PRINT values(i);'+char(10)+N'    IF i < UBound(values) THEN'+char(10)+N'        PRINT ", ";'+char(10)+N'    END IF'+char(10)+N'NEXT i')

,(7, 2, N'int Partition(vector<int>& values, int l, int r) {'+char(10)+N'  int x = values[r];'+char(10)+N'  int less = l;'+char(10)+N''+char(10)+N'  for (int i = l; i < r; ++i) {'+char(10)+N'    if (values[i] <= x) {'+char(10)+N'      swap(values[i], values[less]);'+char(10)+N'      ++less;'+char(10)+N'    }'+char(10)+N'  }'+char(10)+N'  swap(values[less], values[r]);'+char(10)+N'  return less;'+char(10)+N'}'+char(10)+N''+char(10)+N'void QuickSortImpl(vector<int>& values, int l, int r) {'+char(10)+N'  if (l < r) {'+char(10)+N'    int q = Partition(values, l, r);'+char(10)+N'    QuickSortImpl(values, l, q - 1);'+char(10)+N'    QuickSortImpl(values, q + 1, r);'+char(10)+N'  }'+char(10)+N'}'+char(10)+N''+char(10)+N'void QuickSort(vector<int>& values) {'+char(10)+N'  if (!values.empty()) {'+char(10)+N'    QuickSortImpl(values, 0, values.size() - 1);'+char(10)+N'  }'+char(10)+N'}')
,(7, 1, N'def partition(values, l, r):'+char(10)+N'    x = values[r]'+char(10)+N'    less = l'+char(10)+N'    for i in range(l, r):'+char(10)+N'        if values[i] <= x:'+char(10)+N'            values[i], values[less] = values[less], values[i]'+char(10)+N'            less += 1'+char(10)+N'    values[less], values[r] = values[r], values[less]'+char(10)+N'    return less'+char(10)+N''+char(10)+N'def quick_sort_impl(values, l, r):'+char(10)+N'    if l < r:'+char(10)+N'        q = partition(values, l, r)'+char(10)+N'        quick_sort_impl(values, l, q - 1)'+char(10)+N'        quick_sort_impl(values, q + 1, r)'+char(10)+N''+char(10)+N'def quick_sort(values):'+char(10)+N'    if len(values) > 0:'+char(10)+N'        quick_sort_impl(values, 0, len(values) - 1)'+char(10)+N''+char(10)+N'values = [5, 2, 9, 1, 7]'+char(10)+N'quick_sort(values)'+char(10)+N'print(f"Массиви мураттабшуда: {values}")')
,(7, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static int Partition(List<int> values, int l, int r)'+char(10)+N'    {'+char(10)+N'        int x = values[r];'+char(10)+N'        int less = l;'+char(10)+N''+char(10)+N'        for (int i = l; i < r; ++i)'+char(10)+N'        {'+char(10)+N'            if (values[i] <= x)'+char(10)+N'            {'+char(10)+N'                (values[i], values[less]) = (values[less], values[i]);'+char(10)+N'                ++less;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        (values[less], values[r]) = (values[r], values[less]);'+char(10)+N'        return less;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void QuickSortImpl(List<int> values, int l, int r)'+char(10)+N'    {'+char(10)+N'        if (l < r)'+char(10)+N'        {'+char(10)+N'            int q = Partition(values, l, r);'+char(10)+N'            QuickSortImpl(values, l, q - 1);'+char(10)+N'            QuickSortImpl(values, q + 1, r);'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void QuickSort(List<int> values)'+char(10)+N'    {'+char(10)+N'        if (values.Count > 0)'+char(10)+N'        {'+char(10)+N'            QuickSortImpl(values, 0, values.Count - 1);'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        List<int> values = new List<int>() { 5, 2, 9, 1, 7 };'+char(10)+N'        QuickSort(values);'+char(10)+N'        Console.WriteLine(string.Join(", ", values));'+char(10)+N'    }'+char(10)+N'}')
,(7, 4, N'import java.util.ArrayList;'+char(10)+N'import java.util.List;'+char(10)+N''+char(10)+N'public class QuickSort {'+char(10)+N'    static int partition(List<Integer> values, int l, int r) {'+char(10)+N'        int x = values.get(r);'+char(10)+N'        int less = l;'+char(10)+N''+char(10)+N'        for (int i = l; i < r; ++i) {'+char(10)+N'            if (values.get(i) <= x) {'+char(10)+N'                int temp = values.get(i);'+char(10)+N'                values.set(i, values.get(less));'+char(10)+N'                values.set(less, temp);'+char(10)+N'                ++less;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        int temp = values.get(less);'+char(10)+N'        values.set(less, values.get(r));'+char(10)+N'        values.set(r, temp);'+char(10)+N'        return less;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void quickSortImpl(List<Integer> values, int l, int r) {'+char(10)+N'        if (l < r) {'+char(10)+N'            int q = partition(values, l, r);'+char(10)+N'            quickSortImpl(values, l, q - 1);'+char(10)+N'            quickSortImpl(values, q + 1, r);'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void quickSort(List<Integer> values) {'+char(10)+N'        if (!values.isEmpty()) {'+char(10)+N'            quickSortImpl(values, 0, values.size() - 1);'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        List<Integer> values = new ArrayList<>();'+char(10)+N'        values.add(5);'+char(10)+N'        values.add(2);'+char(10)+N'        values.add(9);'+char(10)+N'        values.add(1);'+char(10)+N'        values.add(7);'+char(10)+N''+char(10)+N'        quickSort(values);'+char(10)+N''+char(10)+N'        System.out.println(String.join(", ", values));'+char(10)+N'    }'+char(10)+N'}')
,(7, 5, N'DIM values AS Variant'+char(10)+N'DIM l AS Integer'+char(10)+N'DIM r AS Integer'+char(10)+N'DIM x AS Integer'+char(10)+N'DIM less AS Integer'+char(10)+N'DIM i AS Integer'+char(10)+N'DIM temp AS Integer'+char(10)+N''+char(10)+N'values = Array(5, 2, 9, 1, 7)'+char(10)+N''+char(10)+N'FUNCTION Partition(values, l, r) AS Integer'+char(10)+N'    x = values(r)'+char(10)+N'    less = l'+char(10)+N'    FOR i = l TO r - 1'+char(10)+N'        IF values(i) <= x THEN'+char(10)+N'            temp = values(i)'+char(10)+N'            values(i) = values(less)'+char(10)+N'            values(less) = temp'+char(10)+N'            less = less + 1'+char(10)+N'        END IF'+char(10)+N'    NEXT i'+char(10)+N'    temp = values(r)'+char(10)+N'    values(r) = values(less)'+char(10)+N'    values(less) = temp'+char(10)+N'    Partition = less'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N'SUB QuickSortImpl(values, l, r)'+char(10)+N'    IF l < r THEN'+char(10)+N'        q = Partition(values, l, r)'+char(10)+N'        Call QuickSortImpl(values, l, q - 1)'+char(10)+N'        Call QuickSortImpl(values, q + 1, r)'+char(10)+N'    END IF'+char(10)+N'END SUB'+char(10)+N''+char(10)+N'SUB QuickSort(values)'+char(10)+N'    IF UBound(values) >= 0 THEN'+char(10)+N'        Call QuickSortImpl(values, 0, UBound(values))'+char(10)+N'    END IF'+char(10)+N'END SUB'+char(10)+N''+char(10)+N'Call QuickSort(values)'+char(10)+N''+char(10)+N'PRINT "Массиви мураттабшуда: ";'+char(10)+N'FOR i = 0 TO UBound(values)'+char(10)+N'    PRINT values(i);'+char(10)+N'    IF i < UBound(values) THEN'+char(10)+N'        PRINT ", ";'+char(10)+N'    END IF'+char(10)+N'NEXT i')

,(8, 1, N'def bfs(graph, start):'+char(10)+N'    queue = [start]'+char(10)+N'    visited = set()'+char(10)+N'    while queue:'+char(10)+N'        current = queue.pop(0)'+char(10)+N'        visited.add(current)'+char(10)+N'        for neighbor in graph[current]:'+char(10)+N'            if neighbor not in visited:'+char(10)+N'                queue.append(neighbor)'+char(10)+N''+char(10)+N'graph = {'+char(10)+N'    "A": ["B", "C"],'+char(10)+N'    "B": ["D", "E"],'+char(10)+N'    "C": ["F"],'+char(10)+N'    "D": [],'+char(10)+N'    "E": [],'+char(10)+N'    "F": [],'+char(10)+N'}'+char(10)+N'bfs(graph, "A")')
,(8, 2, N'#include <iostream>'+char(10)+N'#include <queue>'+char(10)+N'#include <unordered_set>'+char(10)+N'#include <unordered_map>'+char(10)+N'#include <vector>'+char(10)+N''+char(10)+N'void bfs(std::unordered_map<std::string, std::vector<std::string>> graph, std::string start) {'+char(10)+N'    std::queue<std::string> queue;'+char(10)+N'    std::unordered_set<std::string> visited;'+char(10)+N''+char(10)+N'    queue.push(start);'+char(10)+N''+char(10)+N'    while (!queue.empty()) {'+char(10)+N'        std::string current = queue.front();'+char(10)+N'        queue.pop();'+char(10)+N'        visited.insert(current);'+char(10)+N'        for (const std::string& neighbor : graph[current]) {'+char(10)+N'            if (visited.find(neighbor) == visited.end()) {'+char(10)+N'                queue.push(neighbor);'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::unordered_map<std::string, std::vector<std::string>> graph = {'+char(10)+N'        {"A", {"B", "C"}},'+char(10)+N'        {"B", {"D", "E"}},'+char(10)+N'        {"C", {"F"}},'+char(10)+N'        {"D", {}},'+char(10)+N'        {"E", {}},'+char(10)+N'        {"F", {}}'+char(10)+N'    };'+char(10)+N''+char(10)+N'    bfs(graph, "A");'+char(10)+N''+char(10)+N'    return 0;'+char(10)+N'}')
,(8, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        Dictionary<string, List<string>> graph = new Dictionary<string, List<string>>()'+char(10)+N'        {'+char(10)+N'            { "A", new List<string>{"B", "C"} },'+char(10)+N'            { "B", new List<string>{"D", "E"} },'+char(10)+N'            { "C", new List<string>{"F"} },'+char(10)+N'            { "D", new List<string>{} },'+char(10)+N'            { "E", new List<string>{} },'+char(10)+N'            { "F", new List<string>{} }'+char(10)+N'        };'+char(10)+N''+char(10)+N'        BFS(graph, "A");'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void BFS(Dictionary<string, List<string>> graph, string start)'+char(10)+N'    {'+char(10)+N'        Queue<string> queue = new Queue<string>();'+char(10)+N'        HashSet<string> visited = new HashSet<string>();'+char(10)+N''+char(10)+N'        queue.Enqueue(start);'+char(10)+N''+char(10)+N'        while (queue.Count > 0)'+char(10)+N'        {'+char(10)+N'            string current = queue.Dequeue();'+char(10)+N'            visited.Add(current);'+char(10)+N'            foreach (string neighbor in graph[current])'+char(10)+N'            {'+char(10)+N'                if (!visited.Contains(neighbor))'+char(10)+N'                {'+char(10)+N'                    queue.Enqueue(neighbor);'+char(10)+N'                }'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(8, 4, N'import java.util.*;'+char(10)+N''+char(10)+N'public class Main {'+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        Map<String, List<String>> graph = new HashMap<>();'+char(10)+N'        graph.put("A", Arrays.asList("B", "C"));'+char(10)+N'        graph.put("B", Arrays.asList("D", "E"));'+char(10)+N'        graph.put("C", Arrays.asList("F"));'+char(10)+N'        graph.put("D", new ArrayList<>());'+char(10)+N'        graph.put("E", new ArrayList<>());'+char(10)+N'        graph.put("F", new ArrayList<>());'+char(10)+N''+char(10)+N'        bfs(graph, "A");'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void bfs(Map<String, List<String>> graph, String start) {'+char(10)+N'        Queue<String> queue = new LinkedList<>();'+char(10)+N'        Set<String> visited = new HashSet<>();'+char(10)+N''+char(10)+N'        queue.add(start);'+char(10)+N''+char(10)+N'        while (!queue.isEmpty()) {'+char(10)+N'            String current = queue.poll();'+char(10)+N'            visited.add(current);'+char(10)+N'            for (String neighbor : graph.get(current)) {'+char(10)+N'                if (!visited.contains(neighbor)) {'+char(10)+N'                    queue.add(neighbor);'+char(10)+N'                }'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(8, 5, N'SUB BFS(graph$, start$)'+char(10)+N'    DIM queue$(1 TO 100) '' Навбат'+char(10)+N'    DIM visited$(1 TO 100) '' Қуллаҳо дидан карданд'+char(10)+N'    DIM current$'+char(10)+N'    DIM neighbor$'+char(10)+N'    '+char(10)+N'    '' Оғози навбат ва маҷмӯи қуллаҳои боздидшуда'+char(10)+N'    queue$(1) = start$'+char(10)+N'    visited$(1) = start$'+char(10)+N'    q_start = 1'+char(10)+N'    q_end = 1'+char(10)+N'    '+char(10)+N'    '' Дар ҳоле ки навбат холӣ нест'+char(10)+N'    WHILE q_start <= q_end'+char(10)+N'        '' Гирифтани қуллаи ҷорӣ аз навбат'+char(10)+N'        current$ = queue$(q_start)'+char(10)+N'        q_start = q_start + 1'+char(10)+N'        '+char(10)+N'        '' Мо атрофи хамсояхои куллаи хозираро давр мезанем'+char(10)+N'        FOR i = 1 TO LEN(graph$(current$))'+char(10)+N'            neighbor$ = MID$(graph$(current$), i, 1)'+char(10)+N'            '' Агар ҳамсоя то ҳол дидан накарда бошад, онро ба навбат илова кунед ва ҳамчун ташриф овардашуда қайд кунед'+char(10)+N'            IF INSTR(visited$, neighbor$) = 0 THEN'+char(10)+N'                q_end = q_end + 1'+char(10)+N'                queue$(q_end) = neighbor$'+char(10)+N'                visited$ = visited$ + neighbor$'+char(10)+N'            END IF'+char(10)+N'        NEXT i'+char(10)+N'    WEND'+char(10)+N'END SUB'+char(10)+N''+char(10)+N''' Таърифи график'+char(10)+N'DIM graph$(6)'+char(10)+N'graph$("A") = "BC"'+char(10)+N'graph$("B") = "DE"'+char(10)+N'graph$("C") = "F"'+char(10)+N'graph$("D") = ""'+char(10)+N'graph$("E") = ""'+char(10)+N'graph$("F") = ""'+char(10)+N''+char(10)+N''' Даъвати тартиби гузариши фарох-аввал'+char(10)+N'CALL BFS(graph$, "A")')

,(9, 1, N'def hanoi_recursive(n, source, target, auxiliary):'+char(10)+N'    if n == 1:'+char(10)+N'        print("Ҷойивазкунии диск 1 с", source, "на", target)'+char(10)+N'        return'+char(10)+N'    hanoi_recursive(n-1, source, auxiliary, target)'+char(10)+N'    print("Ҷойивазкунии диск ", n, "с", source, "на", target)'+char(10)+N'    hanoi_recursive(n-1, auxiliary, target, source)'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'n = 3'+char(10)+N'hanoi_recursive(n, "A", "C", "B")')
,(9, 2, N'#include <iostream>'+char(10)+N''+char(10)+N'void hanoi_recursive(int n, char source, char target, char auxiliary) {'+char(10)+N'    if (n == 1) {'+char(10)+N'        std::cout << "Ҷойивазкунии диск 1 с " << source << " на " << target << std::endl;'+char(10)+N'        return;'+char(10)+N'    }'+char(10)+N'    hanoi_recursive(n - 1, source, auxiliary, target);'+char(10)+N'    std::cout << "Ҷойивазкунии диск " << n << " с " << source << " на " << target << std::endl;'+char(10)+N'    hanoi_recursive(n - 1, auxiliary, target, source);'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    int n = 3;'+char(10)+N'    hanoi_recursive(n, ''A'', ''C'', ''B'');'+char(10)+N'    return 0;'+char(10)+N'}')
,(9, 3, N'using System;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static void HanoiRecursive(int n, char source, char target, char auxiliary)'+char(10)+N'    {'+char(10)+N'        if (n == 1)'+char(10)+N'        {'+char(10)+N'            Console.WriteLine($"Ҷойивазкунии диск 1 с {source} на {target}");'+char(10)+N'            return;'+char(10)+N'        }'+char(10)+N'        HanoiRecursive(n - 1, source, auxiliary, target);'+char(10)+N'        Console.WriteLine($"Ҷойивазкунии диск {n} с {source} на {target}");'+char(10)+N'        HanoiRecursive(n - 1, auxiliary, target, source);'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        int n = 3;'+char(10)+N'        HanoiRecursive(n, ''A'', ''C'', ''B'');'+char(10)+N'    }'+char(10)+N'}')
,(9, 4, N'public class Main {'+char(10)+N'    static void hanoiRecursive(int n, char source, char target, char auxiliary) {'+char(10)+N'        if (n == 1) {'+char(10)+N'            System.out.println("Ҷойивазкунии диск 1 с " + source + " на " + target);'+char(10)+N'            return;'+char(10)+N'        }'+char(10)+N'        hanoiRecursive(n - 1, source, auxiliary, target);'+char(10)+N'        System.out.println("Ҷойивазкунии диск " + n + " с " + source + " на " + target);'+char(10)+N'        hanoiRecursive(n - 1, auxiliary, target, source);'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int n = 3;'+char(10)+N'        hanoiRecursive(n, ''A'', ''C'', ''B'');'+char(10)+N'    }'+char(10)+N'}')
,(9, 5, N'SUB HanoiRecursive(n, source, target, auxiliary)'+char(10)+N'    IF n = 1 THEN'+char(10)+N'        PRINT "Ҷойивазкунии диск 1 с "; source; " на "; target'+char(10)+N'        EXIT SUB'+char(10)+N'    END IF'+char(10)+N'    CALL HanoiRecursive(n - 1, source, auxiliary, target)'+char(10)+N'    PRINT "Ҷойивазкунии диск "; n; " с "; source; " на "; target'+char(10)+N'    CALL HanoiRecursive(n - 1, auxiliary, target, source)'+char(10)+N'END SUB'+char(10)+N''+char(10)+N''' Намунаи истифода:'+char(10)+N'n = 3'+char(10)+N'CALL HanoiRecursive(n, "A", "C", "B")')

,(10, 1, N'def hanoi_iterative(n, source, target, auxiliary):'+char(10)+N'    stack = [(n, source, target, auxiliary)]'+char(10)+N'    while stack:'+char(10)+N'        n, source, target, auxiliary = stack.pop()'+char(10)+N'        if n == 1:'+char(10)+N'            print("Ҷойивазкунии диск 1 с", source, "на", target)'+char(10)+N'        else:'+char(10)+N'            stack.append((n-1, auxiliary, target, source))'+char(10)+N'            stack.append((1, source, target, auxiliary))'+char(10)+N'            stack.append((n-1, source, auxiliary, target))'+char(10)+char(10)+N'# Намунаи истифода:'+char(10)+N'n = 3'+char(10)+N'hanoi_iterative(n, "A", "C", "B")')
,(10, 2, N'#include <iostream>'+char(10)+N'#include <stack>'+char(10)+N'#include <tuple>'+char(10)+N''+char(10)+N'void hanoi_iterative(int n, char source, char target, char auxiliary) {'+char(10)+N'    std::stack<std::tuple<int, char, char, char>> stack;'+char(10)+N'    stack.push(std::make_tuple(n, source, target, auxiliary));'+char(10)+N'    while (!stack.empty()) {'+char(10)+N'        std::tie(n, source, target, auxiliary) = stack.top();'+char(10)+N'        stack.pop();'+char(10)+N'        if (n == 1) {'+char(10)+N'            std::cout << "Ҷойивазкунии диск 1 с " << source << " на " << target << std::endl;'+char(10)+N'        } else {'+char(10)+N'            stack.push(std::make_tuple(n - 1, auxiliary, target, source));'+char(10)+N'            stack.push(std::make_tuple(1, source, target, auxiliary));'+char(10)+N'            stack.push(std::make_tuple(n - 1, source, auxiliary, target));'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    int n = 3;'+char(10)+N'    hanoi_iterative(n, ''A'', ''C'', ''B'');'+char(10)+N'    return 0;'+char(10)+N'}')
,(10, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static void HanoiIterative(int n, char source, char target, char auxiliary)'+char(10)+N'    {'+char(10)+N'        Stack<Tuple<int, char, char, char>> stack = new Stack<Tuple<int, char, char, char>>();'+char(10)+N'        stack.Push(new Tuple<int, char, char, char>(n, source, target, auxiliary));'+char(10)+N'        while (stack.Count > 0)'+char(10)+N'        {'+char(10)+N'            var (nVal, sourceVal, targetVal, auxiliaryVal) = stack.Pop();'+char(10)+N'            if (nVal == 1)'+char(10)+N'            {'+char(10)+N'                Console.WriteLine($"Ҷойивазкунии диск 1 с {sourceVal} на {targetVal}");'+char(10)+N'            }'+char(10)+N'            else'+char(10)+N'            {'+char(10)+N'                stack.Push(new Tuple<int, char, char, char>(nVal - 1, auxiliaryVal, targetVal, sourceVal));'+char(10)+N'                stack.Push(new Tuple<int, char, char, char>(1, sourceVal, targetVal, auxiliaryVal));'+char(10)+N'                stack.Push(new Tuple<int, char, char, char>(nVal - 1, sourceVal, auxiliaryVal, targetVal));'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        int n = 3;'+char(10)+N'        HanoiIterative(n, ''A'', ''C'', ''B'');'+char(10)+N'    }'+char(10)+N'}')
,(10, 4, N'import java.util.Stack;'+char(10)+N''+char(10)+N'public class Main {'+char(10)+N'    static void hanoiIterative(int n, char source, char target, char auxiliary) {'+char(10)+N'        Stack<int[]> stack = new Stack<>();'+char(10)+N'        stack.push(new int[] { n, source, target, auxiliary });'+char(10)+N'        while (!stack.empty()) {'+char(10)+N'            int[] params = stack.pop();'+char(10)+N'            int nVal = params[0];'+char(10)+N'            char sourceVal = (char)params[1];'+char(10)+N'            char targetVal = (char)params[2];'+char(10)+N'            char auxiliaryVal = (char)params[3];'+char(10)+N'            if (nVal == 1) {'+char(10)+N'                System.out.println("Ҷойивазкунии диск 1 с " + sourceVal + " на " + targetVal);'+char(10)+N'            } else {'+char(10)+N'                stack.push(new int[] { nVal - 1, auxiliaryVal, targetVal, sourceVal });'+char(10)+N'                stack.push(new int[] { 1, sourceVal, targetVal, auxiliaryVal });'+char(10)+N'                stack.push(new int[] { nVal - 1, sourceVal, auxiliaryVal, targetVal });'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int n = 3;'+char(10)+N'        hanoiIterative(n, ''A'', ''C'', ''B'');'+char(10)+N'    }'+char(10)+N'}')
,(10, 5, N'SUB HanoiIterative(n, source, target, auxiliary)'+char(10)+N'    DIM stack()'+char(10)+N'    REDIM stack(0 TO 3)'+char(10)+N'    stack(0) = n : stack(1) = source : stack(2) = target : stack(3) = auxiliary'+char(10)+N'    WHILE LEN(stack) > 0'+char(10)+N'        n = stack(0) : source = stack(1) : target = stack(2) : auxiliary = stack(3)'+char(10)+N'        stack() = NULL'+char(10)+N'        REDIM PRESERVE stack(0 TO LEN(stack) - 5)'+char(10)+N'        IF n = 1 THEN'+char(10)+N'            PRINT "Ҷойивазкунии диск 1 с "; source; " на "; target'+char(10)+N'        ELSE'+char(10)+N'            REDIM PRESERVE stack(0 TO LEN(stack) + 8)'+char(10)+N'            stack(LEN(stack) - 1) = n - 1 : stack(LEN(stack)) = auxiliary : stack(LEN(stack) + 1) = target : stack(LEN(stack) + 2) = source'+char(10)+N'            stack(LEN(stack) + 3) = 1 : stack(LEN(stack) + 4) = source : stack(LEN(stack) + 5) = target : stack(LEN(stack) + 6) = auxiliary'+char(10)+N'            stack(LEN(stack) + 7) = n - 1 : stack(LEN(stack) + 8) = source : stack(LEN(stack) + 9) = auxiliary : stack(LEN(stack) + 10) = target'+char(10)+N'        END IF'+char(10)+N'    WEND'+char(10)+N'END SUB'+char(10)+N''+char(10)+N''' Намунаи истифода:'+char(10)+N'n = 3'+char(10)+N'CALL HanoiIterative(n, "A", "C", "B")')

,(11, 1, N'def power(base, exponent):'+char(10)+N'    result = 1'+char(10)+N'    # То расидан ба нишондиҳанда 0'+char(10)+N'    while exponent > 0:'+char(10)+N'        # Агар нишондиҳанда ҷуфт бошад'+char(10)+N'        if exponent % 2 == 0:'+char(10)+N'            base *= base'+char(10)+N'            exponent //= 2'+char(10)+N'        # Агар нишондиҳанда тоқ бошад'+char(10)+N'        else:'+char(10)+N'            result *= base'+char(10)+N'            exponent -= 1'+char(10)+N'    return result'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'base = 2'+char(10)+N'exponent = 10'+char(10)+N'result = power(base, exponent)'+char(10)+N'print(base, "дар дараҷаи", exponent, "баробар аст ба ", result)')
,(11, 2, N'#include <iostream>'+char(10)+N''+char(10)+N'int power(int base, int exponent) {'+char(10)+N'    int result = 1;'+char(10)+N'    // То расидан ба нишондиҳанда 0'+char(10)+N'    while (exponent > 0) {'+char(10)+N'        // Агар нишондиҳанда ҷуфт бошад'+char(10)+N'        if (exponent % 2 == 0) {'+char(10)+N'            base *= base;'+char(10)+N'            exponent /= 2;'+char(10)+N'        }'+char(10)+N'        // Агар нишондиҳанда тоқ бошад'+char(10)+N'        else {'+char(10)+N'            result *= base;'+char(10)+N'            exponent -= 1;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return result;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    int base = 2;'+char(10)+N'    int exponent = 10;'+char(10)+N'    int result = power(base, exponent);'+char(10)+N'    std::cout << base << " дар дараҷаи " << exponent << " баробар аст ба " << result << std::endl;'+char(10)+N'    return 0;'+char(10)+N'}')
,(11, 3, N'using System;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static int Power(int baseNum, int exponent)'+char(10)+N'    {'+char(10)+N'        int result = 1;'+char(10)+N'        // То расидан ба нишондиҳанда 0'+char(10)+N'        while (exponent > 0)'+char(10)+N'        {'+char(10)+N'            // Агар нишондиҳанда ҷуфт бошад'+char(10)+N'            if (exponent % 2 == 0)'+char(10)+N'            {'+char(10)+N'                baseNum *= baseNum;'+char(10)+N'                exponent /= 2;'+char(10)+N'            }'+char(10)+N'            // Агар нишондиҳанда тоқ бошад'+char(10)+N'            else'+char(10)+N'            {'+char(10)+N'                result *= baseNum;'+char(10)+N'                exponent -= 1;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return result;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        int baseNum = 2;'+char(10)+N'        int exponent = 10;'+char(10)+N'        int result = Power(baseNum, exponent);'+char(10)+N'        Console.WriteLine(baseNum + " дар дараҷаи " + exponent + " баробар аст ба " + result);'+char(10)+N'    }'+char(10)+N'}')
,(11, 4, N'public class Main {'+char(10)+N'    static int power(int base, int exponent) {'+char(10)+N'        int result = 1;'+char(10)+N'        // То расидан ба нишондиҳанда 0'+char(10)+N'        while (exponent > 0) {'+char(10)+N'            // Агар нишондиҳанда ҷуфт бошад'+char(10)+N'            if (exponent % 2 == 0) {'+char(10)+N'                base *= base;'+char(10)+N'                exponent /= 2;'+char(10)+N'            }'+char(10)+N'            // Агар нишондиҳанда тоқ бошад'+char(10)+N'            else {'+char(10)+N'                result *= base;'+char(10)+N'                exponent -= 1;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return result;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int base = 2;'+char(10)+N'        int exponent = 10;'+char(10)+N'        int result = power(base, exponent);'+char(10)+N'        System.out.println(base + " дар дараҷаи " + exponent + " баробар аст ба " + result);'+char(10)+N'    }'+char(10)+N'}')
,(11, 5, N'FUNCTION Power(base, exponent)'+char(10)+N'    result = 1'+char(10)+N'    '' То расидан ба нишондиҳанда 0'+char(10)+N'    WHILE exponent > 0'+char(10)+N'        '' Агар нишондиҳанда ҷуфт бошад'+char(10)+N'        IF exponent MOD 2 = 0 THEN'+char(10)+N'            base = base * base'+char(10)+N'            exponent = exponent / 2'+char(10)+N'        '' Агар нишондиҳанда тоқ бошад'+char(10)+N'        ELSE'+char(10)+N'            result = result * base'+char(10)+N'            exponent = exponent - 1'+char(10)+N'        END IF'+char(10)+N'    WEND'+char(10)+N'    Power = result'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Намунаи истифода:'+char(10)+N'base = 2'+char(10)+N'exponent = 10'+char(10)+N'result = Power(base, exponent)'+char(10)+N'PRINT base; " дар дараҷаи "; exponent; " баробар аст ба "; result')

,(12, 1, N'class Kruskal:'+char(10)+N'    def find_parent(self, parent, i):'+char(10)+N'        if parent[i] == i:'+char(10)+N'            return i'+char(10)+N'        return self.find_parent(parent, parent[i])'+char(10)+N''+char(10)+N'    def union(self, parent, rank, x, y):'+char(10)+N'        x_root = self.find_parent(parent, x)'+char(10)+N'        y_root = self.find_parent(parent, y)'+char(10)+N''+char(10)+N'        if rank[x_root] < rank[y_root]:'+char(10)+N'            parent[x_root] = y_root'+char(10)+N'        elif rank[x_root] > rank[y_root]:'+char(10)+N'            parent[y_root] = x_root'+char(10)+N'        else:'+char(10)+N'            parent[y_root] = x_root'+char(10)+N'            rank[x_root] += 1'+char(10)+N''+char(10)+N'    def kruskal_algorithm(self, graph):'+char(10)+N'        result = []'+char(10)+N'        i, e = 0, 0'+char(10)+N'        graph = sorted(graph, key=lambda item: item[2])'+char(10)+N'        parent, rank = [], []'+char(10)+N'        for node in range(len(graph)):'+char(10)+N'            parent.append(node)'+char(10)+N'            rank.append(0)'+char(10)+N''+char(10)+N'        while e < len(graph) - 1:'+char(10)+N'            u, v, w = graph[i]'+char(10)+N'            i += 1'+char(10)+N'            x = self.find_parent(parent, u)'+char(10)+N'            y = self.find_parent(parent, v)'+char(10)+N'            if x != y:'+char(10)+N'                e += 1'+char(10)+N'                result.append([u, v, w])'+char(10)+N'                self.union(parent, rank, x, y)'+char(10)+N'        return result'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'graph = [[0, 1, 4], [0, 7, 8], [1, 7, 11], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, 2], [8, 6, 6], [2, 5, 4], [2, 3, 7], [6, 5, 2], [3, 5, 14], [3, 4, 9], [5, 4, 10]]'+char(10)+N'kruskal = Kruskal()'+char(10)+N'result = kruskal.kruskal_algorithm(graph)'+char(10)+N'print(result)')

,(13, 1, N'def dfs(graph, start):'+char(10)+N'    """'+char(10)+N'    graph: Луғате, ки графро ифода мекунад.'+char(10)+N'    start: Нуқтаи оғоз.'+char(10)+N'    """'+char(10)+N'    visited = {key: 0 for key in graph}  # Ҳама нуқтаҳоро ҳамчун сафед оғоз кунед (дида нашуда)'+char(10)+N'    stack = [start]  # Истифодаи рӯйхат ҳамчун стек'+char(10)+N'    visited[start] = 1  # Нуқтаро ҳамчун хокистарӣ қайд мекунем (дар рафти боздид)'+char(10)+N''+char(10)+N'    while stack:'+char(10)+N'        vertex = stack.pop()'+char(10)+N'        print(vertex, "->", end=" ")'+char(10)+N'        '+char(10)+N'        # Для каждой смежной вершины'+char(10)+N'        if vertex in graph:'+char(10)+N'            for neighbour in graph[vertex]:'+char(10)+N'                if visited[neighbour] == 0:  # Агар нуқта сафед бошад (дида нашуда)'+char(10)+N'                    stack.append(neighbour)'+char(10)+N'                    visited[neighbour] = 1  # Нуқтаро ҳамчун хокистарӣ қайд мекунем (дар рафти боздид)'+char(10)+N''+char(10)+N'        visited[vertex] = 2  # Нуқтаро ҳамчун сиёҳ қайд мекунем (комилан дидан карда шудааст)'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'graph = {'+char(10)+N'    0: [1, 2],'+char(10)+N'    1: [2],'+char(10)+N'    2: [0, 3],'+char(10)+N'    3: [3]'+char(10)+N'}'+char(10)+N''+char(10)+N'start_vertex = 2'+char(10)+N'print(Ҷустуҷӯи амиқи такрории (DFS) сар карда аз нуқтаи", start_vertex)'+char(10)+N'dfs(graph, start_vertex)')
,(13, 2, N'#include <iostream>'+char(10)+N'#include <unordered_map>'+char(10)+N'#include <vector>'+char(10)+N'#include <stack>'+char(10)+N''+char(10)+N'void DFS(std::unordered_map<int, std::vector<int>> graph, int start) {'+char(10)+N'    std::unordered_map<int, int> visited;'+char(10)+N'    for (auto& pair : graph)'+char(10)+N'        visited[pair.first] = 0;'+char(10)+N''+char(10)+N'    std::stack<int> stack;'+char(10)+N'    stack.push(start);'+char(10)+N'    visited[start] = 1;'+char(10)+N''+char(10)+N'    std::cout << "DFS обход, начиная с вершины " << start << ": ";'+char(10)+N'    while (!stack.empty()) {'+char(10)+N'        int vertex = stack.top();'+char(10)+N'        stack.pop();'+char(10)+N'        std::cout << vertex << " -> ";'+char(10)+N''+char(10)+N'        if (graph.find(vertex) != graph.end()) {'+char(10)+N'            for (int neighbour : graph[vertex]) {'+char(10)+N'                if (visited[neighbour] == 0) {'+char(10)+N'                    stack.push(neighbour);'+char(10)+N'                    visited[neighbour] = 1;'+char(10)+N'                }'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        visited[vertex] = 2;'+char(10)+N'    }'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::unordered_map<int, std::vector<int>> graph = {'+char(10)+N'        {0, {1, 2}},'+char(10)+N'        {1, {2}},'+char(10)+N'        {2, {0, 3}},'+char(10)+N'        {3, {3}}'+char(10)+N'    };'+char(10)+N''+char(10)+N'    int startVertex = 2;'+char(10)+N'    DFS(graph, startVertex);'+char(10)+N''+char(10)+N'    return 0;'+char(10)+N'}')
,(13, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        Dictionary<int, List<int>> graph = new Dictionary<int, List<int>>()'+char(10)+N'        {'+char(10)+N'            { 0, new List<int>{1, 2} },'+char(10)+N'            { 1, new List<int>{2} },'+char(10)+N'            { 2, new List<int>{0, 3} },'+char(10)+N'            { 3, new List<int>{3} }'+char(10)+N'        };'+char(10)+N''+char(10)+N'        int startVertex = 2;'+char(10)+N'        Console.WriteLine("DFS обход, начиная с вершины " + startVertex + ":");'+char(10)+N'        DFS(graph, startVertex);'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void DFS(Dictionary<int, List<int>> graph, int start)'+char(10)+N'    {'+char(10)+N'        Dictionary<int, int> visited = new Dictionary<int, int>();'+char(10)+N'        foreach (var key in graph.Keys)'+char(10)+N'            visited[key] = 0;'+char(10)+N''+char(10)+N'        Stack<int> stack = new Stack<int>();'+char(10)+N'        stack.Push(start);'+char(10)+N'        visited[start] = 1;'+char(10)+N''+char(10)+N'        while (stack.Count > 0)'+char(10)+N'        {'+char(10)+N'            int vertex = stack.Pop();'+char(10)+N'            Console.Write(vertex + " -> ");'+char(10)+N''+char(10)+N'            if (graph.ContainsKey(vertex))'+char(10)+N'            {'+char(10)+N'                foreach (int neighbour in graph[vertex])'+char(10)+N'                {'+char(10)+N'                    if (visited[neighbour] == 0)'+char(10)+N'                    {'+char(10)+N'                        stack.Push(neighbour);'+char(10)+N'                        visited[neighbour] = 1;'+char(10)+N'                    }'+char(10)+N'                }'+char(10)+N'            }'+char(10)+N''+char(10)+N'            visited[vertex] = 2;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(13, 4, N'java '+char(10)+N'import java.util.*;'+char(10)+N''+char(10)+N'public class Main {'+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        Map<Integer, List<Integer>> graph = new HashMap<>();'+char(10)+N'        graph.put(0, Arrays.asList(1, 2));'+char(10)+N'        graph.put(1, Arrays.asList(2));'+char(10)+N'        graph.put(2, Arrays.asList(0, 3));'+char(10)+N'        graph.put(3, Arrays.asList(3));'+char(10)+N''+char(10)+N'        int startVertex = 2;'+char(10)+N'        System.out.println("DFS обход, начиная с вершины " + startVertex + ":");'+char(10)+N'        dfs(graph, startVertex);'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void dfs(Map<Integer, List<Integer>> graph, int start) {'+char(10)+N'        Map<Integer, Integer> visited = new HashMap<>();'+char(10)+N'        for (int key : graph.keySet())'+char(10)+N'            visited.put(key, 0);'+char(10)+N''+char(10)+N'        Stack<Integer> stack = new Stack<>();'+char(10)+N'        stack.push(start);'+char(10)+N'        visited.put(start, 1);'+char(10)+N''+char(10)+N'        while (!stack.empty()) {'+char(10)+N'            int vertex = stack.pop();'+char(10)+N'            System.out.print(vertex + " -> ");'+char(10)+N''+char(10)+N'            if (graph.containsKey(vertex)) {'+char(10)+N'                for (int neighbour : graph.get(vertex)) {'+char(10)+N'                    if (visited.get(neighbour) == 0) {'+char(10)+N'                        stack.push(neighbour);'+char(10)+N'                        visited.put(neighbour, 1);'+char(10)+N'                    }'+char(10)+N'                }'+char(10)+N'            }'+char(10)+N''+char(10)+N'            visited.put(vertex, 2);'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(13, 5, N'SUB DFS(graph, start)'+char(10)+N'    DIM visited(1 TO LEN(graph)) '' Барои қайд кардани қуллаҳои боздидшуда массив эҷод кунед'+char(10)+N'    DIM stack(1 TO LEN(graph)) '' Массив эҷод кунед, то ҳамчун стек истифода шавад'+char(10)+N'    FOR i = 1 TO LEN(graph)'+char(10)+N'        visited(i) = 0 '' Ҳама қуллаҳоро ҳамчун боздиднашуда оғоз кунед'+char(10)+N'    NEXT i'+char(10)+N'    stack(1) = start '' Қуллаи ибтидоиро дар стек ҷойгир кунед'+char(10)+N'    visited(start) = 1 '' Қуллаи ибтидоиро ҳамчун дидан қайд кунед'+char(10)+N''+char(10)+N'    WHILE stack(1) <> 0 '' Дар ҳоле ки стек холӣ нест'+char(10)+N'        vertex = stack(1) '' Гирифтани боло аз стек'+char(10)+N'        PRINT vertex; " -> ";'+char(10)+N'        stack(1) = 0 '' Хориҷ кардани як боло аз анбор'+char(10)+N'        FOR EACH neighbour IN graph(vertex) '' Барои ҳар як қуллаи ҳамсоя'+char(10)+N'            IF visited(neighbour) = 0 THEN '' Агар вертекс то хол дидан накарда бошад'+char(10)+N'                stack(1) = neighbour '' Илова кардани вертекс ба стек'+char(10)+N'                visited(neighbour) = 1 '' Қулларо ҳамчун дидан қайд кунед'+char(10)+N'                EXIT FOR '' Хуруҷ аз давра'+char(10)+N'            END IF'+char(10)+N'        NEXT neighbour'+char(10)+N'    WEND'+char(10)+N''+char(10)+N'    PRINT '' Барои баромади зебо хати холӣ чоп кунед'+char(10)+N'END SUB'+char(10)+N''+char(10)+N''' Оғозсозии график'+char(10)+N'DIM graph(4)'+char(10)+N'graph(1) = "12"'+char(10)+N'graph(2) = "2"'+char(10)+N'graph(3) = "03"'+char(10)+N'graph(4) = "3"'+char(10)+N''+char(10)+N''' Қуллаи ибтидоӣ'+char(10)+N'start_vertex = 2'+char(10)+N''+char(10)+N''' Даъват кардани тартиби DFS'+char(10)+N'PRINT "DFS обход, начиная с вершины "; start_vertex'+char(10)+N'CALL DFS(graph, start_vertex)')

,(14, 1, N'def power(base, exponent):'+char(10)+N'    # Агар нишондиҳанда 0 бошад, бармегардад 1'+char(10)+N'    if exponent == 0:'+char(10)+N'        return 1'+char(10)+N'    # Агар нишондиҳанда ҷуфт бошад, ҳисоб мекунем base^(exponent/2) ва мураббаъ кунед'+char(10)+N'    elif exponent % 2 == 0:'+char(10)+N'        temp = power(base, exponent // 2)'+char(10)+N'        return temp * temp'+char(10)+N'    # Агар нишондиҳанда тоқ бошад, ҳисоб мекунем base^(exponent-1) ва зарб ба base'+char(10)+N'    else:'+char(10)+N'        temp = power(base, (exponent - 1) // 2)'+char(10)+N'        return base * temp * temp'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'base = 2'+char(10)+N'exponent = 10'+char(10)+N'result = power(base, exponent)'+char(10)+N'print(base, "дар дараҷаи", exponent, " баробар ба", result)')
,(14, 2, N'#include <iostream>'+char(10)+N''+char(10)+N'int power(int base, int exponent) {'+char(10)+N'    // Агар нишондиҳанда 0 бошад, бармегардад 1'+char(10)+N'    if (exponent == 0) {'+char(10)+N'        return 1;'+char(10)+N'    }'+char(10)+N'    // Агар нишондиҳанда ҷуфт бошад, ҳисоб мекунем base^(exponent/2) ва мураббаъ кунед'+char(10)+N'    else if (exponent % 2 == 0) {'+char(10)+N'        int temp = power(base, exponent / 2);'+char(10)+N'        return temp * temp;'+char(10)+N'    }'+char(10)+N'    // Агар нишондиҳанда тоқ бошад, ҳисоб мекунем base^(exponent-1) ва зарб ба base'+char(10)+N'    else {'+char(10)+N'        int temp = power(base, (exponent - 1) / 2);'+char(10)+N'        return base * temp * temp;'+char(10)+N'    }'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    int base = 2;'+char(10)+N'    int exponent = 10;'+char(10)+N'    int result = power(base, exponent);'+char(10)+N'    std::cout << base << " дар дараҷаи " << exponent << " баробар ба " << result << std::endl;'+char(10)+N'    return 0;'+char(10)+N'}')
,(14, 3, N'using System;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static int Power(int baseNum, int exponent)'+char(10)+N'    {'+char(10)+N'        // Агар нишондиҳанда 0 бошад, бармегардад 1'+char(10)+N'        if (exponent == 0)'+char(10)+N'            return 1;'+char(10)+N'        // Агар нишондиҳанда ҷуфт бошад, ҳисоб мекунем base^(exponent/2) ва мураббаъ кунед'+char(10)+N'        else if (exponent % 2 == 0)'+char(10)+N'        {'+char(10)+N'            int temp = Power(baseNum, exponent / 2);'+char(10)+N'            return temp * temp;'+char(10)+N'        }'+char(10)+N'        // Агар нишондиҳанда тоқ бошад, ҳисоб мекунем base^(exponent-1) ва зарб ба base'+char(10)+N'        else'+char(10)+N'        {'+char(10)+N'            int temp = Power(baseNum, (exponent - 1) / 2);'+char(10)+N'            return baseNum * temp * temp;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        int baseNum = 2;'+char(10)+N'        int exponent = 10;'+char(10)+N'        int result = Power(baseNum, exponent);'+char(10)+N'        Console.WriteLine(baseNum + " дар дараҷаи " + exponent + " баробар ба " + result);'+char(10)+N'    }'+char(10)+N'}')
,(14, 4, N'public class Main {'+char(10)+N'    static int power(int base, int exponent) {'+char(10)+N'        // Агар нишондиҳанда 0 бошад, бармегардад 1'+char(10)+N'        if (exponent == 0)'+char(10)+N'            return 1;'+char(10)+N'        // Агар нишондиҳанда ҷуфт бошад, ҳисоб мекунем base^(exponent/2) ва мураббаъ кунед'+char(10)+N'        else if (exponent % 2 == 0) {'+char(10)+N'            int temp = power(base, exponent / 2);'+char(10)+N'            return temp * temp;'+char(10)+N'        }'+char(10)+N'        // Агар нишондиҳанда тоқ бошад, ҳисоб мекунем base^(exponent-1) ва зарб ба base'+char(10)+N'        else {'+char(10)+N'            int temp = power(base, (exponent - 1) / 2);'+char(10)+N'            return base * temp * temp;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int base = 2;'+char(10)+N'        int exponent = 10;'+char(10)+N'        int result = power(base, exponent);'+char(10)+N'        System.out.println(base + " дар дараҷаи " + exponent + " баробар ба " + result);'+char(10)+N'    }'+char(10)+N'}')
,(14, 5, N'FUNCTION Power(base, exponent)'+char(10)+N'    '' Агар нишондиҳанда 0 бошад, бармегардад 1'+char(10)+N'    IF exponent = 0 THEN'+char(10)+N'        Power = 1'+char(10)+N'        EXIT FUNCTION'+char(10)+N'    END IF'+char(10)+N'    '' Агар нишондиҳанда ҷуфт бошад, ҳисоб мекунем base^(exponent/2) ва мураббаъ кунед'+char(10)+N'    IF exponent MOD 2 = 0 THEN'+char(10)+N'        temp = Power(base, exponent / 2)'+char(10)+N'        Power = temp * temp'+char(10)+N'        EXIT FUNCTION'+char(10)+N'    END IF'+char(10)+N'    '' Агар нишондиҳанда тоқ бошад, ҳисоб мекунем base^(exponent-1) ва зарб ба base'+char(10)+N'    temp = Power(base, (exponent - 1) / 2)'+char(10)+N'    Power = base * temp * temp'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Намунаи истифода'+char(10)+N'base = 2'+char(10)+N'exponent = 10'+char(10)+N'result = Power(base, exponent)'+char(10)+N'PRINT base; " дар дараҷаи "; exponent; " баробар ба "; result')

,(15, 1, N'def is_palindrome(s):'+char(10)+N'    left = 0'+char(10)+N'    right = len(s) - 1'+char(10)+N'    '+char(10)+N'    while left < right:'+char(10)+N'        if s[left] != s[right]:'+char(10)+N'            return False'+char(10)+N'        left += 1'+char(10)+N'        right -= 1'+char(10)+N'    '+char(10)+N'    return True'+char(10)+char(10)+N'# Намунаи истифода '+char(10)+N's = "racecar"'+char(10)+N'print(f"Сатри \"{s}\" палиндром аст: {is_palindrome(s)}")')
,(15, 2, N'#include <iostream>'+char(10)+N'#include <string>'+char(10)+N''+char(10)+N'bool is_palindrome(std::string s) {'+char(10)+N'    int left = 0;'+char(10)+N'    int right = s.length() - 1;'+char(10)+N''+char(10)+N'    while (left < right) {'+char(10)+N'        if (s[left] != s[right]) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'        left++;'+char(10)+N'        right--;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    return true;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::string s = "racecar";'+char(10)+N'    std::cout << "Сатри \"" << s << "\" палиндром аст: " << std::boolalpha << is_palindrome(s) << std::endl;'+char(10)+N'    return 0;'+char(10)+N'}')
,(15, 3, N'using System;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static bool IsPalindrome(string s)'+char(10)+N'    {'+char(10)+N'        int left = 0;'+char(10)+N'        int right = s.Length - 1;'+char(10)+N''+char(10)+N'        while (left < right)'+char(10)+N'        {'+char(10)+N'            if (s[left] != s[right])'+char(10)+N'                return false;'+char(10)+N'            left++;'+char(10)+N'            right--;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        string s = "racecar";'+char(10)+N'        Console.WriteLine($"Сатри \"{s}\" палиндром аст: {IsPalindrome(s)}");'+char(10)+N'    }'+char(10)+N'}')
,(15, 4, N'public class Main {'+char(10)+N'    static boolean isPalindrome(String s) {'+char(10)+N'        int left = 0;'+char(10)+N'        int right = s.length() - 1;'+char(10)+N''+char(10)+N'        while (left < right) {'+char(10)+N'            if (s.charAt(left) != s.charAt(right))'+char(10)+N'                return false;'+char(10)+N'            left++;'+char(10)+N'            right--;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        String s = "racecar";'+char(10)+N'        System.out.println("Сатри \"" + s + "\" палиндром аст: " + isPalindrome(s));'+char(10)+N'    }'+char(10)+N'}')
,(15, 5, N'FUNCTION IsPalindrome(s$)'+char(10)+N'    left = 1'+char(10)+N'    right = LEN(s$)'+char(10)+N''+char(10)+N'    WHILE left < right'+char(10)+N'        IF MID$(s$, left, 1) <> MID$(s$, right, 1) THEN'+char(10)+N'            IsPalindrome = FALSE'+char(10)+N'            EXIT FUNCTION'+char(10)+N'        END IF'+char(10)+N'        left = left + 1'+char(10)+N'        right = right - 1'+char(10)+N'    WEND'+char(10)+N''+char(10)+N'    IsPalindrome = TRUE'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Намунаи истифода'+char(10)+N's$ = "racecar"'+char(10)+N'PRINT "Сатри \""; s$; "\" палиндром аст: "; IsPalindrome(s$)')

,(16, 1, N'def find_pair_with_sum(arr, target_sum):'+char(10)+N'    left = 0'+char(10)+N'    right = len(arr) - 1'+char(10)+N'    while left < right:'+char(10)+N'        current_sum = arr[left] + arr[right]'+char(10)+N'        if current_sum == target_sum:'+char(10)+N'            return (arr[left], arr[right])'+char(10)+N'        elif current_sum < target_sum:'+char(10)+N'            left += 1'+char(10)+N'        else:'+char(10)+N'            right -= 1'+char(10)+N'    '+char(10)+N'    return None'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'arr = [1, 2, 3, 4, 6]'+char(10)+N'target_sum = 6'+char(10)+N'result = find_pair_with_sum(arr, target_sum)'+char(10)+N'print(f" Ҷуфти рақамҳо бо ҷамъ {target_sum}: {result}")')
,(16, 2, N'#include <iostream>'+char(10)+N'#include <vector>'+char(10)+N''+char(10)+N'std::pair<int, int> find_pair_with_sum(std::vector<int> arr, int target_sum) {'+char(10)+N'    int left = 0;'+char(10)+N'    int right = arr.size() - 1;'+char(10)+N''+char(10)+N'    while (left < right) {'+char(10)+N'        int current_sum = arr[left] + arr[right];'+char(10)+N'        if (current_sum == target_sum)'+char(10)+N'            return std::make_pair(arr[left], arr[right]);'+char(10)+N'        else if (current_sum < target_sum)'+char(10)+N'            left++;'+char(10)+N'        else'+char(10)+N'            right--;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    return std::make_pair(-1, -1); // Return {-1, -1} if pair not found'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::vector<int> arr = {1, 2, 3, 4, 6};'+char(10)+N'    int target_sum = 6;'+char(10)+N'    std::pair<int, int> result = find_pair_with_sum(arr, target_sum);'+char(10)+N'    std::cout << "Ҷуфти рақамҳо бо ҷамъ " << target_sum << ": (" << result.first << ", " << result.second << ")" << std::endl;'+char(10)+N'    return 0;'+char(10)+N'}')
,(16, 3, N'using System;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static (int, int) FindPairWithSum(int[] arr, int targetSum)'+char(10)+N'    {'+char(10)+N'        int left = 0;'+char(10)+N'        int right = arr.Length - 1;'+char(10)+N''+char(10)+N'        while (left < right)'+char(10)+N'        {'+char(10)+N'            int currentSum = arr[left] + arr[right];'+char(10)+N'            if (currentSum == targetSum)'+char(10)+N'                return (arr[left], arr[right]);'+char(10)+N'            else if (currentSum < targetSum)'+char(10)+N'                left++;'+char(10)+N'            else'+char(10)+N'                right--;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        return (-1, -1); // Return (-1, -1) if pair not found'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        int[] arr = {1, 2, 3, 4, 6};'+char(10)+N'        int targetSum = 6;'+char(10)+N'        var result = FindPairWithSum(arr, targetSum);'+char(10)+N'        Console.WriteLine($"Ҷуфти рақамҳо бо ҷамъ {targetSum}: ({result.Item1}, {result.Item2})");'+char(10)+N'    }'+char(10)+N'}')
,(16, 4, N'import java.util.*;'+char(10)+N''+char(10)+N'public class Main {'+char(10)+N'    static int[] findPairWithSum(int[] arr, int targetSum) {'+char(10)+N'        int left = 0;'+char(10)+N'        int right = arr.length - 1;'+char(10)+N''+char(10)+N'        while (left < right) {'+char(10)+N'            int currentSum = arr[left] + arr[right];'+char(10)+N'            if (currentSum == targetSum)'+char(10)+N'                return new int[]{arr[left], arr[right]};'+char(10)+N'            else if (currentSum < targetSum)'+char(10)+N'                left++;'+char(10)+N'            else'+char(10)+N'                right--;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        return new int[]{-1, -1}; // Return {-1, -1} if pair not found'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int[] arr = {1, 2, 3, 4, 6};'+char(10)+N'        int targetSum = 6;'+char(10)+N'        int[] result = findPairWithSum(arr, targetSum);'+char(10)+N'        System.out.println("Ҷуфти рақамҳо бо ҷамъ " + targetSum + ": (" + result[0] + ", " + result[1] + ")");'+char(10)+N'    }'+char(10)+N'}')
,(16, 5, N'FUNCTION FindPairWithSum(arr(), targetSum)'+char(10)+N'    left = 1'+char(10)+N'    right = LEN(arr())'+char(10)+N''+char(10)+N'    WHILE left < right'+char(10)+N'        currentSum = arr(left) + arr(right)'+char(10)+N'        IF currentSum = targetSum THEN'+char(10)+N'            FindPairWithSum = (arr(left), arr(right))'+char(10)+N'            EXIT FUNCTION'+char(10)+N'        ELSEIF currentSum < targetSum THEN'+char(10)+N'            left = left + 1'+char(10)+N'        ELSE'+char(10)+N'            right = right - 1'+char(10)+N'        END IF'+char(10)+N'    WEND'+char(10)+N''+char(10)+N'    FindPairWithSum = (-1, -1) '' Возвращаем (-1, -1), если пара не найдена'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Намунаи истифода'+char(10)+N'DIM arr(5)'+char(10)+N'arr(1) = 1'+char(10)+N'arr(2) = 2'+char(10)+N'arr(3) = 3'+char(10)+N'arr(4) = 4'+char(10)+N'arr(5) = 6'+char(10)+N'targetSum = 6'+char(10)+N'result = FindPairWithSum(arr(), targetSum)'+char(10)+N'PRINT "Ҷуфти рақамҳо бо ҷамъ "; targetSum; ": "; result')

,(17, 1, N'def merge_sorted_arrays(arr1, arr2):'+char(10)+N'    merged_array = []'+char(10)+N'    i = 0'+char(10)+N'    j = 0'+char(10)+N'    while i < len(arr1) and j < len(arr2):'+char(10)+N'        if arr1[i] < arr2[j]:'+char(10)+N'            merged_array.append(arr1[i])'+char(10)+N'            i += 1'+char(10)+N'        else:'+char(10)+N'            merged_array.append(arr2[j])'+char(10)+N'            j += 1'+char(10)+N'    '+char(10)+N'    # Унсурҳои боқимондаро илова кунед'+char(10)+N'    while i < len(arr1):'+char(10)+N'        merged_array.append(arr1[i])'+char(10)+N'        i += 1'+char(10)+N'    while j < len(arr2):'+char(10)+N'        merged_array.append(arr2[j])'+char(10)+N'        j += 1'+char(10)+N'    '+char(10)+N'    return merged_array'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'arr1 = [1, 3, 5]'+char(10)+N'arr2 = [2, 4, 6]'+char(10)+N'result = merge_sorted_arrays(arr1, arr2)'+char(10)+N'print(f" Массиви якҷояшуда: {result}")')
,(17, 2, N'#include <iostream>'+char(10)+N'#include <vector>'+char(10)+N''+char(10)+N'std::vector<int> merge_sorted_arrays(std::vector<int> arr1, std::vector<int> arr2) {'+char(10)+N'    std::vector<int> merged_array;'+char(10)+N'    int i = 0;'+char(10)+N'    int j = 0;'+char(10)+N''+char(10)+N'    while (i < arr1.size() && j < arr2.size()) {'+char(10)+N'        if (arr1[i] < arr2[j]) {'+char(10)+N'            merged_array.push_back(arr1[i]);'+char(10)+N'            i++;'+char(10)+N'        } else {'+char(10)+N'            merged_array.push_back(arr2[j]);'+char(10)+N'            j++;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    // Add remaining elements from both arrays'+char(10)+N'    while (i < arr1.size()) {'+char(10)+N'        merged_array.push_back(arr1[i]);'+char(10)+N'        i++;'+char(10)+N'    }'+char(10)+N'    while (j < arr2.size()) {'+char(10)+N'        merged_array.push_back(arr2[j]);'+char(10)+N'        j++;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    return merged_array;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::vector<int> arr1 = {1, 3, 5};'+char(10)+N'    std::vector<int> arr2 = {2, 4, 6};'+char(10)+N'    std::vector<int> result = merge_sorted_arrays(arr1, arr2);'+char(10)+N'    std::cout << "Массиви якҷояшуда: ";'+char(10)+N'    for (int num : result) {'+char(10)+N'        std::cout << num << " ";'+char(10)+N'    }'+char(10)+N'    std::cout << std::endl;'+char(10)+N'    return 0;'+char(10)+N'}')
,(17, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static List<int> MergeSortedArrays(List<int> arr1, List<int> arr2)'+char(10)+N'    {'+char(10)+N'        List<int> mergedArray = new List<int>();'+char(10)+N'        int i = 0;'+char(10)+N'        int j = 0;'+char(10)+N''+char(10)+N'        while (i < arr1.Count && j < arr2.Count)'+char(10)+N'        {'+char(10)+N'            if (arr1[i] < arr2[j])'+char(10)+N'            {'+char(10)+N'                mergedArray.Add(arr1[i]);'+char(10)+N'                i++;'+char(10)+N'            }'+char(10)+N'            else'+char(10)+N'            {'+char(10)+N'                mergedArray.Add(arr2[j]);'+char(10)+N'                j++;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        // Add remaining elements from both arrays'+char(10)+N'        while (i < arr1.Count)'+char(10)+N'        {'+char(10)+N'            mergedArray.Add(arr1[i]);'+char(10)+N'            i++;'+char(10)+N'        }'+char(10)+N'        while (j < arr2.Count)'+char(10)+N'        {'+char(10)+N'            mergedArray.Add(arr2[j]);'+char(10)+N'            j++;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        return mergedArray;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        List<int> arr1 = new List<int> { 1, 3, 5 };'+char(10)+N'        List<int> arr2 = new List<int> { 2, 4, 6 };'+char(10)+N'        List<int> result = MergeSortedArrays(arr1, arr2);'+char(10)+N'        Console.Write("Массиви якҷояшуда: ");'+char(10)+N'        foreach (int num in result)'+char(10)+N'        {'+char(10)+N'            Console.Write(num + " ");'+char(10)+N'        }'+char(10)+N'        Console.WriteLine();'+char(10)+N'    }'+char(10)+N'}')
,(17, 4, N'import java.util.*;'+char(10)+N''+char(10)+N'public class Main {'+char(10)+N'    static List<Integer> mergeSortedArrays(List<Integer> arr1, List<Integer> arr2) {'+char(10)+N'        List<Integer> mergedArray = new ArrayList<>();'+char(10)+N'        int i = 0;'+char(10)+N'        int j = 0;'+char(10)+N''+char(10)+N'        while (i < arr1.size() && j < arr2.size()) {'+char(10)+N'            if (arr1.get(i) < arr2.get(j)) {'+char(10)+N'                mergedArray.add(arr1.get(i));'+char(10)+N'                i++;'+char(10)+N'            } else {'+char(10)+N'                mergedArray.add(arr2.get(j));'+char(10)+N'                j++;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        // Унсурҳои боқимондаро аз ҳарду массив илова кунед'+char(10)+N'        while (i < arr1.size()) {'+char(10)+N'            mergedArray.add(arr1.get(i));'+char(10)+N'            i++;'+char(10)+N'        }'+char(10)+N'        while (j < arr2.size()) {'+char(10)+N'            mergedArray.add(arr2.get(j));'+char(10)+N'            j++;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        return mergedArray;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        List<Integer> arr1 = Arrays.asList(1, 3, 5);'+char(10)+N'        List<Integer> arr2 = Arrays.asList(2, 4, 6);'+char(10)+N'        List<Integer> result = mergeSortedArrays(arr1, arr2);'+char(10)+N'        System.out.print("Массиви якҷояшуда: ");'+char(10)+N'        for (int num : result) {'+char(10)+N'            System.out.print(num + " ");'+char(10)+N'        }'+char(10)+N'        System.out.println();'+char(10)+N'    }'+char(10)+N'}')
,(17, 5, N'FUNCTION MergeSortedArrays(arr1(), arr2())'+char(10)+N'    DIM mergedArray(LEN(arr1()) + LEN(arr2()))'+char(10)+N'    i = 1'+char(10)+N'    j = 1'+char(10)+N'    k = 1'+char(10)+N''+char(10)+N'    WHILE i <= LEN(arr1()) AND j <= LEN(arr2())'+char(10)+N'        IF arr1(i) < arr2(j) THEN'+char(10)+N'            mergedArray(k) = arr1(i)'+char(10)+N'            i = i + 1'+char(10)+N'        ELSE'+char(10)+N'            mergedArray(k) = arr2(j)'+char(10)+N'            j = j + 1'+char(10)+N'        END IF'+char(10)+N'        k = k + 1'+char(10)+N'    WEND'+char(10)+N''+char(10)+N'    '' Добавление оставшихся элементов из обоих массивов'+char(10)+N'    WHILE i <= LEN(arr1())'+char(10)+N'        mergedArray(k) = arr1(i)'+char(10)+N'        i = i + 1'+char(10)+N'        k = k + 1'+char(10)+N'    WEND'+char(10)+N'    WHILE j <= LEN(arr2())'+char(10)+N'        mergedArray(k) = arr2(j)'+char(10)+N'        j = j + 1'+char(10)+N'        k = k + 1'+char(10)+N'    WEND'+char(10)+N''+char(10)+N'    MergeSortedArrays = mergedArray'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Намунаи истифода'+char(10)+N'DIM arr1(3)'+char(10)+N'DIM arr2(3)'+char(10)+N'arr1(1) = 1'+char(10)+N'arr1(2) = 3'+char(10)+N'arr1(3) = 5'+char(10)+N'arr2(1) = 2'+char(10)+N'arr2(2) = 4'+char(10)+N'arr2(3) = 6'+char(10)+N'result = MergeSortedArrays(arr1(), arr2())'+char(10)+N'PRINT "Массиви якҷояшуда: ";'+char(10)+N'FOR i = 1 TO LEN(result)'+char(10)+N'    PRINT result(i); " ";'+char(10)+N'NEXT i'+char(10)+N'PRINT')

,(18, 1, N'import heapq'+char(10)+N''+char(10)+N'def dijkstra(graph, start):'+char(10)+N'    """'+char(10)+N'    graph: Луғате, ки графро ифода мекунад. Калидҳои болоӣ, арзишҳо рӯйхати кортежҳо (сосед, вес).'+char(10)+N'    start: Қуллаи ибтидоӣ.'+char(10)+N'    return: Луғати масофаҳои кӯтоҳтарин аз қуллаи ибтидоӣ то ҳар қулла.'+char(10)+N'    """'+char(10)+N'    # Оғози кор'+char(10)+N'    distances = {vertex: float("infinity") for vertex in graph}'+char(10)+N'    distances[start] = 0'+char(10)+N'    priority_queue = [(0, start)]'+char(10)+N'    visited = set()'+char(10)+N''+char(10)+N'    while priority_queue:'+char(10)+N'        current_distance, current_vertex = heapq.heappop(priority_queue)'+char(10)+N'        if current_vertex in visited:'+char(10)+N'            continue'+char(10)+N''+char(10)+N'        visited.add(current_vertex)'+char(10)+N'        for neighbor, weight in graph[current_vertex]:'+char(10)+N'            distance = current_distance + weight'+char(10)+N'            if distance < distances[neighbor]:'+char(10)+N'                distances[neighbor] = distance'+char(10)+N'                heapq.heappush(priority_queue, (distance, neighbor))'+char(10)+N''+char(10)+N'    return distances'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'graph = {'+char(10)+N'    "A": [("B", 1), ("C", 4)],'+char(10)+N'    "B": [("A", 1), ("C", 2), ("D", 5)],'+char(10)+N'    "C": [("A", 4), ("B", 2), ("D", 1)],'+char(10)+N'    "D": [("B", 5), ("C", 1)]'+char(10)+N'}'+char(10)+N''+char(10)+N'start_vertex = "A"'+char(10)+N'distances = dijkstra(graph, start_vertex)'+char(10)+N'print(f" Масофаи кӯтоҳтарин аз қулла {start_vertex}:")'+char(10)+N'for vertex, distance in distances.items():'+char(10)+N'    print(f" Ба боло {vertex}: {distance}")')
,(18, 2, N'#include <iostream>'+char(10)+N'#include <unordered_map>'+char(10)+N'#include <vector>'+char(10)+N'#include <queue>'+char(10)+N'#include <utility>'+char(10)+N'#include <limits>'+char(10)+N''+char(10)+N'std::unordered_map<std::string, int> dijkstra(std::unordered_map<std::string, std::vector<std::pair<std::string, int>>> graph, std::string start) {'+char(10)+N'    std::unordered_map<std::string, int> distances;'+char(10)+N'    for (auto& pair : graph)'+char(10)+N'        distances[pair.first] = std::numeric_limits<int>::max();'+char(10)+N''+char(10)+N'    distances[start] = 0;'+char(10)+N'    std::priority_queue<std::pair<int, std::string>, std::vector<std::pair<int, std::string>>, std::greater<std::pair<int, std::string>>> priorityQueue;'+char(10)+N'    priorityQueue.push(std::make_pair(0, start));'+char(10)+N''+char(10)+N'    while (!priorityQueue.empty()) {'+char(10)+N'        int currentDistance = priorityQueue.top().first;'+char(10)+N'        std::string currentVertex = priorityQueue.top().second;'+char(10)+N'        priorityQueue.pop();'+char(10)+N''+char(10)+N'        if (distances[currentVertex] < currentDistance)'+char(10)+N'            continue;'+char(10)+N''+char(10)+N'        for (const auto& neighbour : graph[currentVertex]) {'+char(10)+N'            int distance = currentDistance + neighbour.second;'+char(10)+N'            if (distance < distances[neighbour.first]) {'+char(10)+N'                distances[neighbour.first] = distance;'+char(10)+N'                priorityQueue.push(std::make_pair(distance, neighbour.first));'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    return distances;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::unordered_map<std::string, std::vector<std::pair<std::string, int>>> graph = {'+char(10)+N'        {"A", {{"B", 1}, {"C", 4}}},'+char(10)+N'        {"B", {{"A", 1}, {"C", 2}, {"D", 5}}},'+char(10)+N'        {"C", {{"A", 4}, {"B", 2}, {"D", 1}}},'+char(10)+N'        {"D", {{"B", 5}, {"C", 1}}}'+char(10)+N'    };'+char(10)+N''+char(10)+N'    std::string startVertex = "A";'+char(10)+N'    std::unordered_map<std::string, int> distances = dijkstra(graph, startVertex);'+char(10)+N'    std::cout << "Масофаи кӯтоҳтарин аз қулла " << startVertex << ":\n";'+char(10)+N'    for (const auto& kvp : distances) {'+char(10)+N'        std::cout << "Ба боло " << kvp.first << ": " << kvp.second << std::endl;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    return 0;'+char(10)+N'}')
,(18, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static void Main(string[] args)'+char(10)+N'    {'+char(10)+N'        Dictionary<string, List<(string, int)>> graph = new Dictionary<string, List<(string, int)>>()'+char(10)+N'        {'+char(10)+N'            { "A", new List<(string, int)>{("B", 1), ("C", 4)} },'+char(10)+N'            { "B", new List<(string, int)>{("A", 1), ("C", 2), ("D", 5)} },'+char(10)+N'            { "C", new List<(string, int)>{("A", 4), ("B", 2), ("D", 1)} },'+char(10)+N'            { "D", new List<(string, int)>{("B", 5), ("C", 1)} }'+char(10)+N'        };'+char(10)+N''+char(10)+N'        string startVertex = "A";'+char(10)+N'        Dictionary<string, int> distances = Dijkstra(graph, startVertex);'+char(10)+N'        Console.WriteLine($"Масофаи кӯтоҳтарин аз қулла {startVertex}:");'+char(10)+N'        foreach (var kvp in distances)'+char(10)+N'        {'+char(10)+N'            Console.WriteLine($"Ба боло {kvp.Key}: {kvp.Value}");'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static Dictionary<string, int> Dijkstra(Dictionary<string, List<(string, int)>> graph, string start)'+char(10)+N'    {'+char(10)+N'        Dictionary<string, int> distances = new Dictionary<string, int>();'+char(10)+N'        foreach (var vertex in graph.Keys)'+char(10)+N'            distances[vertex] = int.MaxValue;'+char(10)+N''+char(10)+N'        distances[start] = 0;'+char(10)+N'        PriorityQueue<(int, string)> priorityQueue = new PriorityQueue<(int, string)>();'+char(10)+N'        priorityQueue.Enqueue((0, start));'+char(10)+N''+char(10)+N'        while (priorityQueue.Count > 0)'+char(10)+N'        {'+char(10)+N'            (int currentDistance, string currentVertex) = priorityQueue.Dequeue();'+char(10)+N'            if (distances[currentVertex] < currentDistance)'+char(10)+N'                continue;'+char(10)+N''+char(10)+N'            foreach ((string neighbor, int weight) in graph[currentVertex])'+char(10)+N'            {'+char(10)+N'                int distance = currentDistance + weight;'+char(10)+N'                if (distance < distances[neighbor])'+char(10)+N'                {'+char(10)+N'                    distances[neighbor] = distance;'+char(10)+N'                    priorityQueue.Enqueue((distance, neighbor));'+char(10)+N'                }'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        return distances;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    // Татбиқи навбати афзалиятнок'+char(10)+N'    class PriorityQueue<T> where T : IComparable<T>'+char(10)+N'    {'+char(10)+N'        private List<T> data;'+char(10)+N''+char(10)+N'        public PriorityQueue()'+char(10)+N'        {'+char(10)+N'            this.data = new List<T>();'+char(10)+N'        }'+char(10)+N''+char(10)+N'        public int Count'+char(10)+N'        {'+char(10)+N'            get { return this.data.Count; }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        public void Enqueue(T item)'+char(10)+N'        {'+char(10)+N'            this.data.Add(item);'+char(10)+N'            int ci = this.data.Count - 1; // child index; start at end'+char(10)+N'            while (ci > 0)'+char(10)+N'            {'+char(10)+N'                int pi = (ci - 1) / 2; // индекси волидайн'+char(10)+N'                if (this.data[ci].CompareTo(this.data[pi]) >= 0)'+char(10)+N'                    break; // адад кўдак калонтар аст (ё баробар) волидайн, бинобар ин мо анҷом додем'+char(10)+N'                T tmp = this.data[ci];'+char(10)+N'                this.data[ci] = this.data[pi];'+char(10)+N'                this.data[pi] = tmp;'+char(10)+N'                ci = pi;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        public T Dequeue()'+char(10)+N'        {'+char(10)+N'            // фарз мекунад, ки pq холӣ нест; то рамзи занг'+char(10)+N'            int li = this.data.Count - 1; // индекси охирин (пеш аз хориҷ кардан)'+char(10)+N'            T frontItem = this.data[0];   // пеш оварад'+char(10)+N'            this.data[0] = this.data[li];'+char(10)+N'            this.data.RemoveAt(li);'+char(10)+N''+char(10)+N'            --li; // индекси охирин (пас аз нест кардан)'+char(10)+N'            int pi = 0; // индекси волидайн. аз пеши pq оғоз кунед'+char(10)+N'            while (true)'+char(10)+N'            {'+char(10)+N'                int ci = pi * 2 + 1; // шохиси чапи фарзанди волидайн'+char(10)+N'                if (ci > li)'+char(10)+N'                    break;  // кӯдакон ин тавр накардаанд'+char(10)+N'                int rc = ci + 1;     // фарзанди рост'+char(10)+N'                if (rc <= li && this.data[rc].CompareTo(this.data[ci]) < 0) // агар rc (ci + 1) мавҷуд бошад ва он аз кӯдаки чап хурдтар бошад, ба ҷои он rc -ро истифода баред'+char(10)+N'                    ci = rc;'+char(10)+N'                if (this.data[pi].CompareTo(this.data[ci]) <= 0)'+char(10)+N'                    break; // волидайн аз хурдтарин кӯдак (ё ба он баробар) хурдтар аст'+char(10)+N'                T tmp = this.data[pi];'+char(10)+N'                this.data[pi] = this.data[ci];'+char(10)+N'                this.data[ci] = tmp; // иваз кардани падару модар ва фарзанд'+char(10)+N'                pi = ci;'+char(10)+N'            }'+char(10)+N'            return frontItem;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(18, 4, N'import java.util.*;'+char(10)+N''+char(10)+N'public class Main {'+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        Map<String, List<String>> graph = new HashMap<>();'+char(10)+N'        graph.put("A", Arrays.asList("B1", "C4"));'+char(10)+N'        graph.put("B", Arrays.asList("A1", "C2", "D5"));'+char(10)+N'        graph.put("C", Arrays.asList("A4", "B2", "D1"));'+char(10)+N'        graph.put("D", Arrays.asList("B5", "C1"));'+char(10)+N''+char(10)+N'        String startVertex = "A";'+char(10)+N'        Map<String, Integer> distances = dijkstra(graph, startVertex);'+char(10)+N'        System.out.println("Масофаи кӯтоҳтарин аз қулла " + startVertex + ":");'+char(10)+N'        for (Map.Entry<String, Integer> entry : distances.entrySet()) {'+char(10)+N'            System.out.println("Ба боло " + entry.getKey() + ": " + entry.getValue());'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static Map<String, Integer> dijkstra(Map<String, List<String>> graph, String start) {'+char(10)+N'        Map<String, Integer> distances = new HashMap<>();'+char(10)+N'        for (String vertex : graph.keySet())'+char(10)+N'            distances.put(vertex, Integer.MAX_VALUE);'+char(10)+N''+char(10)+N'        distances.put(start, 0);'+char(10)+N'        PriorityQueue<String> priorityQueue = new PriorityQueue<>((a, b) -> distances.get(a) - distances.get(b));'+char(10)+N'        priorityQueue.offer(start);'+char(10)+N''+char(10)+N'        while (!priorityQueue.isEmpty()) {'+char(10)+N'            String currentVertex = priorityQueue.poll();'+char(10)+N'            for (String edge : graph.get(currentVertex)) {'+char(10)+N'                String neighbor = edge.substring(0, 1);'+char(10)+N'                int weight = Integer.parseInt(edge.substring(1));'+char(10)+N'                int distance = distances.get(currentVertex) + weight;'+char(10)+N'                if (distance < distances.get(neighbor)) {'+char(10)+N'                    distances.put(neighbor, distance);'+char(10)+N'                    priorityQueue.offer(neighbor);'+char(10)+N'                }'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        return distances;'+char(10)+N'    }'+char(10)+N'}')
,(18, 5, N'SUB Dijkstra(graph$, start$)'+char(10)+N'    DIM distances(LEN(graph$))'+char(10)+N'    DIM priority_queue(100)'+char(10)+N'    DIM visited$(LEN(graph$))'+char(10)+N'    '+char(10)+N'    FOR i = 1 TO LEN(graph$)'+char(10)+N'        distances(i) = 99999 '' Беохир'+char(10)+N'    NEXT i'+char(10)+N'    distances(INSTR(start$, graph$)) = 0'+char(10)+N'    priority_queue(1) = "0;" + start$'+char(10)+N'    '+char(10)+N'    WHILE LEN(priority_queue(1)) > 0'+char(10)+N'        current = SPLIT(priority_queue(1), ";")(1)'+char(10)+N'        priority_queue(1) = ""'+char(10)+N'        IF INSTR(visited$, current) > 0 THEN'+char(10)+N'            CONTINUE WHILE'+char(10)+N'        END IF'+char(10)+N'        visited$ = visited$ + current'+char(10)+N'        '+char(10)+N'        FOR EACH edge IN SPLIT(MID$(graph$, INSTR(current, graph$) + LEN(current) + 1), ";")'+char(10)+N'            neighbor$ = LEFT$(edge, 1)'+char(10)+N'            weight = VAL(MID$(edge, 3))'+char(10)+N'            distance = distances(INSTR(current, graph$)) + weight'+char(10)+N'            IF distance < distances(INSTR(neighbor$, graph$)) THEN'+char(10)+N'                distances(INSTR(neighbor$, graph$)) = distance'+char(10)+N'                priority_queue(1) = priority_queue(1) + ";" + STR$(distance) + ";" + neighbor$'+char(10)+N'            END IF'+char(10)+N'        NEXT edge'+char(10)+N'        FOR i = 1 TO LEN(priority_queue(1))'+char(10)+N'            IF MID$(priority_queue(1), i, 1) = ";" THEN'+char(10)+N'                EXIT FOR'+char(10)+N'            END IF'+char(10)+N'        NEXT i'+char(10)+N'        priority_queue(1) = MID$(priority_queue(1), i + 1)'+char(10)+N'        FOR i = 2 TO LEN(priority_queue(1))'+char(10)+N'            IF MID$(priority_queue(1), i, 1) = ";" THEN'+char(10)+N'                EXIT FOR'+char(10)+N'            END IF'+char(10)+N'        NEXT i'+char(10)+N'        priority_queue(1) = MID$(priority_queue(1), i + 1)'+char(10)+N'    WEND'+char(10)+N'    '+char(10)+N'    FOR i = 1 TO LEN(graph$)'+char(10)+N'        PRINT "Ба боло "; MID$(graph$, i, 1); ": "; distances(i)'+char(10)+N'    NEXT i'+char(10)+N'END SUB'+char(10)+N''+char(10)+N''' Намунаи истифода'+char(10)+N'graph$ = "AB1;AC4;BA1;BC2;BD5;CA4;CB2;CD1;DB5;DC1"'+char(10)+N'start_vertex$ = "A"'+char(10)+N'PRINT "Масофаи кӯтоҳтарин аз қулла "; start_vertex$; ":"'+char(10)+N'CALL Dijkstra(graph$, start_vertex$)')

,(19, 1, N'def is_safe(board, row, col, N):'+char(10)+N'    # Санҷиши амудӣ ва уфуқӣ'+char(10)+N'    for i in range(N):'+char(10)+N'        if board[row][i] == 1 or board[i][col] == 1:'+char(10)+N'            return False'+char(10)+N'    '+char(10)+N'    # Диагоналҳоро тафтиш кунед'+char(10)+N'    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):'+char(10)+N'        if board[i][j] == 1:'+char(10)+N'            return False'+char(10)+N'    for i, j in zip(range(row, -1, -1), range(col, N)):'+char(10)+N'        if board[i][j] == 1:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'def solve_n_queens_util(board, col, N):'+char(10)+N'    if col >= N:'+char(10)+N'        return True'+char(10)+N'    '+char(10)+N'    for i in range(N):'+char(10)+N'        if is_safe(board, i, col, N):'+char(10)+N'            board[i][col] = 1'+char(10)+N'            if solve_n_queens_util(board, col + 1, N):'+char(10)+N'                return True'+char(10)+N'            board[i][col] = 0'+char(10)+N'    return False')
,(19, 2, N'#include <iostream>'+char(10)+N'#include <vector>'+char(10)+N''+char(10)+N'bool isSafe(std::vector<std::vector<int>>& board, int row, int col, int N) {'+char(10)+N'    // Check vertical and horizontal positions'+char(10)+N'    for (int i = 0; i < N; ++i) {'+char(10)+N'        if (board[row][i] == 1 || board[i][col] == 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    // Check diagonals'+char(10)+N'    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {'+char(10)+N'        if (board[i][j] == 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    for (int i = row, j = col; i >= 0 && j < N; --i, ++j) {'+char(10)+N'        if (board[i][j] == 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return true;'+char(10)+N'}'+char(10)+N''+char(10)+N'bool solveNQueensUtil(std::vector<std::vector<int>>& board, int col, int N) {'+char(10)+N'    if (col >= N) {'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    for (int i = 0; i < N; ++i) {'+char(10)+N'        if (isSafe(board, i, col, N)) {'+char(10)+N'            board[i][col] = 1;'+char(10)+N'            if (solveNQueensUtil(board, col + 1, N)) {'+char(10)+N'                return true;'+char(10)+N'            }'+char(10)+N'            board[i][col] = 0;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return false;'+char(10)+N'}')
,(19, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static bool IsSafe(List<List<int>> board, int row, int col, int N) {'+char(10)+N'        for (int i = 0; i < N; ++i) {'+char(10)+N'            if (board[row][i] == 1 || board[i][col] == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {'+char(10)+N'            if (board[i][j] == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        for (int i = row, j = col; i >= 0 && j < N; --i, ++j) {'+char(10)+N'            if (board[i][j] == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static bool SolveNQueensUtil(List<List<int>> board, int col, int N) {'+char(10)+N'        if (col >= N) {'+char(10)+N'            return true;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        for (int i = 0; i < N; ++i) {'+char(10)+N'            if (IsSafe(board, i, col, N)) {'+char(10)+N'                board[i][col] = 1;'+char(10)+N'                if (SolveNQueensUtil(board, col + 1, N)) {'+char(10)+N'                    return true;'+char(10)+N'                }'+char(10)+N'                board[i][col] = 0;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return false;'+char(10)+N'    }'+char(10)+N'}')
,(19, 4, N'import java.util.List;'+char(10)+N''+char(10)+N'public class Main {'+char(10)+N'    static boolean isSafe(List<List<Integer>> board, int row, int col, int N) {'+char(10)+N'        for (int i = 0; i < N; ++i) {'+char(10)+N'            if (board.get(row).get(i) == 1 || board.get(i).get(col) == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {'+char(10)+N'            if (board.get(i).get(j) == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        for (int i = row, j = col; i >= 0 && j < N; --i, ++j) {'+char(10)+N'            if (board.get(i).get(j) == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static boolean solveNQueensUtil(List<List<Integer>> board, int col, int N) {'+char(10)+N'        if (col >= N) {'+char(10)+N'            return true;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        for (int i = 0; i < N; ++i) {'+char(10)+N'            if (isSafe(board, i, col, N)) {'+char(10)+N'                board.get(i).set(col, 1);'+char(10)+N'                if (solveNQueensUtil(board, col + 1, N)) {'+char(10)+N'                    return true;'+char(10)+N'                }'+char(10)+N'                board.get(i).set(col, 0);'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return false;'+char(10)+N'    }'+char(10)+N'}')
,(19, 5, N'FUNCTION IsSafe(board, row, col, N)'+char(10)+N'    '' Check vertical and horizontal positions'+char(10)+N'    FOR i = 0 TO N - 1'+char(10)+N'        IF board[row][i] = 1 OR board[i][col] = 1 THEN'+char(10)+N'            IsSafe = FALSE'+char(10)+N'            EXIT FUNCTION'+char(10)+N'        END IF'+char(10)+N'    NEXT i'+char(10)+N''+char(10)+N'    '' Check diagonals'+char(10)+N'    FOR i = row TO 0 STEP -1'+char(10)+N'        FOR j = col TO 0 STEP -1'+char(10)+N'            IF board[i][j] = 1 THEN'+char(10)+N'                IsSafe = FALSE'+char(10)+N'                EXIT FUNCTION'+char(10)+N'            END IF'+char(10)+N'        NEXT j'+char(10)+N'    NEXT i'+char(10)+N''+char(10)+N'    FOR i = row TO 0 STEP -1'+char(10)+N'        FOR j = col TO N - 1'+char(10)+N'            IF board[i][j] = 1 THEN'+char(10)+N'                IsSafe = FALSE'+char(10)+N'                EXIT FUNCTION'+char(10)+N'            END IF'+char(10)+N'        NEXT j'+char(10)+N'    NEXT i'+char(10)+N''+char(10)+N'    IsSafe = TRUE'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Function to solve N-Queens problem recursively'+char(10)+N'FUNCTION SolveNQueensUtil(board, col, N)'+char(10)+N'    IF col >= N THEN'+char(10)+N'        SolveNQueensUtil = TRUE'+char(10)+N'        EXIT FUNCTION'+char(10)+N'    END IF'+char(10)+N''+char(10)+N'    FOR i = 0 TO N - 1'+char(10)+N'        IF IsSafe(board, i, col, N) THEN'+char(10)+N'            board[i][col] = 1'+char(10)+N'            IF SolveNQueensUtil(board, col + 1, N) THEN'+char(10)+N'                SolveNQueensUtil = TRUE'+char(10)+N'                EXIT FUNCTION'+char(10)+N'            END IF'+char(10)+N'            board[i][col] = 0'+char(10)+N'        END IF'+char(10)+N'    NEXT i'+char(10)+N'    SolveNQueensUtil = FALSE'+char(10)+N'END FUNCTION')

,(20, 1, N'def is_safe(board, row, col, N):'+char(10)+N'    # Санҷиши амудӣ ва уфуқӣ'+char(10)+N'    for i in range(N):'+char(10)+N'        if board[row][i] == 1 or board[i][col] == 1:'+char(10)+N'            return False'+char(10)+N'    '+char(10)+N'    # Диагоналҳоро тафтиш кунед'+char(10)+N'    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):'+char(10)+N'        if board[i][j] == 1:'+char(10)+N'            return False'+char(10)+N'    for i, j in zip(range(row, -1, -1), range(col, N)):'+char(10)+N'        if board[i][j] == 1:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'def solve_n_queens(N):'+char(10)+N'    board = [[0] * N for _ in range(N)]'+char(10)+N'    if not solve_n_queens_util(board, 0, N):'+char(10)+N'        return None')
,(20, 2, N'#include <vector>'+char(10)+N''+char(10)+N'bool isSafe(std::vector<std::vector<int>>& board, int row, int col, int N) {'+char(10)+N'    // Check vertical and horizontal positions'+char(10)+N'    for (int i = 0; i < N; ++i) {'+char(10)+N'        if (board[row][i] == 1 || board[i][col] == 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    // Check diagonals'+char(10)+N'    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {'+char(10)+N'        if (board[i][j] == 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    for (int i = row, j = col; i >= 0 && j < N; --i, ++j) {'+char(10)+N'        if (board[i][j] == 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return true;'+char(10)+N'}'+char(10)+N''+char(10)+N'bool solveNQueensUtil(std::vector<std::vector<int>>& board, int col, int N) {'+char(10)+N'    if (col >= N) {'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    for (int i = 0; i < N; ++i) {'+char(10)+N'        if (isSafe(board, i, col, N)) {'+char(10)+N'            board[i][col] = 1;'+char(10)+N'            if (solveNQueensUtil(board, col + 1, N)) {'+char(10)+N'                return true;'+char(10)+N'            }'+char(10)+N'            board[i][col] = 0;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return false;'+char(10)+N'}'+char(10)+N''+char(10)+N'std::vector<std::vector<int>> solveNQueens(int N) {'+char(10)+N'    std::vector<std::vector<int>> board(N, std::vector<int>(N, 0));'+char(10)+N'    if (!solveNQueensUtil(board, 0, N)) {'+char(10)+N'        board.clear();'+char(10)+N'    }'+char(10)+N'    return board;'+char(10)+N'}')
,(20, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N''+char(10)+N'class Program'+char(10)+N'{'+char(10)+N'    static bool IsSafe(List<List<int>> board, int row, int col, int N) {'+char(10)+N'        for (int i = 0; i < N; ++i) {'+char(10)+N'            if (board[row][i] == 1 || board[i][col] == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {'+char(10)+N'            if (board[i][j] == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        for (int i = row, j = col; i >= 0 && j < N; --i, ++j) {'+char(10)+N'            if (board[i][j] == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static bool SolveNQueensUtil(List<List<int>> board, int col, int N) {'+char(10)+N'        if (col >= N) {'+char(10)+N'            return true;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        for (int i = 0; i < N; ++i) {'+char(10)+N'            if (IsSafe(board, i, col, N)) {'+char(10)+N'                board[i][col] = 1;'+char(10)+N'                if (SolveNQueensUtil(board, col + 1, N)) {'+char(10)+N'                    return true;'+char(10)+N'                }'+char(10)+N'                board[i][col] = 0;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return false;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static List<List<int>> SolveNQueens(int N) {'+char(10)+N'        List<List<int>> board = new List<List<int>>();'+char(10)+N'        for (int i = 0; i < N; ++i) {'+char(10)+N'            board.Add(new List<int>(new int[N]));'+char(10)+N'        }'+char(10)+N'        if (!SolveNQueensUtil(board, 0, N)) {'+char(10)+N'            board.Clear();'+char(10)+N'        }'+char(10)+N'        return board;'+char(10)+N'    }'+char(10)+N'}')
,(20, 4, N'import java.util.*;'+char(10)+N''+char(10)+N'public class NQueensSolver {'+char(10)+N'    public static boolean isSafe(int[][] board, int row, int col, int N) {'+char(10)+N'        // Check vertical and horizontal positions'+char(10)+N'        for (int i = 0; i < N; ++i) {'+char(10)+N'            if (board[row][i] == 1 || board[i][col] == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        // Check diagonals'+char(10)+N'        for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {'+char(10)+N'            if (board[i][j] == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        for (int i = row, j = col; i >= 0 && j < N; --i, ++j) {'+char(10)+N'            if (board[i][j] == 1) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static boolean solveNQueensUtil(int[][] board, int col, int N) {'+char(10)+N'        if (col >= N) {'+char(10)+N'            return true;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        for (int i = 0; i < N; ++i) {'+char(10)+N'            if (isSafe(board, i, col, N)) {'+char(10)+N'                board[i][col] = 1;'+char(10)+N'                if (solveNQueensUtil(board, col + 1, N)) {'+char(10)+N'                    return true;'+char(10)+N'                }'+char(10)+N'                board[i][col] = 0;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return false;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static int[][] solveNQueens(int N) {'+char(10)+N'        int[][] board = new int[N][N];'+char(10)+N'        if (!solveNQueensUtil(board, 0, N)) {'+char(10)+N'            board = null;'+char(10)+N'        }'+char(10)+N'        return board;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int N = 4;'+char(10)+N'        int[][] solution = solveNQueens(N);'+char(10)+N'        if (solution == null) {'+char(10)+N'            System.out.println("No solution exists.");'+char(10)+N'        } else {'+char(10)+N'            System.out.println("Solution:");'+char(10)+N'            for (int i = 0; i < N; ++i) {'+char(10)+N'                for (int j = 0; j < N; ++j) {'+char(10)+N'                    System.out.print(solution[i][j] + " ");'+char(10)+N'                }'+char(10)+N'                System.out.println();'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(20, 5, N'FUNCTION IsSafe(board, row, col, N)'+char(10)+N'    '' Check vertical and horizontal positions'+char(10)+N'    FOR i = 0 TO N - 1'+char(10)+N'        IF board[row][i] = 1 OR board[i][col] = 1 THEN'+char(10)+N'            IsSafe = FALSE'+char(10)+N'            EXIT FUNCTION'+char(10)+N'        END IF'+char(10)+N'    NEXT i'+char(10)+N''+char(10)+N'    '' Check diagonals'+char(10)+N'    FOR i = row TO 0 STEP -1'+char(10)+N'        FOR j = col TO 0 STEP -1'+char(10)+N'            IF board[i][j] = 1 THEN'+char(10)+N'                IsSafe = FALSE'+char(10)+N'                EXIT FUNCTION'+char(10)+N'            END IF'+char(10)+N'        NEXT j'+char(10)+N'    NEXT i'+char(10)+N''+char(10)+N'    FOR i = row TO 0 STEP -1'+char(10)+N'        FOR j = col TO N - 1'+char(10)+N'            IF board[i][j] = 1 THEN'+char(10)+N'                IsSafe = FALSE'+char(10)+N'                EXIT FUNCTION'+char(10)+N'            END IF'+char(10)+N'        NEXT j'+char(10)+N'    NEXT i'+char(10)+N''+char(10)+N'    IsSafe = TRUE'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Function to solve N-Queens problem recursively'+char(10)+N'FUNCTION SolveNQueensUtil(board, col, N)'+char(10)+N'    IF col >= N THEN'+char(10)+N'        SolveNQueensUtil = TRUE'+char(10)+N'        EXIT FUNCTION'+char(10)+N'    END IF'+char(10)+N''+char(10)+N'    FOR i = 0 TO N - 1'+char(10)+N'        IF IsSafe(board, i, col, N) THEN'+char(10)+N'            board[i][col] = 1'+char(10)+N'            IF SolveNQueensUtil(board, col + 1, N) THEN'+char(10)+N'                SolveNQueensUtil = TRUE'+char(10)+N'                EXIT FUNCTION'+char(10)+N'            END IF'+char(10)+N'            board[i][col] = 0'+char(10)+N'        END IF'+char(10)+N'    NEXT i'+char(10)+N'    SolveNQueensUtil = FALSE'+char(10)+N'END FUNCTION'+char(10)+N''+char(10)+N''' Function to initialize and solve N-Queens problem'+char(10)+N'FUNCTION SolveNQueens(N)'+char(10)+N'    DIM board(N - 1, N - 1)'+char(10)+N'    IF NOT SolveNQueensUtil(board, 0, N) THEN'+char(10)+N'        DIM emptyBoard()'+char(10)+N'        SolveNQueens = emptyBoard'+char(10)+N'    ELSE'+char(10)+N'        SolveNQueens = board'+char(10)+N'    END IF'+char(10)+N'END FUNCTION')

,(21, 1, N'def is_prime(n):'+char(10)+N'    if n <= 1:'+char(10)+N'        return False'+char(10)+N'    for i in range(2, n):'+char(10)+N'        if n % i == 0:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'# Тафтиши рақамҳои аз 1 то 100:'+char(10)+N'N = 100'+char(10)+N'for num in range(1, N+1):'+char(10)+N'    if is_prime(num):'+char(10)+N'        print(num, " ин адади оддӣ аст ")'+char(10)+N'    else:'+char(10)+N'        print(num, " ин адади оддӣ нест ")')
,(21, 2, N'#include <iostream>'+char(10)+N''+char(10)+N'bool isPrime(int n) {'+char(10)+N'    if (n <= 1) {'+char(10)+N'        return false;'+char(10)+N'    }'+char(10)+N'    for (int i = 2; i < n; ++i) {'+char(10)+N'        if (n % i == 0) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return true;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    int N = 100;'+char(10)+N'    for (int num = 1; num <= N; ++num) {'+char(10)+N'        if (isPrime(num)) {'+char(10)+N'            std::cout << num << " ин адади оддӣ аст" << std::endl;'+char(10)+N'        } else {'+char(10)+N'            std::cout << num << " ин адади оддӣ нест" << std::endl;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return 0;'+char(10)+N'}')
,(21, 3, N'using System;'+char(10)+N''+char(10)+N'class Program {'+char(10)+N'    static bool IsPrime(int n) {'+char(10)+N'        if (n <= 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'        for (int i = 2; i < n; ++i) {'+char(10)+N'            if (n % i == 0) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args) {'+char(10)+N'        int N = 100;'+char(10)+N'        for (int num = 1; num <= N; ++num) {'+char(10)+N'            if (IsPrime(num)) {'+char(10)+N'                Console.WriteLine(num + " ин адади оддӣ аст");'+char(10)+N'            } else {'+char(10)+N'                Console.WriteLine(num + " ин адади оддӣ нест");'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(21, 4, N'public class Main {'+char(10)+N'    static boolean isPrime(int n) {'+char(10)+N'        if (n <= 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'        for (int i = 2; i < n; ++i) {'+char(10)+N'            if (n % i == 0) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int N = 100;'+char(10)+N'        for (int num = 1; num <= N; ++num) {'+char(10)+N'            if (isPrime(num)) {'+char(10)+N'                System.out.println(num + " ин адади оддӣ аст");'+char(10)+N'            } else {'+char(10)+N'                System.out.println(num + " ин адади оддӣ нест");'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(21, 5, N'Imports System'+char(10)+N''+char(10)+N'Module Program'+char(10)+N'    Function IsPrime(n As Integer) As Boolean'+char(10)+N'        If n <= 1 Then'+char(10)+N'            Return False'+char(10)+N'        End If'+char(10)+N'        For i As Integer = 2 To n - 1'+char(10)+N'            If n Mod i = 0 Then'+char(10)+N'                Return False'+char(10)+N'            End If'+char(10)+N'        Next'+char(10)+N'        Return True'+char(10)+N'    End Function'+char(10)+N''+char(10)+N'    Sub Main(args As String())'+char(10)+N'        Dim N As Integer = 100'+char(10)+N'        For num As Integer = 1 To N'+char(10)+N'            If IsPrime(num) Then'+char(10)+N'                Console.WriteLine(num & " ин адади оддӣ аст")'+char(10)+N'            Else'+char(10)+N'                Console.WriteLine(num & " ин адади оддӣ нест")'+char(10)+N'            End If'+char(10)+N'        Next'+char(10)+N'    End Sub'+char(10)+N'End Module')

,(22, 1, N'def is_prime_optimized_half(n):'+char(10)+N'    if n <= 1:'+char(10)+N'        return False'+char(10)+N'    for i in range(2, n // 2 + 1):'+char(10)+N'        if n % i == 0:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'# Тафтиши рақамҳои аз 1 то 100:'+char(10)+N'N = 100'+char(10)+N'for num in range(1, N+1):'+char(10)+N'    if is_prime_optimized_half(num):'+char(10)+N'        print(num, " ин адади оддӣ аст ")'+char(10)+N'    else:'+char(10)+N'        print(num, " ин адади оддӣ нест ")')
,(22, 2, N'#include <iostream>'+char(10)+N''+char(10)+N'bool isPrimeOptimizedHalf(int n) {'+char(10)+N'    if (n <= 1) {'+char(10)+N'        return false;'+char(10)+N'    }'+char(10)+N'    for (int i = 2; i <= n / 2; ++i) {'+char(10)+N'        if (n % i == 0) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return true;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    int N = 100;'+char(10)+N'    for (int num = 1; num <= N; ++num) {'+char(10)+N'        if (isPrimeOptimizedHalf(num)) {'+char(10)+N'            std::cout << num << " ин адади оддӣ аст" << std::endl;'+char(10)+N'        } else {'+char(10)+N'            std::cout << num << " ин адади оддӣ нест" << std::endl;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return 0;'+char(10)+N'}')
,(22, 3, N'using System;'+char(10)+N''+char(10)+N'class Program {'+char(10)+N'    static bool IsPrimeOptimizedHalf(int n) {'+char(10)+N'        if (n <= 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'        for (int i = 2; i <= n / 2; ++i) {'+char(10)+N'            if (n % i == 0) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args) {'+char(10)+N'        int N = 100;'+char(10)+N'        for (int num = 1; num <= N; ++num) {'+char(10)+N'            if (IsPrimeOptimizedHalf(num)) {'+char(10)+N'                Console.WriteLine(num + " ин адади оддӣ аст");'+char(10)+N'            } else {'+char(10)+N'                Console.WriteLine(num + " ин адади оддӣ нест");'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(22, 4, N'public class Main {'+char(10)+N'    static boolean isPrimeOptimizedHalf(int n) {'+char(10)+N'        if (n <= 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'        for (int i = 2; i <= n / 2; ++i) {'+char(10)+N'            if (n % i == 0) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int N = 100;'+char(10)+N'        for (int num = 1; num <= N; ++num) {'+char(10)+N'            if (isPrimeOptimizedHalf(num)) {'+char(10)+N'                System.out.println(num + " ин адади оддӣ аст");'+char(10)+N'            } else {'+char(10)+N'                System.out.println(num + " ин адади оддӣ нест");'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')

,(23, 1, N'import math'+char(10)+N''+char(10)+N'def is_prime_optimized_sqrt(n):'+char(10)+N'    if n <= 1:'+char(10)+N'        return False'+char(10)+N'    for i in range(2, int(math.sqrt(n)) + 1):'+char(10)+N'        if n % i == 0:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'# Тафтиши рақамҳои аз 1 то 100:'+char(10)+N'N = 100'+char(10)+N'for num in range(1, N+1):'+char(10)+N'    if is_prime_optimized_sqrt(num):'+char(10)+N'        print(num, " ин адади оддӣ аст ")'+char(10)+N'    else:'+char(10)+N'        print(num, " ин адади оддӣ нест ")')
,(23, 2, N'#include <iostream>'+char(10)+N'#include <cmath>'+char(10)+N''+char(10)+N'bool isPrimeOptimizedSqrt(int n) {'+char(10)+N'    if (n <= 1) {'+char(10)+N'        return false;'+char(10)+N'    }'+char(10)+N'    for (int i = 2; i <= std::sqrt(n); ++i) {'+char(10)+N'        if (n % i == 0) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return true;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    int N = 100;'+char(10)+N'    for (int num = 1; num <= N; ++num) {'+char(10)+N'        if (isPrimeOptimizedSqrt(num)) {'+char(10)+N'            std::cout << num << " ин адади оддӣ аст" << std::endl;'+char(10)+N'        } else {'+char(10)+N'            std::cout << num << " ин адади оддӣ нест" << std::endl;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return 0;'+char(10)+N'}')
,(23, 3, N'using System;'+char(10)+N''+char(10)+N'class Program {'+char(10)+N'    static bool IsPrimeOptimizedSqrt(int n) {'+char(10)+N'        if (n <= 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'        for (int i = 2; i <= Math.Sqrt(n); ++i) {'+char(10)+N'            if (n % i == 0) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args) {'+char(10)+N'        int N = 100;'+char(10)+N'        for (int num = 1; num <= N; ++num) {'+char(10)+N'            if (IsPrimeOptimizedSqrt(num)) {'+char(10)+N'                Console.WriteLine(num + " ин адади оддӣ аст");'+char(10)+N'            } else {'+char(10)+N'                Console.WriteLine(num + " ин адади оддӣ нест");'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')
,(23, 4, N'public class Main {'+char(10)+N'    static boolean isPrimeOptimizedSqrt(int n) {'+char(10)+N'        if (n <= 1) {'+char(10)+N'            return false;'+char(10)+N'        }'+char(10)+N'        for (int i = 2; i <= Math.sqrt(n); ++i) {'+char(10)+N'            if (n % i == 0) {'+char(10)+N'                return false;'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        return true;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        int N = 100;'+char(10)+N'        for (int num = 1; num <= N; ++num) {'+char(10)+N'            if (isPrimeOptimizedSqrt(num)) {'+char(10)+N'                System.out.println(num + " ин адади оддӣ аст");'+char(10)+N'            } else {'+char(10)+N'                System.out.println(num + " ин адади оддӣ нест");'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'}')

,(24, 1, N'import random'+char(10)+N''+char(10)+N'def quicksort(arr):'+char(10)+N'    if len(arr) <= 1:'+char(10)+N'        return arr'+char(10)+N''+char(10)+N'    # Интихоби унсури дастгирии тасодуфӣ'+char(10)+N'    pivot_index = random.randint(0, len(arr) - 1)'+char(10)+N'    pivot = arr[pivot_index]'+char(10)+N'    # Тақсимоти массив ба се қисм'+char(10)+N'    less = [x for x in arr if x < pivot]'+char(10)+N'    equal = [x for x in arr if x == pivot]'+char(10)+N'    greater = [x for x in arr if x > pivot]'+char(10)+N'    # Ҷобаҷогузории рекурсивии зермассивҳо ва якҷоя кардани натиҷаҳо'+char(10)+N'    return quicksort(less) + equal + quicksort(greater)'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'arr = [3, 6, 8, 10, 1, 2, 1]'+char(10)+N'sorted_arr = quicksort(arr)'+char(10)+N'print("Массиви мураттабшуда:", sorted_arr)')
,(24, 2, N'#include <iostream>'+char(10)+N'#include <vector>'+char(10)+N'#include <algorithm>'+char(10)+N''+char(10)+N'std::vector<int> quicksort(std::vector<int>& arr) {'+char(10)+N'    if (arr.size() <= 1) {'+char(10)+N'        return arr;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    // Select a random pivot element'+char(10)+N'    int pivotIndex = rand() % arr.size();'+char(10)+N'    int pivot = arr[pivotIndex];'+char(10)+N'    std::vector<int> less, equal, greater;'+char(10)+N''+char(10)+N'    // Divide the array into three parts'+char(10)+N'    for (int x : arr) {'+char(10)+N'        if (x < pivot) {'+char(10)+N'            less.push_back(x);'+char(10)+N'        } else if (x == pivot) {'+char(10)+N'            equal.push_back(x);'+char(10)+N'        } else {'+char(10)+N'            greater.push_back(x);'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    // Recursively sort subarrays and concatenate the results'+char(10)+N'    std::vector<int> sortedArr;'+char(10)+N'    sortedArr.insert(sortedArr.end(), quicksort(less).begin(), quicksort(less).end());'+char(10)+N'    sortedArr.insert(sortedArr.end(), equal.begin(), equal.end());'+char(10)+N'    sortedArr.insert(sortedArr.end(), quicksort(greater).begin(), quicksort(greater).end());'+char(10)+N'    return sortedArr;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::vector<int> arr = {3, 6, 8, 10, 1, 2, 1};'+char(10)+N'    std::vector<int> sortedArr = quicksort(arr);'+char(10)+N'    std::cout << "Sorted array:";'+char(10)+N'    for (int x : sortedArr) {'+char(10)+N'        std::cout << " " << x;'+char(10)+N'    }'+char(10)+N'    std::cout << std::endl;'+char(10)+N'    return 0;'+char(10)+N'}')
,(24, 3, N'using System;'+char(10)+N'using System.Collections.Generic;'+char(10)+N'using System.Linq;'+char(10)+N''+char(10)+N'class Program {'+char(10)+N'    static Random rand = new Random();'+char(10)+N''+char(10)+N'    static List<int> QuickSort(List<int> arr) {'+char(10)+N'        if (arr.Count <= 1) {'+char(10)+N'            return arr;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        // Select a random pivot element'+char(10)+N'        int pivotIndex = rand.Next(arr.Count);'+char(10)+N'        int pivot = arr[pivotIndex];'+char(10)+N'        List<int> less = new List<int>();'+char(10)+N'        List<int> equal = new List<int>();'+char(10)+N'        List<int> greater = new List<int>();'+char(10)+N''+char(10)+N'        // Divide the array into three parts'+char(10)+N'        foreach (int x in arr) {'+char(10)+N'            if (x < pivot) {'+char(10)+N'                less.Add(x);'+char(10)+N'            } else if (x == pivot) {'+char(10)+N'                equal.Add(x);'+char(10)+N'            } else {'+char(10)+N'                greater.Add(x);'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N''+char(10)+N'        // Recursively sort subarrays and concatenate the results'+char(10)+N'        List<int> sortedArr = new List<int>();'+char(10)+N'        sortedArr.AddRange(QuickSort(less));'+char(10)+N'        sortedArr.AddRange(equal);'+char(10)+N'        sortedArr.AddRange(QuickSort(greater));'+char(10)+N'        return sortedArr;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    static void Main(string[] args) {'+char(10)+N'        List<int> arr = new List<int> {3, 6, 8, 10, 1, 2, 1};'+char(10)+N'        List<int> sortedArr = QuickSort(arr);'+char(10)+N'        Console.Write("Sorted array:");'+char(10)+N'        foreach (int x in sortedArr) {'+char(10)+N'            Console.Write(" " + x);'+char(10)+N'        }'+char(10)+N'        Console.WriteLine();'+char(10)+N'    }'+char(10)+N'}')
,(24, 4, N'import java.util.*;'+char(10)+N''+char(10)+N'public class QuickSort {'+char(10)+N'    public static List<Integer> quicksort(List<Integer> arr) {'+char(10)+N'        if (arr.size() <= 1) {'+char(10)+N'            return arr;'+char(10)+N'        }'+char(10)+N''+char(10)+N'        // Select a random pivot element'+char(10)+N'        Random rand = new Random();'+char(10)+N'        int pivotIndex = rand.nextInt(arr.size());'+char(10)+N'        int pivot = arr.get(pivotIndex);'+char(10)+N'        List<Integer> less = new ArrayList<>();'+char(10)+N'        List<Integer> equal = new ArrayList<>();'+char(10)+N'        List<Integer> greater = new ArrayList<>();'+char(10)+N'        '+char(10)+N'        // Divide the array into three parts'+char(10)+N'        for (int x : arr) {'+char(10)+N'            if (x < pivot) {'+char(10)+N'                less.add(x);'+char(10)+N'            } else if (x == pivot) {'+char(10)+N'                equal.add(x);'+char(10)+N'            } else {'+char(10)+N'                greater.add(x);'+char(10)+N'            }'+char(10)+N'        }'+char(10)+N'        '+char(10)+N'        // Recursively sort subarrays and concatenate the results'+char(10)+N'        List<Integer> sortedArr = new ArrayList<>();'+char(10)+N'        sortedArr.addAll(quicksort(less));'+char(10)+N'        sortedArr.addAll(equal);'+char(10)+N'        sortedArr.addAll(quicksort(greater));'+char(10)+N'        return sortedArr;'+char(10)+N'    }'+char(10)+N''+char(10)+N'    public static void main(String[] args) {'+char(10)+N'        List<Integer> arr = Arrays.asList(3, 6, 8, 10, 1, 2, 1);'+char(10)+N'        List<Integer> sortedArr = quicksort(arr);'+char(10)+N'        System.out.println("Sorted array: " + sortedArr);'+char(10)+N'    }'+char(10)+N'}')
,(24, 5, N'mports System'+char(10)+N'Imports System.Collections.Generic'+char(10)+N''+char(10)+N'Module Program'+char(10)+N'    Dim rand As New Random()'+char(10)+N''+char(10)+N'    Function QuickSort(ByVal arr As List(Of Integer)) As List(Of Integer)'+char(10)+N'        If arr.Count <= 1 Then'+char(10)+N'            Return arr'+char(10)+N'        End If'+char(10)+N''+char(10)+N'        '' Select a random pivot element'+char(10)+N'        Dim pivotIndex As Integer = rand.Next(arr.Count)'+char(10)+N'        Dim pivot As Integer = arr(pivotIndex)'+char(10)+N'        Dim less As New List(Of Integer)'+char(10)+N'        Dim equal As New List(Of Integer)'+char(10)+N'        Dim greater As New List(Of Integer)'+char(10)+N''+char(10)+N'        '' Divide the array into three parts'+char(10)+N'        For Each x As Integer In arr'+char(10)+N'            If x < pivot Then'+char(10)+N'                less.Add(x)'+char(10)+N'            ElseIf x = pivot Then'+char(10)+N'                equal.Add(x)'+char(10)+N'            Else'+char(10)+N'                greater.Add(x)'+char(10)+N'            End If'+char(10)+N'        Next'+char(10)+N''+char(10)+N'        '' Recursively sort subarrays and concatenate the results'+char(10)+N'        Dim sortedArr As New List(Of Integer)'+char(10)+N'        sortedArr.AddRange(QuickSort(less))'+char(10)+N'        sortedArr.AddRange(equal)'+char(10)+N'        sortedArr.AddRange(QuickSort(greater))'+char(10)+N'        Return sortedArr'+char(10)+N'    End Function'+char(10)+N''+char(10)+N'    Sub Main(args As String())'+char(10)+N'        Dim arr As New List(Of Integer) From {3, 6, 8, 10, 1, 2, 1}'+char(10)+N'        Dim sortedArr As List(Of Integer) = QuickSort(arr)'+char(10)+N'        Console.Write("Sorted array:")'+char(10)+N'        For Each x As Integer In sortedArr'+char(10)+N'            Console.Write(" " + x.ToString())'+char(10)+N'        Next'+char(10)+N'        Console.WriteLine()'+char(10)+N'    End Sub'+char(10)+N'End Module')

,(25, 1, N'def fractional_knapsack(weights, values, W):'+char(10)+N'    """'+char(10)+N'    weights: Рӯйхати тарозуи ашё.'+char(10)+N'    values: Рӯйхати арзиши ашё.'+char(10)+N'    W: Иқтидори максималии ҷузвдон.'+char(10)+N'    return: Арзиши максималии ашё дар ҷузвдон.'+char(10)+N'    """'+char(10)+N'    items = [(values[i] / weights[i], weights[i], values[i]) for i in range(len(weights))]'+char(10)+N'    items.sort(reverse=True, key=lambda x: x[0])'+char(10)+N''+char(10)+N'    total_value = 0'+char(10)+N'    for value_per_weight, weight, value in items:'+char(10)+N'        if W == 0:'+char(10)+N'            break'+char(10)+N'        if weight <= W:'+char(10)+N'            W -= weight'+char(10)+N'            total_value += value'+char(10)+N'        else:'+char(10)+N'            total_value += value_per_weight * W'+char(10)+N'            W = 0'+char(10)+N''+char(10)+N'    return total_value'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'weights = [10, 20, 30]'+char(10)+N'values = [60, 100, 120]'+char(10)+N'W = 50'+char(10)+N'print("Арзиши ҳадди аксар (банди хароб ):", fractional_knapsack(weights, values, W))')

,(26, 1, N'def knapsack(weights, values, W):'+char(10)+N'    """'+char(10)+N'    weights: Рӯйхати тарозуи ашё.'+char(10)+N'    values: Рӯйхати арзиши ашё.'+char(10)+N'    W: Максимальная вместимость рюкзака.'+char(10)+N'    return: Арзиши максималии маҷмӯи ашее, ки ба ҷузвдон мувофиқат мекунанд.'+char(10)+N'    """'+char(10)+N'    n = len(weights)'+char(10)+N'    dp = [[0] * (W + 1) for _ in range(n + 1)]'+char(10)+N''+char(10)+N'    for i in range(1, n + 1):'+char(10)+N'        for w in range(1, W + 1):'+char(10)+N'            if weights[i-1] <= w:'+char(10)+N'                dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1])'+char(10)+N'            else:'+char(10)+N'                dp[i][w] = dp[i-1][w]'+char(10)+N'    '+char(10)+N'    return dp[n][W]'+char(10)+N''+char(10)+N'# Пример использования'+char(10)+N'weights = [1, 2, 3]'+char(10)+N'values = [10, 15, 40]'+char(10)+N'W = 5'+char(10)+N'print("Арзиши максималӣ (0/1 бастаи):", knapsack(weights, values, W))')

,(27, 1, N'def min_path_sum(grid):'+char(10)+N'    if not grid or not grid[0]:'+char(10)+N'        return 0'+char(10)+N''+char(10)+N'    m, n = len(grid), len(grid[0])'+char(10)+N'    dp = [[0] * n for _ in range(m)]'+char(10)+N''+char(10)+N'    # Оғози кор'+char(10)+N'    dp[0][0] = grid[0][0]'+char(10)+N''+char(10)+N'    # Оғози сутуни аввал'+char(10)+N'    for i in range(1, m):'+char(10)+N'        dp[i][0] = dp[i-1][0] + grid[i][0]'+char(10)+N''+char(10)+N'    # Оғози сатри аввал'+char(10)+N'    for j in range(1, n):'+char(10)+N'        dp[0][j] = dp[0][j-1] + grid[0][j]'+char(10)+N''+char(10)+N'    # Пур кардани массив dp'+char(10)+N'    for i in range(1, m):'+char(10)+N'        for j in range(1, n):'+char(10)+N'            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])'+char(10)+N''+char(10)+N'    return dp[m-1][n-1]'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'grid = ['+char(10)+N'    [1, 3, 1],'+char(10)+N'    [1, 5, 1],'+char(10)+N'    [4, 2, 1]'+char(10)+N']'+char(10)+N'print("Арзиши ҳадди ақали роҳ:", min_path_sum(grid))')

--,(28, 1, N'')

--,(26, 1, N'')

GO


INSERT INTO Users([Name], IsAdmin, [Login], PasswordHash)
VALUES(N'Azimjon', 0, N'anematov2002@gmail.com', N'123')
,(N'Акмалхон Бурхонов', 0, N'b@gmail.com', N'123')
,(N'Шаҳзод', 0, N'shahanshohov01@gmail.com', N'123')
,(N'admin', 1, N'admin', N'admin')

--,(N'', 0, '', '')





GO 



SELECT COUNT(*) AS 'Alg count' FROM Topics WHERE HasChildren = 0