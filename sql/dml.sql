/*Algorithms
Алгоритм поиска
- Линейный поиск
- Бинарный поиск

Алгоритм сортировки
- сортировка пузырьком
- сортировка выбором
- быстрая сортировка

Алгоритмы для работы с графами
- BFS (breadth first search)
- DFS (depth first search)
- алгоритм Дейкстры

Два указателя

Жадные алгоритмы
- Алгоритм Хаффмана
- Алгоритм Краскала

Быстрое возведение в степень C#
- Рекурсивная реализация быстрого возведения в степень
- Итерационная реализация быстрого возведения в степень
*/


INSERT INTO Topics([Name], HasChildren, ParentId, [Order])
VALUES(N'Алгоритмҳои ҷустуҷӯ', 1, NULL, 1)
	 ,(N'Алгоритмҳои ҷудокунӣ', 1, NULL, 2)
	 ,(N'Алгоритҳо барои кор бо графҳо', 1, NULL, 3)
	 ,(N'Ду нишондод', 0, NULL, 7)
	 ,(N'Алгоритмҳои хасис', 1, NULL, 5)
	 ,(N'Экспонентатсияи зуд', 1, NULL, 6)

GO

INSERT INTO Topics([Name], HasChildren, ParentId, [Order])
VALUES(N'Ҷустуҷӯи хатӣ', 0, 1, 1) --7
	 ,(N'Ҷустуҷӯи дуӣ', 0, 1, 2) --8
	 ,(N'Ҷудокунии ҳубобӣ', 0, 2, 1) --9
	 ,(N'Ҷудокунӣ аз рӯи интихоб', 0, 2, 2) --10
	 ,(N'Ҷудокунии зуд', 0, 2, 3)
	 ,(N'BFS (breadth first search)', 0, 3, 1) --12
	 ,(N'DFS (depth first search)', 0, 3, 2)
	 ,(N'Алгоритми Дейкстр', 0, 3, 3) --14
	 ,(N'Алгоритми Хаффман', 0, 5, 1)
	 ,(N'Алгоритми Краскал', 0, 5, 2) --16
	 ,(N'Алгоритми Евклид', 0, NULL, 5) --17
	 ,(N'Татбиқи рекурсивии экспонентатсияи зуд', 0, 6, 1)
	 ,(N'Татбиқи такрории экспонентатсияи зуд', 0, 6, 2) --19
	 ,(N'Манораи ханой', 0, NULL, 8) --20
	 ,(N'Барномасозии динамикӣ', 1, NULL, 9) --21
	 ,(N'Ҷойгиркунии n-маликаҳо дар тахтаи шоҳмот', 0, 21, 2) --22
	 ,(N'Рақамҳои ибтидоӣ', 0, NULL, 10) --23
	 ,(N'Алгоритмҳои тасодуфӣ', 0, 21, 3) --24
	 ,(N'Мушкилоти ҷузвдон', 0, 21, 4) --25
	 ,(N'Масофа дар шабака', 0, 21, 5) --26

GO

INSERT INTO Content(TopicId, ContentTypeId, [Data], Params, [Order])
VALUES(7, 2, N'Ҷустуҷӯи хатӣ яке аз соддатарин ва маъмултарин алгоритмҳои ҷустуҷӯи унсур дар массив мебошад. Он ҳар як унсури массивро аз аввал то пайдо шудани унсури дилхоҳ е то дидани ҳамаи унсурҳо такроран месанҷад.', NULL, 1)
	 ,(7, 4, N'https://sushrutkuchik.wordpress.com/wp-content/uploads/2020/05/linear_search.gif', NULL, 2)
	 ,(7, 2, N'Принсипи кори алгоритм хеле содда аст. Бо гузаштан аз унсурҳои массив як ба як, он ҳар як унсурро бо арзиши мақсаднок муқоиса мекунад. Агар элемент бо арзиши мақсаднок мувофиқат кунад, алгоритм индекси ин элементро бармегардонад. Агар унсур бо арзиши мақсаднок мувофиқат накунад, алгоритм ба интихоби унсурҳои зерин идома медиҳад. Агар унсури мақсаднок дар массив пайдо нашавад, алгоритм арзиши махсусеро, ки набудани онро нишон медиҳад, бармегардонад.', NULL, 3)
	 ,(7, 2, N'Намунаи код:', NULL, 4)

GO

INSERT INTO CodeLists(asd) VALUES(NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL)
,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL)
,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL) ,(NULL);
SELECT * FROM CodeLists;

GO

SELECT * FROM ProgramingLanguages

GO

INSERT INTO Content(TopicId, ContentTypeId, [Data], Params, [Order], CodeListId)
VALUES(7, 6, N'', NULL, 6, 1)
	 ,(7, 2, N'Дар ин рамз функсияи `linear_search` массиви `arr` ва унсури мақсадноки `target` - ро қабул мекунад, сипас ҳар як унсури массивро интихоб мекунад ва онро бо арзиши мақсаднок муқоиса мекунад. Агар элемент бо арзиши мақсаднок мувофиқат кунад, функсия индекси онро бармегардонад. Дар акси ҳол, -1 бармегардад, ки нишон медиҳад, ки унсур ёфт нашудааст.', NULL,7, NULL)
	 ,(7, 2, N'Ҷустуҷӯи хатӣ як алгоритми оддӣ ва содда аст, аммо он метавонад барои массивҳои калон аз сабаби мураккабии вақти хаттии он бесамар бошад. Аммо, он метавонад ҳангоми ҷустуҷӯи унсурҳо дар маҷмӯаҳои хурди маълумот ё вақте ки алгоритмҳои дигар мувофиқ нестанд, муфид бошад.', NULL, 8, NULL)
	 
	 ,(15, 2, N'Алгоритми Хаффман (Huffman Algorithm) алгоритми тамаъҷӯест, ки барои сохтани рамзи префиксии оптималӣ истифода мешавад, ки аксар вақт дар фишурдани маълумот истифода мешавад. Биеед бифаҳмем, ки ин алгоритм чӣ гуна кор мекунад.', NULL, 1, NULL)
	 ,(15, 3, N'Қадамҳои асосии алгоритми Хаффман', NULL, 2, NULL)
	 ,(15, 2, N'1. Ҳисоб кардани басомади аломатҳо:', NULL, 3, NULL)
	 ,(15, 5, N'Пеш аз ҳама, басомади пайдоиши ҳар як аломат дар паем (е файл) муайян карда мешавад, ки барои он рамзи фишурда сохта мешавад.', NULL, 4, NULL)
	 ,(15, 2, N'2. Сохтани дарахти Хаффман:', NULL, 5, NULL)
	 ,(15, 5, N'Дарахти бинарӣ сохта мешавад, ки дар он ҳар як барг рамз аст ва гиреҳҳои дохилӣ ҷамъи басомади наслҳои худ мебошанд;'+char(10)+N'Дар ҳар қадам алгоритм ду гиреҳро бо басомади камтарин муттаҳид мекунад ва гиреҳи навро бо басомади умумӣ эҷод мекунад.', NULL, 6, NULL)
	 ,(15, 2, N'3. Таъини рамзҳо:', NULL, 7, NULL)
	 ,(15, 5, N'Рамзи префиксӣ (пайдарпаии битӣ) барои ҳар як рамз аз рӯи дарахт аз реша ба баргҳо сохта мешавад. Дар зери дарахти чап "0" ва дар тарафи рост "1" нишон дода шудааст;'+char(10)+N'Ба шарофати усули чашмгуруснагии сохтани дарахт, рамзҳои дарозии тағйиребанда аксар вақт истифода мешаванд. Аксар вақт рамзҳои кӯтоҳтар ба рамзҳои бештар таъин карда мешаванд.', NULL, 8, NULL)
	 ,(15, 2, N'4. Фишурдани маълумот:', NULL, 9, NULL)
	 ,(15, 5, N'Паем (е файл) бо версияи фишурда иваз карда мешавад, ки дар он ҳар як рамз бо рамзи префиксии мувофиқ иваз карда мешавад;'+char(10)+N'Ин ба шумо имкон медиҳад, ки маълумотро бо истифода аз битҳои камтар пешниҳод кунед, агар рамзҳои зуд-зуд рамзҳои кӯтоҳтар дошта бошанд.', NULL, 10, NULL)
	 ,(15, 6, N'', NULL, 11, 3)
	 ,(15, 2, N'Алгоритми Хаффман имкон медиҳад, ки маълумотро дар асоси басомади рамзҳо дар паем самаранок фишурда шавад. Он воситаи калидӣ дар фишурдани маълумот мебошад ва дар технологияҳои фишурдани файл, бойгонӣ, протоколҳои шабакавӣ ва дигар соҳаҳо васеъ истифода мешавад.', NULL, 12, NULL)
	 
	 ,(8, 2, N'Ҷустуҷӯи дуӣ алгоритми самараноки ҷустуҷӯи унсур дар массиви мураттабшуда мебошад. Он тавассути тақсим кардани массив ва муқоисаи унсури дилхоҳ бо унсури мобайни массив кор мекунад. Агар унсури ҷустуҷӯшаванда ба унсури миёнаи массив баробар бошад, ҷустуҷӯ ба анҷом мерасад. Агар унсури ҷустуҷӯшаванда аз унсури миёнаи массив хурдтар бошад, ҷустуҷӯ дар нимаи чапи массив идома меёбад. Агар унсури ҷустуҷӯшаванда аз унсури миёнаи массив калонтар бошад, ҷустуҷӯ дар нимаи рости массив идома меёбад. Ин раванд то пайдо шудани унсури ҷустуҷӯшуда ё то дар массив боқӣ мондани як унсур такрор мешавад.', NULL, 1, NULL)
	 ,(8, 4, N'https://media.proglib.io/posts/2022/11/21/1cf3b4ed69a54149b52f817571bd3d81.gif', NULL, 2, NULL)
	 ,(8, 2, N'Принсипи кори алгоритм чунин аст: дар ҳар як итерасия ҷустуҷӯи дуӣ андозаи диапазони ҷустуҷӯро ду баробар кам мекунад. Ин ба шумо имкон медиҳад, ки ҷустуҷӯро ба як адад кам мекунад.', NULL, 3, NULL)
	 ,(8, 2, N'Намуна код:', NULL, 4, NULL)
	 ,(8, 6, N'', NULL, 5, 4)
	 
	 ,(9, 2, N'Ҷобаҷогузории ҳубобӣ яке аз алгоритмҳои машҳури ҷобаҷогузорӣ мебошад. Дар ин ҷо шумо бояд арзишҳои унсурҳои ҳамсояро пай дар пай муқоиса кунед ва рақамҳоро бо ҷойҳо иваз кунед, агар пештара аз охирин калонтар бошад. Ҳамин тариқ, унсурҳои дорои арзишҳои калон дар охири рӯйхат ва бо арзишҳои хурдтар дар аввал боқӣ мемонанд.', NULL, 1, NULL)
	 ,(9, 4, N'https://yastatic.net/s3/education-portal/media/1_49e0bb0f63_63adb81133.gif', NULL, 2, NULL)
	 ,(9, 2, N'Ин алгоритм омӯзишӣ ҳисобида мешавад ва аз сабаби самаранокии паст қариб дар амал татбиқ карда намешавад: он оҳиста дар санҷишҳое кор мекунад, ки дар онҳо унсурҳои хурд (онҳоро черепахами меноманд) дар охири массив истодаанд. Аммо, бисер усулҳои дигар ба он асос ефтаанд, ба монанди ҷобаҷогузории ларзиш ва ҷобаҷогузории шона.', NULL, 3, NULL)
	 ,(9, 6, N'', NULL, 4, 5)
	 ,(9, 7, N'Бояд қайд кард, ки мураккабии муваққатии ин алгоритми O(n^2).', NULL, 5, NULL)
	 
	 ,(10, 2, N'Аввалан, шумо бояд зергурӯҳи массивро баррасӣ кунед ва дар он ҳадди аксар (е ҳадди аққал) пайдо кунед. Сипас арзиши интихобшуда бо арзиши унсури якуми ҷудонашуда иваз карда мешавад. Ин қадам бояд то ба охир расидани зермассивҳои ҷудонашуда дар массив такрор карда шавад.', NULL, 1, NULL)
	 ,(10, 4, N'https://yastatic.net/s3/education-portal/media/184_9_b67b9a57f4_deb9de7372.gif', NULL, 2, NULL)
	 ,(10, 6, N'', NULL, 3, 6)
	 ,(10, 7, N'мураккабии муваққатии ин алгоритми O(n^2).', NULL, 4, NULL)
	 
	 ,(11, 2, N'Ин алгоритм аз се марҳила иборат аст. Аввалан, шумо бояд як унсурро аз массив интихоб кунед-онро одатан дастгирӣ меноманд. Сипас унсурҳои дигари массивро тавре тақсим мекунанд, ки унсурҳои камтар аз унсурҳои такягоҳ пеш аз он ва калон е баробар пас аз он бошанд. Ва минбаъд ду қадами аввалро ба зермассивҳои рост ва чапи арзиши такягоҳ рекурсивӣ истифода мебаранд.', NULL, 1, NULL)
	 ,(11, 4, N'https://yastatic.net/s3/education-portal/media/184_11_3c7583c6cd_59878a71a8.gif', NULL, 2, NULL)
	 ,(11, 2, N'Ҷамъбасти зудро соли 1960 барои тарҷумаи мошинӣ ихтироъ карданд: он вақт луғатҳо дар лентаҳои магнитӣ нигоҳ дошта мешуданд ва ҷамъбасти калимаҳои матни коркардшуда имкон медод, ки тарҷумаҳоро дар як пешбурди лента бидуни бозгашт ба даст оранд.', NULL, 3, NULL)
	 ,(11, 6, N'', NULL, 4, 7)
	 ,(11, 7, N'мураккабии муваққатии ин алгоритми O(n^2).', NULL, 5, NULL)

	 ,(12, 2, N'BFS, ё Breadth First Search алгоритми канори граф дар паҳнои. Граф ин сохтори "қуллаҳо" ва "канорҳо" мебошад, ки қуллаҳоро бо ҳам мепайвандад. Дар канори он аз як қулла ба қуллаи дигар ҳаракат кардан мумкин аст ВА BFS ин корро сатҳӣ мекунад: аввал аз тамоми қуллаҳои наздиктарин аз нуқтаи ибтидоӣ мегузарад, сипас чуқуртар поен меравад.', NULL, 1, NULL)
	 ,(12, 2, N'Чунин ба назар мерасад: алгоритм дар қуллаи пешакӣ интихобшуда оғоз меебад ва аввал "ташриф меорад" ва ҳамаи ҳамсояҳои ин қулларо қайд мекунад. Сипас он ба ҳамсояҳои қуллаҳои ташриф овардашуда мегузарад, сипас минбаъд бо ҳамон принсип. Аз сабаби хусусияти паҳншавии ба мавҷ монанд, алгоритмро мавҷӣ низ меноманд. BFS яке аз ду алгоритми маъмули гузариш аст. Дуюм DFS ном дорад ва ба чуқурӣ гузаштанро дар назар дорад: аввал алгоритм аз канори граф ба чуқурӣ мегузарад.', NULL, 2, NULL)
	 ,(12, 3, N'BFS барои чӣ лозим', NULL, 3, NULL)
	 ,(12, 5, N'Барои ҳалли масъалаҳои ҷустуҷӯи роҳи оптималӣ. Вазифаи классикӣ ҷустуҷӯи автоматикунонидашудаи баромадан аз лабиринт ҳисобида мешавад.'+char(10)+N'Барои ҳалли масъалаҳои бевосита бо назарияи графҳо алоқаманд, масалан барои ҷустуҷӯи ҷузъи пайвастшавӣ. Ин масъалаҳо дар навбати Худ дар илми Маълумот, назарияи шабакаҳо ва электроника ҳал карда мешаванд.'+char(10)+N'Барои масъалаҳои зеҳни сунъӣ, ки бо ҷустуҷӯи ҳалли камтарин ҳаракатҳо алоқаманданд. Дар ин ҳолат ҳолати "мошини оқил" ҳамчун қуллаҳо ва гузаришҳо байни онҳо ҳамчун канораҳо ифода карда мешаванд.'+char(10)+N'Барои оптимизатсияи хотира ҳангоми гузаштан аз граф дар баъзе ҳолатҳо, масалан барои баъзе сохторҳои мушаххас.'+char(10)+N'Барои кор бо иттилоот дар сохторҳои муайяни маълумот, ба монанди дарахтон. Онҳоро низ бо алгоритми BFS убур кардан мумкин аст, зеро онҳо зергурӯҳи графҳо мебошанд.', NULL, 4, NULL)
	 ,(12, 1, N'Хусусиятҳои BFS', NULL, 5, NULL)
	 ,(12, 5, N'Шумораи доимии амалҳо барои ҳар як канор е қулла. Ин ҳангоми ҳисоб кардани мураккабии алгоритм ҳангоми интихоби усули оптималии ҳалли ин е он масъала муҳим аст.'+char(10)+N'Набудани мушкилоти "сикли беохир": алгоритм бо сабаби хусусиятҳои корӣ дар ягон шароит ба он дохил намешавад.'+char(10)+N'Дақиқии баланд ва меъмории боэътимод, ки ба шумо имкон медиҳад, ки ба ин алгоритм барои ҳалли масъалаҳои гуногун такя кунед.'+char(10)+N'Қобилияти кор кардан бо графҳои нигаронидашуда ва ғайримутамарказ. Дар бораи он, ки онҳо аз ҳам фарқ мекунанд, дар мақола дар бораи графикаи нигаронидашуда хондан мумкин аст.'+char(10)+N'Пуррагии алгоритм он ҳалли худро меебад, яъне роҳи кӯтоҳтаринро пайдо мекунад ва дар ҳар графаи ниҳоӣ ба анҷом мерасад. Агар граф беохир бошад, ҳалли он танҳо дар сурате пайдо мешавад, ки агар ягон роҳи он ниҳоӣ бошад.'+char(10)+N'Имконияти пайдо кардани роҳи кӯтоҳтарин дар граф, агар ҳамаи канораҳо дарозии якхела дошта бошанд. Агар дарозии қабурғаҳо гуногун бошанд, BFS роҳи камтарини қабурғаҳоро пайдо мекунад, аммо он ҳатман кӯтоҳтарин нахоҳад буд. Барои ҷустуҷӯи роҳи кӯтоҳтарин дар ин ҳолат алгоритми Дейкстра беҳтар хоҳад буд.', NULL, 6, NULL)
	 ,(12, 3, N'Алгоритми BFS чӣ гуна кор мекунад', NULL, 7, NULL)
	 ,(12, 2, N'Алгоритм оддӣ ва беихтиерона аст. Он аз болои қуллаҳои граф мегузарад, то он даме ки қуллаҳои ташриф наоварда боқӣ монанд ва роҳи кӯтоҳтаринро то қуллаи мақсаднок ҳисоб мекунад. Барои ба таври равшантар нишон додани кори он, алгоритмро зина ба зина муаррифӣ мекунем.', NULL, 8, NULL)
	 ,(12, 2, N'Оғози кор. Шумо метавонед ҳар як қулларо ҳамчун қуллаи ибтидоӣ интихоб кунед. Дар лаҳзаи оғози кори алгоритм, ҳамаи қуллаҳо ҳамчун ташриф наоварда қайд карда шудаанд онҳоро сафед меноманд. Аввалин чизе, ки алгоритм мекунад, ин аст, ки қуллаи ибтидоиро ҳамчун ташриф овардашуда қайд мекунад (инчунин истилоҳоти кушода е хокистарӣ истифода мешаванд). Агар он мақсаднок бошад, ин алгоритмро ба анҷом мерасонад. Аммо аксар вақт ин тавр нест.', NULL, 9, NULL)
	 ,(12, 2, N'Ҷустуҷӯи ҳамсояҳо. Алгоритм месанҷад, ки кадом ҳамсояҳо дар қуллаи ибтидоӣ ҳастанд. Онҳо ба "навбати амалҳо" бо тартиби алгоритме, ки онҳоро пайдо кардааст, илова карда мешаванд ва инчунин ҳамчун "сабз"қайд карда мешаванд. Ин то он даме идома меебад, ки дар қуллаи ибтидоӣ ҳамсояҳои "сафед" боқӣ монанд.', NULL, 10, NULL)
	 ,(12, 2, N'Гузариш ба қуллаи навбатӣ. Вақте ки алгоритм аз тамоми ҳамсояҳои қуллаи ибтидоӣ мегузарад, он онро пурра аз байн мебарад. Чунин қуллаҳоро "сиеҳ" низ меноманд: алгоритм ба онҳо барнамегардад. Сипас он ба яке аз қуллаҳои "хокистарӣ" — и ҳамсояҳои ибтидоӣ мегузарад. Алгоритм қуллаи аввалро дар навбат интихоб мекунад. Сипас амалҳо такрор мешаванд:" ҳамсояҳо "- и қулла, ба ғайр аз" сиеҳ", ба навбат ворид карда мешаванд.', NULL, 12, NULL)
	 ,(12, 2, N'Вақте ки ин қулла низ аз он мегузарад, гузариш бо ҳамон принсип такрор мешавад — қуллаи аввал дар навбат. Дар ин ҳолат, он ҳамсояи дуюми қуллаи ибтидоӣ хоҳад буд-мо дар хотир дорем, ки онҳо аввал ба навбат илова карда шуданд. Ва танҳо вақте ки ҳамсояҳои қуллаи ибтидоӣ дар навбат ба охир мерасанд, алгоритм аз рӯи "сатҳи" қуллаҳои навбатӣ мегузарад. Ҳамин тавр, ба паҳноии он роҳ дода мешавад.', NULL, 13, NULL)
	 ,(12, 2, N'Охири алгоритм. Агар навбат холӣ бошад, ин маънои онро дорад, ки қуллаҳои "сафед" ва "сафед" дигар боқӣ намондаанд. Алгоритм ба охир мерасад. Агар дар ин ҳолат қуллаи мақсаднок ба даст наояд, ин маънои онро дорад, ки ба он аз нуқтаи ибтидоӣ дастрасӣ вуҷуд надорад.', NULL, 14, NULL)
	 ,(12, 2, N'Агар қуллаи мақсаднок пеш аз он ки алгоритм аз тамоми граф гузарад, ба даст оварда шавад, ин метавонад маънои онро дошта бошад, ки он ба анҷом мерасад. Алгоритм қатъ мешавад, зеро вазифа иҷро мешавад: роҳи кӯтоҳтарин ба болои ҳадаф пайдо мешавад.', NULL, 15, NULL)
	 ,(12, 6, N'', NULL, 16, 8)


	 
	 ,(17, 1, N'Алгоритми Евклид: дарефти бузургтарин тақсимкунандаи умумӣ', NULL, 1, NULL)
	 ,(17, 2, N'Алгоритми Эвклид яке аз алгоритмҳои қадимтарин ва самараноктарин барои ёфтани калонтарин тақсимкунандаи умумии (КТУ) ду рақам мебошад. Дар тӯли асрҳо он яке аз воситаҳои асосии математикӣ боқӣ мемонад ва дар бисёр соҳаҳо, аз ҷумла алгебра, криптография, информатика ва ғайра истифода мешавад.', NULL, 2, NULL)
	 ,(17, 2, N'Алгоритм ба номи математики юнони қадим Эвклид номгузорӣ шудааст, ки онро дар рисолаи худ "Оғоз" тасвир кардааст, ки тақрибан соли 300 то милод навишта шудааст. соддагӣ ва самаранокии он онро махсусан барои истифода дар вазифаҳои гуногун ҷолиб месозад.', NULL, 3, NULL)
	 ,(17, 2, N'Принсипи кори алгоритми Эвклид ба идеяи оддӣ асос ёфтааст: агар a аз b калонтар бошад, пас КТУ a ва b ба КТУ b ва a mod b баробар аст, ки дар он mod амалиети гирифтани боқимондаи тақсимотро ифода мекунад. Ин раванд такрор мешавад, то яке аз рақамҳо ба 0 баробар шавад. Вақте ки яке аз ададҳо ба 0 баробар мешавад, адади боқимонда бузургтарин тақсимкунандаи умумии ададҳои ибтидоӣ хоҳад буд.', NULL, 4, NULL)
	 ,(17, 2, N'Намунаи код барои татбиқи алгоритми Эвклид:', NULL, 5, NULL)
	 ,(17, 6, N'', NULL, 6, 2)
	 ,(17, 2, N'Дар ин мисол, функсияи `euclidean_algorithm` ду рақами `a` ва` b` - ро ба вуруд қабул мекунад ва алгоритми Эвклидро барои ефтани тақсимкунандаи умумии калонтарини Онҳо истифода мебарад. То он даме, ки рақами дуюм ба 0 баробар шавад, он бо боқимондаи тақсимоти рақами аввал ба рақами дуюм иваз карда мешавад. Ин раванд то он даме идома меебад, ки яке аз рақамҳо ба 0 баробар шавад ва адади боқимонда бузургтарин тақсимкунандаи умумӣ бошад.', NULL, 7, NULL)
	 ,(17, 2, N'Алгоритми Эвклид яке аз усулҳои самаранок ва универсалии ефтани тақсимкунандаи умумии калонтарин мебошад ва қисми ҷудонопазири арсенали математикӣ боқӣ мемонад.', NULL, 8, NULL)

	 
	 ,(20, 1, N'Манораи ханой: Машқ ва якчанд роҳҳои татбиқ', NULL, 1, NULL)
	 ,(20, 2, N'Бурҷи ханой як мушкили классикӣ аст, ки аксар вақт барои таълим ва нишон додани принсипҳои рекурсия истифода мешавад. Вазифа аз он иборат аст, ки стеки дискҳои диаметри гуногунро аз як асо ба асои дигар бо истифода аз асои сеюм ҳамчун мобайнӣ интиқол диҳед, ба шарте ки дар ҳар як қадам танҳо як дискро интиқол додан мумкин бошад ва диски калонтар ҳеҷ гоҳ дар болои диски хурдтар ҷойгир карда нашавад.', NULL, 2, NULL)
	 ,(20, 2, N'Принсипи кори вазифаи бурҷи Ханой ба қадри кофӣ содда аст: барои интиқол додани стеки дискҳо аз як асо ба асои дигар, мо аввал дискҳои болоии `n-1`-ро ба асои мобайнӣ интиқол медиҳем, сипас диски калонтаринро ба асои ҳадаф интиқол медиҳем ва дар ниҳоят дискҳои `n-1` - ро аз асои мобайнӣ ба асои ҳадаф интиқол медиҳем. Ин раванд барои ҳар як пойгоҳи диск рекурсивӣ такрор карда мешавад, то он даме ки ҳамаи дискҳо ба асои ҳадаф интиқол дода шаванд.', NULL, 3, NULL)
	 ,(20, 3, N'Усули 1: ҳалли рекурсивӣ', NULL, 4, NULL)
	 ,(20, 2, N'Намунаи рамзи барои ҳалли рекурсивии масъалаи Манораи Ханой:', NULL, 5, NULL)
	 ,(20, 6, N'', NULL, 6, 9)
	 ,(20, 3, N'Усули 2: ҳалли такрорӣ', NULL, 7, NULL)
	 ,(20, 2, N'Намунаи рамзи барои ҳалли такрории масъалаи манораи Ханой:', NULL, 8, NULL)
	 ,(20, 6, N'', NULL, 9, 10)
	 ,(20, 2, N'Ҳарду роҳи ҳалли масъалаи Манораи Ханой самаранок буда, принсипҳои рекурсия ва итерасияро нишон медиҳанд. Интихоби усул аз афзалиятҳо ва талаботи мушаххаси лоиҳаи шумо вобаста аст.', NULL, 10, NULL)
	 



	 ,(19, 1, N'Татбиқи такрории экспонентатсияи зуд', NULL, 1, NULL)
	 ,(19, 2, N'Экспонентатсияи зуд усулест, ки ба шумо имкон медиҳад, ки арзиши рақами ба дараҷа бардошташударо самаранок ҳисоб кунед. Баръакси усули рекурсивӣ, татбиқи итеративӣ ба даври итеративӣ асос ёфтааст, ки рақамро ба худ пай дар пай зарб мекунад, то он даме ки ба дараҷаи зарурӣ мерасад.', NULL, 1, NULL)
	 ,(19, 2, N'Принсипи кори татбиқи итеративии экспонентатсияи зуд оддӣ аст: мо бо натиҷаи баробар ба 1 оғоз мекунем ва сипас онро пай дар пай ба пойгоҳ зарб карда, нишондиҳандаи дараҷаро дар ҳар қадам дучанд мекунем. Ин ба мо имкон медиҳад, ки шумораи амалиетҳои барои ҳисоб кардани дараҷа заруриро кам кунем.', NULL, 2, NULL)
	 ,(19, 2, N'Намунаи код:', NULL, 3, NULL)
	 ,(19, 6, N'', NULL, 4, 11)
	 ,(19, 2, N'Дар ин рамз функсияи `power` асоси `base` ва нишондиҳандаи дараҷаи `exponent` - ро ба вуруд қабул мекунад, сипас натиҷаи ба дараҷа баровардани рақамро итеративӣ ҳисоб мекунад. То он даме, ки нишондиҳанда аз 0 зиед аст, мо месанҷем, ки он ҷуфт ё тоқ аст. Агар он баробар бошад, мо асосро ба худ зарб мекунем ва нишондиҳандаро ду баробар кам мекунем. Агар он тоқ бошад, натиҷаро ба пойгоҳ зарб кунед ва нишондиҳандаро ба 1 кам кунед. Ин раванд то ба 0 баробар шудани нишондиҳанда такрор мешавад.', NULL, 5, NULL)
	 ,(19, 2, N'Татбиқи итеративии экспонентатсияи зуд усули муассир ва ба осонӣ фаҳмо барои кор бо ҳисоб кардани дараҷа мебошад.', NULL, 6, NULL)


	 
	 ,(16, 2, N'Алгоритми Краскал (Kruskals Algorithm) ин алгоритми ефтани дарахти ҳадди ақали сутун дар графаи пайвастаи тарозу мебошад. Дарахти остии оптималӣ ин зерграфи графи ибтидоӣ мебошад, ки ҳамаи қуллаҳоро дар бар мегирад, ки аз рӯи вазни канори он ҳадди ақал аст.', NULL, 1, NULL)
	 ,(16, 1, N'Ин аст алгоритми Краскал чӣ гуна кор мекунад:', NULL, 2, NULL)
	 ,(16, 2, N'Қадамҳои асосии алгоритми Краскал:', NULL, 3, NULL)
	 ,(16, 2, N'1. Оғози кор:', NULL, 4, NULL)
	 ,(16, 5, N'Мо ҷангал месозем, ки дар он ҳар як қуллаи граф дарахти алоҳида аст.', NULL, 5, NULL)
	 ,(16, 2, N'2. Ҷобаҷогузории қабурғаҳо:', NULL, 6, NULL)
	 ,(16, 5, N'Канори граф аз рӯи афзоиши вазнҳо ҷудо карда мешавад.', NULL, 7, NULL)
	 ,(16, 2, N'3. Якҷоя кардани дарахтон:', NULL, 8, NULL)
	 ,(16, 5, N'Қабурғаҳои вазни ҳадди ақал пай дар пай интихоб карда мешаванд.'+char(10)+N'Агар илова кардани қабурға дар дарахти пояи ҷорӣ даврае ба вуҷуд наорад, он ба поя илова карда мешавад. Алгоритми ҷустуҷӯи амиқ е равиши дигарро барои санҷиши давра истифода бурдан мумкин аст.', NULL, 9, NULL)
	 ,(16, 2, N'4. Такрор:', NULL, 10, NULL)
	 ,(16, 5, N'Қадамҳои 3 такрор мешаванд, то ҳама қуллаҳо баста шаванд ва дарахти камтарин пурра бошад.', NULL, 12, NULL)
	 ,(16, 2, N'Алгоритми Краскал усули самараноки пайдо кардани дарахти ҳадди ақали сутун дар граф аст. Он дар соҳаҳои гуногун васеъ истифода мешавад, ки дар он ҷо бояд зергурӯҳи оптималии дарахтро бо арзиши ҳадди ақали умумӣ пайдо кард.', NULL, 13, 12)

	 
	 ,(13, 2, N'DFS, ё Depth First Search, ҷустуҷӯи чуқурӣ, ки ба шумо имкон медиҳад, ки хатсайрро аз нуқтаи A то нуқтаи B пайдо кунед.Дар графҳои сохторҳои махсус, ки аз нуқтаҳои қуллаҳо ва канори роҳҳо иборат Мебошанд, Истифода Мешавад. DFS дар ҷустуҷӯи хатсайри графикӣ ба чуқурӣ аст: дар ҳар қадам дуртар меравад.', NULL, 1, NULL)
	 ,(13, 2, N'Намунаи классикии истифодаи алгоритм ҷустуҷӯи роҳи тасодуфӣ дар лабиринт. DFS корро дар нуқтаи додашуда оғоз мекунад, дар ҳар қадам аз лабиринт то гардиши навбатӣ мегузарад ва самтро интихоб мекунад. Агар роҳ сарбаста бошад, алгоритм ба гардиши қаблӣ бармегардад ва самти навро меозмояд. Дар натиҷа, дер е зуд роҳи дуруст аст.', NULL, 2, NULL)
	 ,(13, 4, N'https://blog.skillfactory.ru/wp-content/uploads/2023/02/dfs_maze-8816737.gif', NULL, 3, NULL)
	 ,(13, 3, N'Принсипи гузариши граф ба чуқурӣ', NULL, 4, NULL)
	 ,(13, 2, N'Мо алгоритми рекурсивии стандартии гузаришро дида мебароем. Дар бораи татбиқи ғайримуқаррарӣ дар зер сӯҳбат хоҳем кард: якчанд ҳастанд ва ҳар яки онҳо хусусиятҳои худро доранд. Принсипи стандартиро фаҳмидан хеле осон аст ва татбиқи он осон аст.', NULL, 5, NULL)
	 ,(13, 4, N'https://blog.skillfactory.ru/wp-content/uploads/2023/02/dfs-1-8650838.png', NULL, 6, NULL)
	 ,(13, 2, N'Қадами аввал. Вақте ки алгоритм ба кор шурӯъ мекунад, ҳамаи қуллаҳо "сафед" ҳисобида мешаванд, ки ба он ташриф намеоранд. DFS роҳро дар қуллаи пешакӣ муайяншудаи v оғоз мекунад ва бояд аз он ба қуллаи дигари додашуда роҳ ебад е харитаи графро пурра тартиб диҳад.', NULL, 7, NULL)
	 ,(13, 2, N'Аввалин чизе, ки DFS мекунад, ранг кардани болои он аст, ки дар он хокистарӣ аст. Ин нишон медиҳад, ки алгоритм аллакай дар он буд. пас аз он DFS ҳамсоягонро месанҷад-қуллаҳое, ки ба он ҷое, ки он ҷойгир аст, пайвастанд.', NULL, 8, NULL)
	 ,(13, 2, N'Гузариш. Агар яке аз қуллаҳои ҳамсоя сафед бошад, алгоритм ба он мегузарад ва ҳамон амалҳоро такрор мекунад: ба хокистарӣ ранг мекунад, ҳамсояҳоро меҷӯяд. Ин на ба таври даврӣ, балки ба таври рекурсивӣ сурат мегирад: агар DFS-ро ҳамчун функсия муаррифӣ кунем, пас ин функсия дар рафти иҷро худашро ба вуҷуд меорад, аммо барои қуллаи дигар. Аз ин рӯ, алгоритм аввал бо як ҳамсояи интихобшуда кор мекунад ва танҳо дар сурати ба бунбаст афтодан, бармегардад ва кӯшиш мекунад, ки роҳи дигарро тай кунад.', NULL, 9, NULL)
	 ,(13, 2, N'Интихоби ҳамсоя тасодуфан е бо меъерҳои пешакӣ муайяншуда сурат мегирад-масалан, он метавонад қуллаи чаптарин е росттарин бошад. Дар боло мо "қоидаи дасти чап" - ро зикр кардем: он аслан чунин меъер аст.', NULL, 10, NULL)
	 ,(13, 2, N'Агар дар болои он ҳамсояҳои номаълум боқӣ намонанд, он ҳамчун пурра ташриф овардашуда сиеҳ ранг карда мешавад.', NULL, 11, NULL)
	 ,(13, 2, N'Анҷом додани гардиш. Алгоритм агар ба нуқтаи зарурӣ бирасад, ба анҷом мерасад. Дар ин ҳолат, ҳамаи "намунаҳои" функсияҳои даъватшуда ба таври навбатӣ ба анҷом мерасанд: аз охирин то аввалин даъватшуда. Агар вазифа пурра аз болои граф гузарад, пас меъери ба итмом расонидани графи дигар: ҳамаи қуллаҳо бояд сиеҳ шаванд.', NULL, 12, NULL)
	 ,(13, 3, N'Чӣ тавр амалӣ кардани алгоритми DFS', NULL, 13, NULL)
	 ,(13, 2, N'Соддатарин татбиқи рекурсивӣ сохтани граф дар шакли рӯйхати алоқаманд е сохтори дигари маълумот ва сипас навиштани функсия барои гузаштан аз он мебошад. Чӣ тавр амалӣ кардани худи граф аз забони барномасозӣ вобаста аст: одатан намудҳое истифода мешаванд, ки ба нигоҳ доштани арзишҳои гуногун имкон медиҳанд. Ҳар як унсури чунин навъи комплексӣ қулла аст ва дар дохили қулла истинодҳо ба унсурҳои дигар е рақамҳои онҳо нигоҳ дошта мешаванд ҳамин тавр роҳҳо амалӣ карда мешаванд.', NULL, 14, NULL)
	 ,(13, 2, N'Худи функсия, ки шартан DFS (v) номида мешавад, хеле оддӣ аст ва аз рӯи мантиқи зерин амал мекунад.', NULL, 15, NULL)
	 ,(13, 5, N'Ба даромадгоҳ қуллаи сафед v ворид мешавад.'+char(10)+N'Дар болои v ранги хокистарӣ дорад.'+char(10)+N'Қуллаи w, ки бо v ва сафед ҳамсоя аст, ҷустуҷӯ карда мешавад.'+char(10)+N'Аз дохили DFS (v) dfs (w) рекурсивӣ даъват карда мешавад.'+char(10)+N'Вақте ки функсия ба итмом мерасад, болои v сиеҳ ранг карда мешавад.', NULL, 16, NULL)
	 ,(13, 2, N'"Рангкунӣ" метавонад бо ерии ягон тағиребанда дар дохили қулла амалӣ карда шавад: масалан, арзиши 0 сафед, 1 хокистарӣ ва ғайра', NULL, 17, NULL)
	 ,(13, 6, N'', NULL, 18, 13)

	 
	 ,(18, 1, N'Татбиқи рекурсивии экспонентатсияи зуд', NULL, 1, NULL)
	 ,(18, 2, N'Экспонентатсияи зуд роҳи самараноки зуд ҳисоб кардани арзиши рақами ба дараҷа бардошташуда мебошад. Татбиқи рекурсивии ин алгоритм ба идеяи оддӣ асос ефтааст: агар мо хоҳем, ки рақами а-ро ба дараҷаи n гузорем, мо метавонем n-ро ба ду тақсим кунем ва а-ро ба дараҷаи n/2 ҳисоб кунем ва сипас натиҷаи бадастомадаро квадрат кунем. Ин раванд то расидан ба дараҷаи 1 такрор мешавад.', NULL, 2, NULL)
	 ,(18, 2, N'Намунаи код:', NULL, 3, NULL)
	 ,(18, 6, N'', NULL, 4, 14)
	 ,(18, 2, N'Дар ин код функсияи `power` асоси `base` ва нишондиҳандаи дараҷаи `exponent` - ро қабул мекунад, сипас натиҷаи ба дараҷа баровардани рақамро рекурсивӣ ҳисоб мекунад. Агар нишондиҳанда 0 бошад, функсия 1-ро бармегардонад. Агар нишондиҳанда ҷуфт бошад, функсия арзиши base^{exponent/2} - ро ҳисоб мекунад ва онро квадрат мекунад. Агар нишондиҳанда ночиз бошад, функсия арзиши base^{(exponent-1)/2} - ро ҳисоб мекунад ва онро ба асос зарб мекунад. Ин раванд то расидан ба ҳолати асосӣ, ки нишондиҳандаи дараҷа 0 аст, такрор мешавад.', NULL, 5, NULL)
	 ,(18, 2, N'Татбиқи рекурсивии экспонентатсияи зуд роҳи самараноки ҳисоб кардани дараҷа мебошад, алахусус ҳангоми кор бо нишондиҳандаҳои калон.', NULL, 6, NULL)
	 

	 
	 ,(4, 1, N'Усули ду нишондиҳанда: Таъриф ва намунаҳои истифода', NULL, 1, NULL)
	 ,(4, 2, N'Усули ду нишондиҳанда (two-pointer technique) як усули маъмули алгоритмӣ мебошад, ки барои ҳалли масъалаҳо дар массивҳо е сатрҳо истифода мешавад. Ин усул аз истифодаи ду индекс (нишондиҳандаҳо) иборат аст, ки дар массив е сатр бо суръати гуногун е дар самтҳои гуногун ҳаракат мекунанд. Усули ду нишондиҳанда имкон медиҳад, ки масъалаҳои марбут ба ҷустуҷӯи зермассивҳо, санҷиши палиндромҳо, пайдо кардани ҷуфтҳо бо суммаи додашуда ва дигар вазифаҳо самаранок ҳал карда шаванд, ки аксар вақт мураккабии муваққатии қарорҳоро беҳтар мекунанд.', NULL, 2, NULL)
	 ,(4, 2, N'Намунаҳои вазифаҳо ва қарорҳо бо истифода аз усули ду нишондиҳанда', NULL, 3, NULL)
	 ,(4, 2, N'Мисоли 1: санҷиши сатр барои палиндром', NULL, 4, NULL)
	 ,(4, 2, N'Палиндром сатрест, ки аз чап ба рост ва аз рост ба чап баробар хонда мешавад. Усули ду нишоннамо ба осонӣ тафтиш мекунад, ки сатр палиндром аст е не, бо ду нишоннамо, ки аз аввал ва охири сатр оғоз ефта, ба сӯи якдигар ҳаракат мекунанд', NULL, 5, NULL)
	 ,(4, 6, N'', NULL, 6, 15)
	 ,(4, 2, N'Мисоли 2: ёфтани ҷуфти рақамҳо бо суммаи додашуда', NULL, 7, NULL)
	 ,(4, 2, N'Ин масъала аз ефтани ду рақам дар массиви мураттабшуда иборат аст, ки суммаи онҳо ба рақами додашуда баробар аст. Усули ду нишондиҳанда имкон медиҳад, ки ин масъаларо дар вақти хаттӣ ҳал кунад.', NULL, 8, NULL)
	 ,(4, 6, N'', NULL, 9, 16)
	 ,(4, 2, N'Мисоли 3: Якҷоя кардани ду массиви мураттабшуда', NULL, 10, NULL)
	 ,(4, 2, N'Усули ду нишондиҳанда инчунин метавонад барои якҷоя кардани ду массиви мураттаб ба як массиви мураттаб истифода шавад.', NULL, 11, NULL)
	 ,(4, 6, N'', NULL, 12, 17)
	 ,(4, 3, N'Хулоса', NULL, 13, NULL)
	 ,(4, 2, N'Усули ду нишондиҳанда як усули пурқуввати алгоритмист, ки барои ҳалли масъалаҳои гуногун дар массивҳо ва сатрҳо истифода мешавад. Дар ин мақола, мо якчанд мисолҳоро дида баромадем, ки чӣ гуна ин усулро барои санҷиши сатр дар палиндром, ефтани ҷуфти рақамҳо бо суммаи додашуда ва якҷоя кардани ду массиви мураттаб истифода бурдан мумкин аст. Истифодаи усули ду нишондиҳанда аксар вақт имкон медиҳад, ки мураккабии муваққатии қарорҳо ба таври назаррас беҳтар ва самараноктар карда шавад.', NULL, 14, NULL)

	 
	 ,(14, 1, N'Алгоритми Дейкстра: Таъриф Ва намунаҳои истифода', NULL, 1, NULL)
	 ,(14, 2, N'Алгоритми Дейкстра алгоритми классикии графҳо мебошад, ки барои ефтани роҳҳои кӯтоҳтарин аз як қулла то ҳамаи қуллаҳои дигари граф бо вазни манфии канораҳо истифода мешавад. Ин алгоритмро Эдсгер Дейкстрой соли 1956 пешниҳод кард ва яке аз алгоритмҳои васеъ истифодашаванда дар назарияи графҳо ва барномаҳои шабакавӣ боқӣ мемонад.', NULL, 2, NULL)
	 ,(14, 3, N'Принсипи кори алгоритм', NULL, 3, NULL)
	 ,(14, 2, N'Алгоритми Дейкстра аз рӯи принсипи тамаъкорӣ кор мекунад, ки тадриҷан маҷмӯи роҳҳои кӯтоҳтаринро аз қуллаи ибтидоӣ ба қуллаҳои дигар месозад. Дар ҳар қадам алгоритм қулларо бо арзиши камтарини маълум интихоб мекунад, арзиши роҳҳоро ба ҳамсоягони худ нав мекунад ва равандро то пайдо шудани роҳҳои кӯтоҳтарин ба ҳамаи қуллаҳо такрор мекунад.', NULL, 4, NULL)
	 ,(14, 2, N'Қадамҳои алгоритми Дейкстра', NULL, 5, NULL)
	 ,(14, 2, N'1. Оғози кор:', NULL, 6, NULL)
	 ,(14, 5, N'Қуллаи ибтидоӣ дода мешавад, ки масофаи он 0 аст.'+char(10)+N'Масофа то ҳамаи қуллаҳои дигар ба беохирӣ муқаррар карда мешавад.'+char(10)+N'Бисер қуллаҳои ташрифоварда сохта мешаванд, ки дар аввал холӣ буданд.', NULL, 7, NULL)
	 ,(14, 2, N'2. Давраи асосӣ:', NULL, 8, NULL)
	 ,(14, 5, N'Қуллаи бе ташриф бо масофаи камтарини ҷорӣ интихоб карда мешавад.'+char(10)+N'Масофаҳо ба ҳамсоягонаш нав карда мешаванд, агар роҳро тавассути қуллаи кунунӣ беҳтар кардан мумкин бошад.'+char(10)+N'Қуллаи ҷорӣ ба шумораи зиеди меҳмонон илова карда мешавад.', NULL, 9, NULL)
	 ,(14, 2, N'3. Анҷом:', NULL, 10, NULL)
	 ,(14, 5, N'Алгоритм вақте ба анҷом мерасад, ки ҳамаи қуллаҳо ба он ҷо ташриф овардаанд е вақте ки ҳамаи қуллаҳои боқимондаи ба он ҷо нарафта дастрас нестанд (масофаи беохир доранд).', NULL, 11, NULL)
	 ,(14, 2, N'Татбиқи алгоритми Дейкстра', NULL, 12, NULL)
	 ,(14, 6, N'', NULL, 13, 18)
	 ,(14, 3, N'Истифодаи алгоритми Дейкстра', NULL, 14, NULL)
	 ,(14, 2, N'Алгоритми Дейкстра дар соҳаҳои гуногун васеъ истифода мешавад, аз ҷумла:', NULL, 15, NULL)
	 ,(14, 5, N'Роутерҳои шабакавӣ: Муайян кардани роҳҳои кӯтоҳтарин барои интиқоли маълумот тавассути шабака;'+char(10)+N'Системаҳои навигатсионӣ: сохтани хатсайрҳо дар харитаҳо ва GPS;'+char(10)+N'Системаҳои нақлиетӣ: Оптимизатсияи хатсайрҳо барои нақлиети ҷамъиятӣ ва логистика;'+char(10)+N'Барномаҳои бозӣ: дарефти роҳҳо барои аломатҳо ва объектҳо дар бозиҳо.', NULL, 16, NULL)
	 ,(14, 3, N'Хулоса', NULL, 17, NULL)
	 ,(14, 2, N'Алгоритми Дейкстра воситаи пурқувват ва самаранок барои ефтани роҳҳои кӯтоҳтарин дар графҳо мебошад. Он дар соҳаҳои гуногун, аз алоқаи шабакавӣ то бозиҳо то системаҳои навигатсионӣ васеъ истифода мешавад. Бо истифода аз алгоритми Дейкстра, шумо метавонед вазифаҳои мураккаби оптимизатсия ва ҷустуҷӯи роҳҳоро ҳал кунед, дар ҳоле ки иҷрои баланд ва дақиқии қарорҳоро таъмин кунед.', NULL, 18, NULL)

	 
	 ,(22, 1, N'Ҷойгиркунии n-маликаҳо дар тахтаи шоҳмот: мушкилот ва усулҳои ҳалли', NULL, 1, NULL)
	 ,(22, 2, N'Масъалаи Ҷойгиркунии n-ферзҳо дар тахтаи шоҳмот яке аз масъалаҳои классикии оптимизатсияи комбинаторӣ мебошад. Ин масъала талаб Мекунад, ки N ферз дар тахтаи Андозаи N×N ҷойгир карда шавад, то ки ҳеҷ кадоме аз онҳо зери ҳамлаи ферзи дигар набошад. Ферз метавонад ба ҳар як фигураи дар ҳамон уфуқ, амудӣ е диагоналӣ ҷойгиршуда ҳамла кунад.', NULL, 2, NULL)
	 ,(22, 2, N'Муқаррар кардани вазифа', NULL, 3, NULL)
	 ,(22, 2, N'Бигзор тахтаи шоҳмот Бо Андозаи N×N дода Шавад. Вазифа аз ин иборат Аст:', NULL, 4, NULL)
	 ,(22, 5, N'N маликаро дар тахта тавре ҷойгир кунед, ки ҳеҷ яке аз онҳо зери ҳамлаи дигаре набошад.'+char(10)+N'Ҳар як сатр ва ҳар як сутун бояд маҳз як малика дошта бошад.', NULL, 5, NULL)
	 ,(22, 2, N'Усулҳои ҳалли:', NULL, 6, NULL)
	 ,(22, 2, N'Якчанд усулҳои ҳалли масъалаи Ҷойгиркунии n-ферзҳо мавҷуданд, аз ҷумла алгоритмҳои рекурсивӣ, усулҳои ҷустуҷӯи бозгашт ва равишҳои эвристикӣ. Дар зер ду усули маъмулро дида мебароем: алгоритми рекурсивӣ ва усули "алгоритми Генетикӣ".', NULL, 7, NULL)
	 ,(22, 3, N'1. Алгоритми рекурсивӣ', NULL, 8, NULL)
	 ,(22, 2, N'Яке аз роҳҳои маъруф ва осонтарини ҳалли масъалаи ҷойгиркунии n-ферзҳо алгоритми рекурсивии баргардонидашуда мебошад. Ин усул кӯшиши ҷойгир кардани ҳар як малика дар навбати аввал аз қатори аввал иборат аст. Дар ин ҳолат барои ҳар як қатор санҷида мешавад, ки ое ферз дар хатари ҳамлаи ферзи дигар қарор дорад е не. Агар малика дар хатар бошад, вай ба мавқеи навбатии дастрас мегузарад. Агар чунин мавқеъ пайдо нашавад, алгоритм ба қафо бармегардад ва ҷойгиршавии ферзи пештараро тағйир медиҳад.', NULL, 9, NULL)
	 ,(22, 2, N'Намунаи татбиқ:', NULL, 10, NULL)
	 ,(22, 6, N'', NULL, 11, 19)
	 ,(22, 3, N'2. Усули "алгоритми Генетикӣ"', NULL, 12, NULL)
	 ,(22, 2, N'Роҳи дигари ҳалли масъалаи Ҷойгиркунии n-ферзҳо истифодаи усули эвристикӣ, ба монанди алгоритми Генетикӣ мебошад. Дар ин усул шумораи ибтидоии ҷойгиркунии ферзҳо дар тахта ба вуҷуд меояд. Сипас амалиети салибкунӣ, мутатсия ва интихоб барои эҷоди наслҳои нави ҷойгиркунӣ истифода мешаванд. Эволютсия то пайдо шудани ҳалли масъала е ба даст овардани шумораи максималии наслҳо идома меебад.', NULL, 13, NULL)
	 ,(22, 2, N'Намунаи татбиқ:', NULL, 14, NULL)
	 ,(22, 6, N'', NULL, 15, 20)

	 
	 ,(23, 1, N'Рақамҳои ибтидоӣ: Таъриф Ва усулҳои санҷиш', NULL, 1, NULL)
	 ,(23, 2, N'Рақамҳои ибтидоӣ рақамҳои табиӣ мебошанд, ки маҳз ду тақсимкунандаи гуногуни табиӣ доранд: 1 ва худи ин рақам. Ба ибораи дигар, адади оддӣ ададест, ки танҳо ба 1 ва ба худ тақсим мешавад. Масалан, рақамҳои 2, 3, 5, 7 ва 11 оддӣ мебошанд, дар ҳоле ки рақамҳои 4, 6, 8 ва 9 оддӣ нестанд, зеро онҳо зиеда аз ду тақсимкунанда доранд.', NULL, 2, NULL)
	 ,(23, 2, N'Рақамҳои ибтидоӣ дар соҳаҳои гуногуни математика ва илмҳои компютерӣ, махсусан дар соҳаҳое, ба монанди криптография, ки онҳо барои рамзгузории маълумот истифода мешаванд, нақши калидӣ доранд.', NULL, 3, NULL)
	 ,(23, 2, N'Тафтиши рақам барои соддагӣ', NULL, 4, NULL)
	 ,(23, 2, N'Барои оғоз кардан, алгоритми оддиро дида мебароем, ки санҷидани он, ки ое рақам оддӣ аст, аз 1 то N гузаштани ҳамаи рақамҳо.', NULL, 5, NULL)
	 ,(23, 6, N'', NULL, 6, 21)
	 ,(23, 2, N'Ин рамз ҳар як рақамро аз 1 То N бо истифода аз функсияи `is_prime`пай дар пай месанҷад. Агар рақам ба ягон рақам аз 2 то n-1 тақсим карда шавад, он оддӣ нест.', NULL, 7, NULL)
	 ,(23, 3, N'Оптимизатсия: Санҷиш то N/2', NULL, 8, NULL)
	 ,(23, 2, N'Мо метавонем ин алгоритмро бо санҷиши тақсимкунандагон танҳо То N/2 оптимизатсия кунем. Ин аз он сабаб аст, ки рақамҳое, ки аз n/2 калонтар ва Аз N хурдтаранд, Ба N тақсим намешаванд.', NULL, 9, NULL)
	 ,(23, 6, N'', NULL, 10, 22)
	 ,(23, 3, N'Оптимизатсия: Санҷиш ба √(N)', NULL, 11, NULL)
	 ,(23, 2, N'Барои оптимизатсияи боз ҳам бештар тақсимкунандаҳоро танҳо то √(N) санҷидан мумкин аст. Агар адад оддӣ набошад, пас он ҳадди аққал ду адад дорад, ки бояд аз решаи адади ибтидоӣ камтар(ё баробар) бошанд, вагарна ҳосили онҳо аз адади ибтидоӣ калонтар хоҳад буд, аз ин рӯ, аз рақамҳои минбаъда гузаштан маъно надорад.', NULL, 12, NULL)
	 ,(23, 6, N'', NULL, 13, 23)
	 ,(23, 2, N'Хулоса', NULL, 14, NULL)
	 ,(23, 2, N'Рақамҳои ибтидоӣ дар математика ва илмҳои компютерӣ асосӣ мебошанд. Мо усулҳои гуногуни санҷиши рақамро барои соддагӣ, аз алгоритми оддӣ сар карда, ҳамаи тақсимкунандаҳои имконпазирро то усулҳои оптимизатсияшуда бо истифода аз хосиятҳои тақсимшаванда баррасӣ кардем. Усули охирин, ки тақсимкунандаҳоро то `√(N)` месанҷад, аз ҳама самараноктарин аст ва дар амал васеъ истифода мешавад.', NULL, 15, NULL)

	 
	 ,(24, 1, N'Алгоритмҳои тасодуфӣ: Мафҳум ва татбиқ', NULL, 1, NULL)
	 ,(24, 2, N'Алгоритмҳои тасодуфӣ алгоритмҳое мебошанд, ки рақамҳои тасодуфиро барои қабули қарорҳо дар ҷараени иҷро истифода мебаранд. Баръакси алгоритмҳои муайяншуда, ки ҳамеша ҳамон амалҳоро барои як вуруд иҷро мекунанд, алгоритмҳои тасодуфӣ метавонанд дар ҳар як оғози ҳамон маълумот гуногун рафтор кунанд. Ин онҳоро абзорҳои тавоно барои ҳалли мушкилоти гуногун месозад, ки дар он ҷо тасодуфӣ метавонад иҷроишро ба таври назаррас беҳтар кунад е татбиқи онро осонтар кунад.', NULL, 2, NULL)
	 ,(24, 2, N'Принсипҳои алгоритмҳои тасодуфӣ', NULL, 3, NULL)
	 ,(24, 2, N'Алгоритмҳои тасодуфӣ ба ду категорияи асосӣ тақсим мешаванд:', NULL, 4, NULL)
	 ,(24, 5, N'Лас Вегас алгоритмҳо: дурустии ҳалли масъаларо Кафолат Медиҳанд, аммо вақти иҷро миқдори тасодуфӣ мебошад. Мисол: намунаи тасодуфӣ барои ҷобаҷогузорӣ;'+char(10)+N'Монте-Карло алгоритмҳо: дурустии қарорро кафолат Намедиҳанд, аммо дар вақти муайян кор мекунанд. Мисол: санҷиши соддагии рақам.', NULL, 5, NULL)
	 ,(24, 2, N'Намунаҳои татбиқ:', NULL, 6, NULL)
	 ,(24, 5, N'Ҷобаҷогузорӣ ва ҷустуҷӯ: ҷобаҷогузории Зуд (Quicksort) бо интихоби тасодуфии унсури дастгирӣ.'+char(10)+N'Оптимизатсия: Алгоритмҳои Ба Монте Карло асосефта барои ҷустуҷӯи оптимуми глобалӣ дар функсияҳои мураккаб.'+char(10)+N'Тавлиди рақамҳо: истифодаи алгоритмҳои тасодуфӣ барои тавлиди рақамҳои тасодуфӣ.'+char(10)+N'Криптография: Тавлиди калидҳо ва дигар амалиети криптографӣ, ки дар он тасодуфӣ нақши калидӣ мебозад.', NULL, 7, NULL)
	 ,(24, 2, N'Намунаи алгоритми тасодуфӣ: ҷамъбасти Зуд', NULL, 8, NULL)
	 ,(24, 2, N'Ҷамъбасти зуд(Quicksort) алгоритми маъмули ҷудокунӣ мебошад, ки ба ҳисоби миена мураккабии Вақти O (n log n) дорад. Ҳангоми истифодаи тасодуфӣ, Quicksort унсури асосиро ба таври тасодуфӣ интихоб мекунад, ки эҳтимолияти бадтарин ҳолатро коҳиш медиҳад, ки мураккабии Муваққатии O(n^2) дорад.', NULL, 9, NULL)
	 ,(24, 2, N'Татбиқи Quicksort', NULL, 10, NULL)
	 ,(24, 6, N'', NULL, 11, 24)
	 ,(24, 2, N'Афзалиятҳои алгоритмҳои тасодуфӣ', NULL, 12, NULL)
	 ,(24, 5, N'Осонии татбиқ: дар баъзе ҳолатҳо, тасодуфӣ метавонад алгоритмро хеле содда кунад.'+char(10)+N'Баланд бардоштани ҳосилнокӣ: интихоби Тасодуфӣ метавонад бадтарин ҳолатҳоро пешгирӣ кунад ва иҷрои миенаро беҳтар кунад.'+char(10)+N'Универсалӣ: алгоритмҳои Тасодуфӣ метавонанд дар соҳаҳои гуногун, аз ҷобаҷогузорӣ то криптография то омӯзиши мошинсозӣ татбиқ карда шаванд.', NULL, 13, NULL)
	 ,(24, 2, N'Камбудиҳои алгоритмҳои тасодуфӣ', NULL, 14, NULL)
	 ,(24, 5, N'Номуайянӣ: Азбаски натиҷаҳо метавонанд дар ҳар як оғоз фарқ кунанд, ислоҳ ва озмоиши чунин алгоритмҳо душвор буда метавонад.'+char(10)+N'Талаботи генераторҳои рақамҳои тасодуфӣ: Самаранокии алгоритмҳои тасодуфӣ аз сифати генераторҳои рақамҳои тасодуфӣ вобаста аст.', NULL, 15, NULL)
	 ,(24, 3, N'Хулоса', NULL, 16, NULL)
	 ,(24, 2, N'Алгоритмҳои тасодуфӣ воситаи пурқувват дар арсенали барномасозон ва муҳаққиқон барои ҳалли масъалаҳои мураккаб самараноктар ва соддатар мебошанд. Истифодаи рақамҳои тасодуфӣ метавонад иҷрои алгоритмҳо ва мутобиқати онҳоро ба ҳолатҳои гуногун ба таври назаррас беҳтар кунад. Фаҳмидани ҳам афзалиятҳо ва ҳам маҳдудиятҳои ин алгоритмҳо барои истифодаи беҳтарини онҳо муҳим аст.', NULL, 17, NULL)


	 
	 ,(25, 1, N'Мушкилоти ҷузвдон: Мафҳум ва усулҳои ҳалли', NULL, 1, NULL)
	 ,(25, 2, N'Масъалаи халта (Knapsack Problem) яке аз масъалаҳои классикии оптимизатсияи комбинаторӣ мебошад. Дар ин масъала бояд аз бисер ашеҳо зергурӯҳеро интихоб кард, ки арзиши умумии он ҳадди аксар аст ва вазни умумии он аз маҳдудияти додашуда зиед нест.', NULL, 2, NULL)
	 ,(25, 2, N'Муқаррар кардани вазифа', NULL, 3, NULL)
	 ,(25, 2, N'Маҷмӯи ашеҳо мавҷуданд, ки ҳар кадоми онҳо вазн ва арзиши муайян доранд. Ин маҷмӯи ашеро интихоб кардан лозим аст, то ки арзиши умумии онҳо ҳадди аксар бошад ва вазни умумии онҳо аз маҳдудияти додашуда зиед набошад.', NULL, 4, NULL)
	 ,(25, 2, N'Танзимоти расмӣ', NULL, 5, NULL)
	 ,(25, 5, N'Бигзор N — шумораи ашё.'+char(10)+N'Бигзор wi — вазни ашёi.'+char(10)+N'Бигзор vi — арзиши ашё i.'+char(10)+N'Бигзор W — вазни максималии иҷозатдодашуда.', NULL, 6, NULL)
	 ,(25, 2, N'Мо бояд зергурӯҳи ашеи S-ро пайдо кунем, ки:', NULL, 7, NULL)
	 ,(25, 2, N'$$\sum_{i \in S} w_i \leq W$$', NULL, 8, NULL)
	 ,(25, 2, N'ва', NULL, 9, NULL)
	 ,(25, 2, N'$$\sum_{i \in S} v_i$$', NULL, 10, NULL)
	 ,(25, 2, N'ба қадри имкон.', NULL, 11, NULL)
	 ,(25, 3, N'Усулҳои ҳалли', NULL, 12, NULL)
	 ,(25, 2, N'Якчанд равишҳо барои ҳалли масъалаи ҷузвдон мавҷуданд:', NULL, 13, NULL)
	 ,(25, 5, N'Алгоритми тамаъҷӯӣ.'+char(10)+N'Усули барномасозии динамикӣ.'+char(10)+N'Алгоритмҳои комбинатсионӣ.', NULL, 14, NULL)
	 ,(25, 2, N'Биеед ҳар яке аз ин усулҳоро муфассалтар дида бароем.', NULL, 15, NULL)
	 ,(25, 3, N'1. Алгоритми тамаъҷӯӣ', NULL, 16, NULL)
	 ,(25, 2, N'Алгоритми тамаъҷӯӣ аксар вақт барои ҳалли масъалаи халта бо ашеи хароб (Fractional Knapsack Problem) истифода мешавад, ки дар он ашеро шикастан мумкин аст. Дар ин ҳолат усули зерин истифода мешавад:', NULL, 17, NULL)
	 ,(25, 5, N'Арзиши воҳиди вазнро барои ҳар як ашеи `vi / wi` ҳисоб кунед.'+char(10)+N'Ашеро аз рӯи камшавии ин арзиш ҷобаҷо кунед.'+char(10)+N'То он даме, ки маҳдудияти вазн имкон медиҳад, ашеро ба ҷузвдон пайваста илова кунед.', NULL, 18, NULL)
	 ,(25, 2, N'Намунаи татбиқи алгоритми тамаъҷӯӣ:', NULL, 19, NULL)
	 ,(25, 6, N'', NULL, 20, 25)
	 ,(25, 1, N'2. Усули барномасозии динамикӣ', NULL, 21, NULL)
	 ,(25, 2, N'Усули барномасозии динамикӣ барои ҳалли масъалаи халта, ки дар он ашеро шикастан мумкин нест (0/1 Knapsack Problem) мувофиқ аст. Ин усул массиви дуҷонибаро барои нигоҳ доштани арзиши максималии аше барои ҳар як вазни имконпазир истифода мебарад.', NULL, 22, NULL)
	 ,(25, 2, N'Намунаи татбиқи барномасозии динамикӣ:', NULL, 23, NULL)
	 ,(25, 6, N'', NULL, 24, 26)
	 ,(25, 2, N'3. Алгоритмҳои комбинатсионӣ', NULL, 25, NULL)
	 ,(25, 2, N'Алгоритмҳои комбинаторӣ усулҳои пурра ва шохаҳо ва сарҳадҳоро дар бар мегиранд. Ин усулҳо меҳнатталабтаранд ва аксар вақт барои вазифаҳои хурд е ҳалли дақиқ ҳангоми имконнопазирии истифодаи усулҳои дигар истифода мешаванд.', NULL, 26, NULL)
	 ,(25, 3, N'Хулоса', NULL, 27, NULL)
	 ,(25, 2, N'Мушкилоти борхалта як масъалаи муҳими оптимизатсияи комбинатсия бо доираи васеи барномаҳо дар соҳаҳои гуногун, ба монанди иқтисод, логистика ва информатика мебошад. Вобаста аз шароити вазифа ва талабот ба дақиқии ҳалли он, усулҳои гуногун, аз қабили алгоритмҳои чашмгурусна, барномасозии динамикӣ е равишҳои комбинатсионӣ метавонанд истифода шаванд.', NULL, 28, NULL)

	 
	 ,(26, 1, N'Масофа дар шабака: барномасозии Динамикӣ дар асоси шабака', NULL, 1, NULL)
	 ,(26, 2, N'Масофа дар шабака (Grid Based Distance) ин синфи масъалаҳоест, ки бо барномасозии динамикӣ ҳал карда мешаванд, ки дар он шумо бояд роҳи беҳтарин е масофаи ҳадди ақалро дар шабакаи дуҷониба пайдо кунед. Ин равиш аксар вақт барои ҳалли мушкилот дар графикҳо, масир ва оптимизатсия истифода мешавад.', NULL, 2, NULL)
	 ,(26, 3, N'Муқаррар кардани вазифа', NULL, 3, NULL)
	 ,(26, 2, N'Масъалаи ёфтани роҳи ҳадди ақалро аз кунҷи болоии чапи шабака ба кунҷи поении рост дида мебароем. Ҳар як ҳуҷайраи шабака арзиш дорад ва мушкилот дар он аст, ки роҳро бо арзиши ҳадди ақал пайдо кунед.', NULL, 4, NULL)
	 ,(26, 3, N'Намоиши расмӣ', NULL, 5, NULL)
	 ,(26, 2, N'Шабакаи андозаи <code>m × n</code> мавҷуд аст, ки дар он ҳар як ҳуҷайра <code>(i, j)</code> арзиши <code>grid[i][j]</code> дорад. Роҳро аз ҳуҷайра <code>(0, 0)</code> ба ҳуҷайра <code>(m-1, n-1)</code> бо арзиши ҳадди ақал пайдо кардан лозим аст.', NULL, 6, NULL)
	 ,(26, 3, N'Усули барномасозии динамикӣ', NULL, 7, NULL)
	 ,(26, 2, N'Барои ҳалли масъала бо истифода аз барномасозии динамикӣ массиви дуҷонибаи <code>dp</code> сохта мешавад, ки дар он <code>dp[i][j]</code> арзиши ҳадди ақали роҳро то ҳуҷайра <code>(i, j)</code> нигоҳ медорад.', NULL, 8, NULL)
	 ,(26, 2, N'Идеяи асосӣ:', NULL, 9, NULL)
	 ,(26, 5, N'Инициализатсия: ҳуҷайраи Ибтидоӣ <code>dp[0][0]</code> арзиши <code>grid[0][0]</code> - ро қабул мекунад.'+char(10)+N'Таносуби такрорӣ: барои ҳар як ҳуҷайра <code>(i, j)</code>, арзиши ҳадди ақали роҳ ба он ба арзиши ин ҳуҷайра ва ҳадди ақали арзиши роҳ ба ҳуҷайраҳои ҳамсоя аз боло ва чап баробар хоҳад буд: $$dp[i][j] = grid[i][j] + \min(dp[i-1][j], dp[i][j-1])$$'+char(10)+N'Сарҳадҳо: барои сатри аввал ва сутуни аввал, роҳ танҳо аз як ҳуҷайраи ҳамсоя имконпазир аст.', NULL, 10, NULL)
	 ,(26, 3, N'Намунаи татбиқ ', NULL, 11, NULL)
	 ,(26, 6, N'', NULL, 12, 27)
	 ,(26, 3, N'Афзалиятҳо ва нуқсонҳои равиш', NULL, 13, NULL)
	 ,(26, 2, N'Афзалиятҳо:', NULL, 14, NULL)
	 ,(26, 5, N'Оптималӣ: барномасозии Динамикӣ ҳалли оптималиро бо назардошти ҳамаи роҳҳои имконпазир пайдо мекунад.'+char(10)+N'Самаранокӣ: Истифодаи мемоизатсия имкон медиҳад, ки ҳисобҳои такрорӣ пешгирӣ карда шаванд, ки ин раванди ҳалли масъаларо суръат мебахшад.'+char(10)+N'Универсалӣ: Равишро барои намудҳои гуногуни шабакаҳо ва шароити иловагӣ мутобиқ кардан мумкин аст.', NULL, 15, NULL)
	 ,(26, 2, N'Камбудиҳо', NULL, 16, NULL)
	 ,(26, 5, N'Истеъмоли хотира: эҷоди массиви дуҷониба хароҷоти назарраси хотираро талаб мекунад, махсусан барои шабакаҳои калон.'+char(10)+N'Мушкилии татбиқ: вазифаҳои мураккаб коркарди ҳамаҷонибаи таносуби такрорӣ ва шароити сарҳадро талаб мекунанд.', NULL, 17, NULL)
	 ,(26, 3, N'Хулоса', NULL, 18, NULL)
	 ,(26, 2, N'Вазифаҳои шабакавӣ бо истифода аз барномасозии динамикӣ воситаи пурқувват барои ҳалли вазифаҳои гуногуни оптимизатсия мебошанд. Усул ба шумо имкон медиҳад, ки роҳҳои оптималӣ ва арзиши ҳадди ақалро бо истифодаи самараноки захираҳо ва бо назардошти ҳамаи имконоти имконпазир пайдо кунед. Равишро дар доираи васеи соҳаҳо, аз масир ва логистика то робототехника ва зеҳни сунъӣ татбиқ кардан мумкин аст.', NULL, 19, NULL)


GO

INSERT INTO CodeInLang(CodeListId, LanguageId, Code)
VALUES(1, 1, N'def linear_search(arr, target):'+char(10)+N'    for i in range(len(arr)):'+char(10)+N'        if arr[i] == target:'+char(10)+N'            return i'+char(10)+N'    return -1'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'arr = [10, 20, 30, 40, 50]'+char(10)+N'target = 30'+char(10)+N'result = linear_search(arr, target)'+char(10)+N'if result != -1:'+char(10)+N'    print("Элементи", target, "ёфта шуд дар индекси", result)'+char(10)+N'else:'+char(10)+N'    print("Элементи", target, "ёфта нашуд")')
,(1, 2, '#include <iostream>'+char(10)+N'using namespace std;'+char(10)+N'int main() {'+char(10)+N'    int arr[7] = { 1, 3, 5, 7, 9, 11, 13 };'+char(10)+N'    int target = 7, result = -1;'+char(10)+N'    for(int i=0; i < 7; i++) {'+char(10)+N'        if(arr[i] == target) {'+char(10)+N'            result = i;'+char(10)+N'            cout << "Элемент найден в позиции " << i << ".";'+char(10)+N'            break;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N''+char(10)+N'    if(result != -1)'+char(10)+N'        cout << "Элемент ёфта шуд дар индекси " << i << ".";'+char(10)+N'    else'+char(10)+N'        cout << "Элемент ёфта нашуд.";'+char(10)+N'}')

,(2, 1, N'def euclidean_algorithm(a, b):'+char(10)+N'    while b != 0:'+char(10)+N'        a, b = b, a % b'+char(10)+N'    return a'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'num1 = 48'+char(10)+N'num2 = 18'+char(10)+N'gcd = euclidean_algorithm(num1, num2)'+char(10)+N'print("Калонтарин тақсимкунандаи умумии рақамҳои", num1, "ва", num2, "бароюар аст ба", gcd)')
--,(2, 2, N'')

,(3, 1, N'import heapq'+char(10)+'from collections import defaultdict'+char(10)+''+char(10)+'def huffman_coding(freq):'+char(10)+'    heap = [[weight, [symbol, ""]] for symbol, weight in freq.items()]'+char(10)+'    heapq.heapify(heap)'+char(10)+'    while len(heap) > 1:'+char(10)+'        lo = heapq.heappop(heap)'+char(10)+'        hi = heapq.heappop(heap)'+char(10)+'        for pair in lo[1:]:'+char(10)+'            pair[1] = "0" + pair[1]'+char(10)+'        for pair in hi[1:]:'+char(10)+'            pair[1] = "1" + pair[1]'+char(10)+'        heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])'+char(10)+'    return sorted(heapq.heappop(heap)[1:], key=lambda p: (len(p[-1]), p))'+char(10)+''+char(10)+N'# Пример использования'+char(10)+'data = "hello"'+char(10)+'freq = defaultdict(int)'+char(10)+'for symbol in data:'+char(10)+'    freq[symbol] += 1'+char(10)+'huff_codes = huffman_coding(freq)'+char(10)+N'print("Символ\tЧастота\tКод Хаффмана")'+char(10)+'for symbol, f in freq.items():'+char(10)+'    code = [x[1] for x in huff_codes if x[0] == symbol][0]'+char(10)+'    print(f"{symbol}\t{f}\t{code}")')

,(4, 1, N'def binary_search(arr, target):'+char(10)+N'    # Оғози сарҳади чап ва рости массив'+char(10)+N'    left, right = 0, len(arr) - 1'+char(10)+N'    # То сарҳади чап аз сарҳади рост зиёд набошад'+char(10)+N'    while left <= right:'+char(10)+N'        # Индекси миёнаи массивро пайдо мекунад'+char(10)+N'        mid = (left + right) // 2'+char(10)+N'        # Агар унсури миёна ба унсури мақсаднок баробар бошад, индекси онро бармегардонем'+char(10)+N'        if arr[mid] == target:'+char(10)+N'            return mid'+char(10)+N'        # Агар унсури миена аз ҳадаф хурдтар бошад, ҷустуҷӯро ба нимаи рости массив кам кунед'+char(10)+N'        elif arr[mid] < target:'+char(10)+N'            left = mid + 1'+char(10)+N'        # Агар унсури миена аз ҳадаф калонтар бошад, майдони ҷустуҷӯро ба нимаи чапи массив танг кунед'+char(10)+N'        else:'+char(10)+N'            right = mid - 1'+char(10)+N'    # Агар элемент ёфт нашавад, мо бармегардем -1'+char(10)+N'    return -1'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'arr = [10, 20, 30, 40, 50, 60, 70]'+char(10)+N'target = 30'+char(10)+N'result = binary_search(arr, target)'+char(10)+N'if result != -1:'+char(10)+N'    print("Элементи", target, " ёфта шуд дар индекси ", result)'+char(10)+N'else:'+char(10)+N'    print("Элементи", target, " дар массив ёфта нашудааст ")')
,(4, 2, N'#include <iostream>'+char(10)+N'#include <vector>'+char(10)+N''+char(10)+N'int binary_search(const std::vector<int>& arr, int target) {'+char(10)+N'    int left = 0, right = arr.size() - 1;'+char(10)+N'    while (left <= right) {'+char(10)+N'        int mid = left + (right - left) / 2; // Индекси миёнаи массивро пайдо мекунад'+char(10)+N'        if (arr[mid] == target) {'+char(10)+N'            return mid;'+char(10)+N'        } else if (arr[mid] < target) {'+char(10)+N'            left = mid + 1;'+char(10)+N'        } else {'+char(10)+N'            right = mid - 1;'+char(10)+N'        }'+char(10)+N'    }'+char(10)+N'    return -1;'+char(10)+N'}'+char(10)+N''+char(10)+N'int main() {'+char(10)+N'    std::vector<int> arr = {1, 3, 5, 7, 9, 11, 13};'+char(10)+N'    int target = 7;'+char(10)+N'    int result = binary_search(arr, target);'+char(10)+N'    if (result != -1) {'+char(10)+N'        std::cout << "Элемент ёфта шуд дар индекси " << result << "." << std::endl;'+char(10)+N'    } else {'+char(10)+N'        std::cout << "Элемент дар массив ёфта нашудааст." << std::endl;'+char(10)+N'    }'+char(10)+N'    return 0;'+char(10)+N'}')

,(5, 2, N'void BubbleSort(vector<int>& values) {'+char(10)+N'  for (size_t idx_i = 0; idx_i + 1 < values.size(); ++idx_i) {'+char(10)+N'    for (size_t idx_j = 0; idx_j + 1 < values.size() - idx_i; ++idx_j) {'+char(10)+N'      if (values[idx_j + 1] < values[idx_j]) {'+char(10)+N'        swap(values[idx_j], values[idx_j + 1]);'+char(10)+N'      }'+char(10)+N'    }'+char(10)+N'  }'+char(10)+N'}')
,(5, 1, N'def bubble_sort(values):'+char(10)+N'    for idx_i in range(len(values) - 1):'+char(10)+N'        for idx_j in range(len(values) - idx_i - 1):'+char(10)+N'            if values[idx_j + 1] < values[idx_j]:'+char(10)+N'                values[idx_j], values[idx_j + 1] = values[idx_j + 1], values[idx_j]'+char(10)+N''+char(10)+N'# Пример использования'+char(10)+N'values = [64, 34, 25, 12, 22, 11, 90]'+char(10)+N'bubble_sort(values)'+char(10)+N'print("Отсортированный список:", values)')

,(6, 2, N'void SelectionSort(vector<int>& values) {'+char(10)+N'  for (auto i = values.begin(); i != values.end(); ++i) {'+char(10)+N'    auto j = std::min_element(i, values.end());'+char(10)+N'    swap(*i, *j);'+char(10)+N'  }'+char(10)+N'}')

,(7, 2, N'int Partition(vector<int>& values, int l, int r) {'+char(10)+N'  int x = values[r];'+char(10)+N'  int less = l;'+char(10)+N''+char(10)+N'  for (int i = l; i < r; ++i) {'+char(10)+N'    if (values[i] <= x) {'+char(10)+N'      swap(values[i], values[less]);'+char(10)+N'      ++less;'+char(10)+N'    }'+char(10)+N'  }'+char(10)+N'  swap(values[less], values[r]);'+char(10)+N'  return less;'+char(10)+N'}'+char(10)+N''+char(10)+N'void QuickSortImpl(vector<int>& values, int l, int r) {'+char(10)+N'  if (l < r) {'+char(10)+N'    int q = Partition(values, l, r);'+char(10)+N'    QuickSortImpl(values, l, q - 1);'+char(10)+N'    QuickSortImpl(values, q + 1, r);'+char(10)+N'  }'+char(10)+N'}'+char(10)+N''+char(10)+N'void QuickSort(vector<int>& values) {'+char(10)+N'  if (!values.empty()) {'+char(10)+N'    QuickSortImpl(values, 0, values.size() - 1);'+char(10)+N'  }'+char(10)+N'}')

,(8, 1, N'def bfs(graph, start):'+char(10)+N'    queue = [start]'+char(10)+N'    visited = set()'+char(10)+N'    while queue:'+char(10)+N'        current = queue.pop(0)'+char(10)+N'        visited.add(current)'+char(10)+N'        for neighbor in graph[current]:'+char(10)+N'            if neighbor not in visited:'+char(10)+N'                queue.append(neighbor)'+char(10)+N''+char(10)+N'graph = {'+char(10)+N'    "A": ["B", "C"],'+char(10)+N'    "B": ["D", "E"],'+char(10)+N'    "C": ["F"],'+char(10)+N'    "D": [],'+char(10)+N'    "E": [],'+char(10)+N'    "F": [],'+char(10)+N'}'+char(10)+N'bfs(graph, "A")')

,(9, 1, N'def hanoi_recursive(n, source, target, auxiliary):'+char(10)+N'    if n == 1:'+char(10)+N'        print("Ҷойивазкунии диск 1 с", source, "на", target)'+char(10)+N'        return'+char(10)+N'    hanoi_recursive(n-1, source, auxiliary, target)'+char(10)+N'    print("Ҷойивазкунии диск ", n, "с", source, "на", target)'+char(10)+N'    hanoi_recursive(n-1, auxiliary, target, source)'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'n = 3'+char(10)+N'hanoi_recursive(n, "A", "C", "B")')

,(10, 1, N'def hanoi_iterative(n, source, target, auxiliary):'+char(10)+N'    stack = [(n, source, target, auxiliary)]'+char(10)+N'    while stack:'+char(10)+N'        n, source, target, auxiliary = stack.pop()'+char(10)+N'        if n == 1:'+char(10)+N'            print("Ҷойивазкунии диск 1 с", source, "на", target)'+char(10)+N'        else:'+char(10)+N'            stack.append((n-1, auxiliary, target, source))'+char(10)+N'            stack.append((1, source, target, auxiliary))'+char(10)+N'            stack.append((n-1, source, auxiliary, target))'+char(10)+char(10)+N'# Намунаи истифода:'+char(10)+N'n = 3'+char(10)+N'hanoi_iterative(n, "A", "C", "B")')

,(11, 1, N'def power(base, exponent):'+char(10)+N'    result = 1'+char(10)+N'    # То расидан ба нишондиҳанда 0'+char(10)+N'    while exponent > 0:'+char(10)+N'        # Агар нишондиҳанда ҷуфт бошад'+char(10)+N'        if exponent % 2 == 0:'+char(10)+N'            base *= base'+char(10)+N'            exponent //= 2'+char(10)+N'        # Агар нишондиҳанда тоқ бошад'+char(10)+N'        else:'+char(10)+N'            result *= base'+char(10)+N'            exponent -= 1'+char(10)+N'    return result'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'base = 2'+char(10)+N'exponent = 10'+char(10)+N'result = power(base, exponent)'+char(10)+N'print(base, "дар дараҷаи", exponent, "баробар аст ба ", result)')

,(12, 1, N'class Kruskal:'+char(10)+N'    def find_parent(self, parent, i):'+char(10)+N'        if parent[i] == i:'+char(10)+N'            return i'+char(10)+N'        return self.find_parent(parent, parent[i])'+char(10)+N''+char(10)+N'    def union(self, parent, rank, x, y):'+char(10)+N'        x_root = self.find_parent(parent, x)'+char(10)+N'        y_root = self.find_parent(parent, y)'+char(10)+N''+char(10)+N'        if rank[x_root] < rank[y_root]:'+char(10)+N'            parent[x_root] = y_root'+char(10)+N'        elif rank[x_root] > rank[y_root]:'+char(10)+N'            parent[y_root] = x_root'+char(10)+N'        else:'+char(10)+N'            parent[y_root] = x_root'+char(10)+N'            rank[x_root] += 1'+char(10)+N''+char(10)+N'    def kruskal_algorithm(self, graph):'+char(10)+N'        result = []'+char(10)+N'        i, e = 0, 0'+char(10)+N'        graph = sorted(graph, key=lambda item: item[2])'+char(10)+N'        parent, rank = [], []'+char(10)+N'        for node in range(len(graph)):'+char(10)+N'            parent.append(node)'+char(10)+N'            rank.append(0)'+char(10)+N''+char(10)+N'        while e < len(graph) - 1:'+char(10)+N'            u, v, w = graph[i]'+char(10)+N'            i += 1'+char(10)+N'            x = self.find_parent(parent, u)'+char(10)+N'            y = self.find_parent(parent, v)'+char(10)+N'            if x != y:'+char(10)+N'                e += 1'+char(10)+N'                result.append([u, v, w])'+char(10)+N'                self.union(parent, rank, x, y)'+char(10)+N'        return result'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'graph = [[0, 1, 4], [0, 7, 8], [1, 7, 11], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, 2], [8, 6, 6], [2, 5, 4], [2, 3, 7], [6, 5, 2], [3, 5, 14], [3, 4, 9], [5, 4, 10]]'+char(10)+N'kruskal = Kruskal()'+char(10)+N'result = kruskal.kruskal_algorithm(graph)'+char(10)+N'print(result)')

,(13, 1, N'def dfs(graph, start):'+char(10)+N'    """'+char(10)+N'    graph: Луғате, ки графро ифода мекунад.'+char(10)+N'    start: Нуқтаи оғоз.'+char(10)+N'    """'+char(10)+N'    visited = {key: 0 for key in graph}  # Ҳама нуқтаҳоро ҳамчун сафед оғоз кунед (дида нашуда)'+char(10)+N'    stack = [start]  # Истифодаи рӯйхат ҳамчун стек'+char(10)+N'    visited[start] = 1  # Нуқтаро ҳамчун хокистарӣ қайд мекунем (дар рафти боздид)'+char(10)+N''+char(10)+N'    while stack:'+char(10)+N'        vertex = stack.pop()'+char(10)+N'        print(vertex, "->", end=" ")'+char(10)+N'        '+char(10)+N'        # Для каждой смежной вершины'+char(10)+N'        if vertex in graph:'+char(10)+N'            for neighbour in graph[vertex]:'+char(10)+N'                if visited[neighbour] == 0:  # Агар нуқта сафед бошад (дида нашуда)'+char(10)+N'                    stack.append(neighbour)'+char(10)+N'                    visited[neighbour] = 1  # Нуқтаро ҳамчун хокистарӣ қайд мекунем (дар рафти боздид)'+char(10)+N''+char(10)+N'        visited[vertex] = 2  # Нуқтаро ҳамчун сиёҳ қайд мекунем (комилан дидан карда шудааст)'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'graph = {'+char(10)+N'    0: [1, 2],'+char(10)+N'    1: [2],'+char(10)+N'    2: [0, 3],'+char(10)+N'    3: [3]'+char(10)+N'}'+char(10)+N''+char(10)+N'start_vertex = 2'+char(10)+N'print(Ҷустуҷӯи амиқи такрории (DFS) сар карда аз нуқтаи", start_vertex)'+char(10)+N'dfs(graph, start_vertex)')

,(14, 1, N'def power(base, exponent):'+char(10)+N'    # Агар нишондиҳанда 0 бошад, бармегардад 1'+char(10)+N'    if exponent == 0:'+char(10)+N'        return 1'+char(10)+N'    # Агар нишондиҳанда ҷуфт бошад, ҳисоб мекунем base^(exponent/2) ва мураббаъ кунед'+char(10)+N'    elif exponent % 2 == 0:'+char(10)+N'        temp = power(base, exponent // 2)'+char(10)+N'        return temp * temp'+char(10)+N'    # Агар нишондиҳанда тоқ бошад, ҳисоб мекунем base^(exponent-1) ва зарб ба base'+char(10)+N'    else:'+char(10)+N'        temp = power(base, (exponent - 1) // 2)'+char(10)+N'        return base * temp * temp'+char(10)+N''+char(10)+N'# Намунаи истифода:'+char(10)+N'base = 2'+char(10)+N'exponent = 10'+char(10)+N'result = power(base, exponent)'+char(10)+N'print(base, "дар дараҷаи", exponent, " баробар ба", result)')

,(15, 1, N'def is_palindrome(s):'+char(10)+N'    left = 0'+char(10)+N'    right = len(s) - 1'+char(10)+N'    '+char(10)+N'    while left < right:'+char(10)+N'        if s[left] != s[right]:'+char(10)+N'            return False'+char(10)+N'        left += 1'+char(10)+N'        right -= 1'+char(10)+N'    '+char(10)+N'    return True'+char(10)+char(10)+N'# Намунаи истифода '+char(10)+N's = "racecar"'+char(10)+N'print(f"Сатри \"{s}\" палиндром аст: {is_palindrome(s)}")')

,(16, 1, N'def find_pair_with_sum(arr, target_sum):'+char(10)+N'    left = 0'+char(10)+N'    right = len(arr) - 1'+char(10)+N'    while left < right:'+char(10)+N'        current_sum = arr[left] + arr[right]'+char(10)+N'        if current_sum == target_sum:'+char(10)+N'            return (arr[left], arr[right])'+char(10)+N'        elif current_sum < target_sum:'+char(10)+N'            left += 1'+char(10)+N'        else:'+char(10)+N'            right -= 1'+char(10)+N'    '+char(10)+N'    return None'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'arr = [1, 2, 3, 4, 6]'+char(10)+N'target_sum = 6'+char(10)+N'result = find_pair_with_sum(arr, target_sum)'+char(10)+N'print(f" Ҷуфти рақамҳо бо ҷамъ {target_sum}: {result}")')

,(17, 1, N'def merge_sorted_arrays(arr1, arr2):'+char(10)+N'    merged_array = []'+char(10)+N'    i = 0'+char(10)+N'    j = 0'+char(10)+N'    while i < len(arr1) and j < len(arr2):'+char(10)+N'        if arr1[i] < arr2[j]:'+char(10)+N'            merged_array.append(arr1[i])'+char(10)+N'            i += 1'+char(10)+N'        else:'+char(10)+N'            merged_array.append(arr2[j])'+char(10)+N'            j += 1'+char(10)+N'    '+char(10)+N'    # Унсурҳои боқимондаро илова кунед'+char(10)+N'    while i < len(arr1):'+char(10)+N'        merged_array.append(arr1[i])'+char(10)+N'        i += 1'+char(10)+N'    while j < len(arr2):'+char(10)+N'        merged_array.append(arr2[j])'+char(10)+N'        j += 1'+char(10)+N'    '+char(10)+N'    return merged_array'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'arr1 = [1, 3, 5]'+char(10)+N'arr2 = [2, 4, 6]'+char(10)+N'result = merge_sorted_arrays(arr1, arr2)'+char(10)+N'print(f" Массиви якҷояшуда: {result}")')

,(18, 1, N'import heapq'+char(10)+N''+char(10)+N'def dijkstra(graph, start):'+char(10)+N'    """'+char(10)+N'    graph: Луғате, ки графро ифода мекунад. Калидҳои болоӣ, арзишҳо рӯйхати кортежҳо (сосед, вес).'+char(10)+N'    start: Қуллаи ибтидоӣ.'+char(10)+N'    return: Луғати масофаҳои кӯтоҳтарин аз қуллаи ибтидоӣ то ҳар қулла.'+char(10)+N'    """'+char(10)+N'    # Оғози кор'+char(10)+N'    distances = {vertex: float("infinity") for vertex in graph}'+char(10)+N'    distances[start] = 0'+char(10)+N'    priority_queue = [(0, start)]'+char(10)+N'    visited = set()'+char(10)+N''+char(10)+N'    while priority_queue:'+char(10)+N'        current_distance, current_vertex = heapq.heappop(priority_queue)'+char(10)+N'        if current_vertex in visited:'+char(10)+N'            continue'+char(10)+N''+char(10)+N'        visited.add(current_vertex)'+char(10)+N'        for neighbor, weight in graph[current_vertex]:'+char(10)+N'            distance = current_distance + weight'+char(10)+N'            if distance < distances[neighbor]:'+char(10)+N'                distances[neighbor] = distance'+char(10)+N'                heapq.heappush(priority_queue, (distance, neighbor))'+char(10)+N''+char(10)+N'    return distances'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'graph = {'+char(10)+N'    "A": [("B", 1), ("C", 4)],'+char(10)+N'    "B": [("A", 1), ("C", 2), ("D", 5)],'+char(10)+N'    "C": [("A", 4), ("B", 2), ("D", 1)],'+char(10)+N'    "D": [("B", 5), ("C", 1)]'+char(10)+N'}'+char(10)+N''+char(10)+N'start_vertex = "A"'+char(10)+N'distances = dijkstra(graph, start_vertex)'+char(10)+N'print(f" Масофаи кӯтоҳтарин аз қулла {start_vertex}:")'+char(10)+N'for vertex, distance in distances.items():'+char(10)+N'    print(f" Ба боло {vertex}: {distance}")')

,(19, 1, N'def is_safe(board, row, col, N):'+char(10)+N'    # Санҷиши амудӣ ва уфуқӣ'+char(10)+N'    for i in range(N):'+char(10)+N'        if board[row][i] == 1 or board[i][col] == 1:'+char(10)+N'            return False'+char(10)+N'    '+char(10)+N'    # Диагоналҳоро тафтиш кунед'+char(10)+N'    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):'+char(10)+N'        if board[i][j] == 1:'+char(10)+N'            return False'+char(10)+N'    for i, j in zip(range(row, -1, -1), range(col, N)):'+char(10)+N'        if board[i][j] == 1:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'def solve_n_queens_util(board, col, N):'+char(10)+N'    if col >= N:'+char(10)+N'        return True'+char(10)+N'    '+char(10)+N'    for i in range(N):'+char(10)+N'        if is_safe(board, i, col, N):'+char(10)+N'            board[i][col] = 1'+char(10)+N'            if solve_n_queens_util(board, col + 1, N):'+char(10)+N'                return True'+char(10)+N'            board[i][col] = 0'+char(10)+N'    return False')

,(20, 1, N'def is_safe(board, row, col, N):'+char(10)+N'    # Санҷиши амудӣ ва уфуқӣ'+char(10)+N'    for i in range(N):'+char(10)+N'        if board[row][i] == 1 or board[i][col] == 1:'+char(10)+N'            return False'+char(10)+N'    '+char(10)+N'    # Диагоналҳоро тафтиш кунед'+char(10)+N'    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):'+char(10)+N'        if board[i][j] == 1:'+char(10)+N'            return False'+char(10)+N'    for i, j in zip(range(row, -1, -1), range(col, N)):'+char(10)+N'        if board[i][j] == 1:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'def solve_n_queens(N):'+char(10)+N'    board = [[0] * N for _ in range(N)]'+char(10)+N'    if not solve_n_queens_util(board, 0, N):'+char(10)+N'        return None')

,(21, 1, N'def is_prime(n):'+char(10)+N'    if n <= 1:'+char(10)+N'        return False'+char(10)+N'    for i in range(2, n):'+char(10)+N'        if n % i == 0:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'# Тафтиши рақамҳои аз 1 то 100:'+char(10)+N'N = 100'+char(10)+N'for num in range(1, N+1):'+char(10)+N'    if is_prime(num):'+char(10)+N'        print(num, " ин адади оддӣ аст ")'+char(10)+N'    else:'+char(10)+N'        print(num, " ин адади оддӣ нест ")')

,(22, 1, N'def is_prime_optimized_half(n):'+char(10)+N'    if n <= 1:'+char(10)+N'        return False'+char(10)+N'    for i in range(2, n // 2 + 1):'+char(10)+N'        if n % i == 0:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'# Тафтиши рақамҳои аз 1 то 100:'+char(10)+N'N = 100'+char(10)+N'for num in range(1, N+1):'+char(10)+N'    if is_prime_optimized_half(num):'+char(10)+N'        print(num, " ин адади оддӣ аст ")'+char(10)+N'    else:'+char(10)+N'        print(num, " ин адади оддӣ нест ")')

,(23, 1, N'import math'+char(10)+N''+char(10)+N'def is_prime_optimized_sqrt(n):'+char(10)+N'    if n <= 1:'+char(10)+N'        return False'+char(10)+N'    for i in range(2, int(math.sqrt(n)) + 1):'+char(10)+N'        if n % i == 0:'+char(10)+N'            return False'+char(10)+N'    return True'+char(10)+N''+char(10)+N'# Тафтиши рақамҳои аз 1 то 100:'+char(10)+N'N = 100'+char(10)+N'for num in range(1, N+1):'+char(10)+N'    if is_prime_optimized_sqrt(num):'+char(10)+N'        print(num, " ин адади оддӣ аст ")'+char(10)+N'    else:'+char(10)+N'        print(num, " ин адади оддӣ нест ")')

,(24, 1, N'import random'+char(10)+N''+char(10)+N'def quicksort(arr):'+char(10)+N'    if len(arr) <= 1:'+char(10)+N'        return arr'+char(10)+N''+char(10)+N'    # Интихоби унсури дастгирии тасодуфӣ'+char(10)+N'    pivot_index = random.randint(0, len(arr) - 1)'+char(10)+N'    pivot = arr[pivot_index]'+char(10)+N'    # Тақсимоти массив ба се қисм'+char(10)+N'    less = [x for x in arr if x < pivot]'+char(10)+N'    equal = [x for x in arr if x == pivot]'+char(10)+N'    greater = [x for x in arr if x > pivot]'+char(10)+N'    # Ҷобаҷогузории рекурсивии зермассивҳо ва якҷоя кардани натиҷаҳо'+char(10)+N'    return quicksort(less) + equal + quicksort(greater)'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'arr = [3, 6, 8, 10, 1, 2, 1]'+char(10)+N'sorted_arr = quicksort(arr)'+char(10)+N'print("Массиви мураттабшуда:", sorted_arr)')

,(25, 1, N'def fractional_knapsack(weights, values, W):'+char(10)+N'    """'+char(10)+N'    weights: Рӯйхати тарозуи ашё.'+char(10)+N'    values: Рӯйхати арзиши ашё.'+char(10)+N'    W: Иқтидори максималии ҷузвдон.'+char(10)+N'    return: Арзиши максималии ашё дар ҷузвдон.'+char(10)+N'    """'+char(10)+N'    items = [(values[i] / weights[i], weights[i], values[i]) for i in range(len(weights))]'+char(10)+N'    items.sort(reverse=True, key=lambda x: x[0])'+char(10)+N''+char(10)+N'    total_value = 0'+char(10)+N'    for value_per_weight, weight, value in items:'+char(10)+N'        if W == 0:'+char(10)+N'            break'+char(10)+N'        if weight <= W:'+char(10)+N'            W -= weight'+char(10)+N'            total_value += value'+char(10)+N'        else:'+char(10)+N'            total_value += value_per_weight * W'+char(10)+N'            W = 0'+char(10)+N''+char(10)+N'    return total_value'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'weights = [10, 20, 30]'+char(10)+N'values = [60, 100, 120]'+char(10)+N'W = 50'+char(10)+N'print("Арзиши ҳадди аксар (банди хароб ):", fractional_knapsack(weights, values, W))')

,(26, 1, N'def knapsack(weights, values, W):'+char(10)+N'    """'+char(10)+N'    weights: Рӯйхати тарозуи ашё.'+char(10)+N'    values: Рӯйхати арзиши ашё.'+char(10)+N'    W: Максимальная вместимость рюкзака.'+char(10)+N'    return: Арзиши максималии маҷмӯи ашее, ки ба ҷузвдон мувофиқат мекунанд.'+char(10)+N'    """'+char(10)+N'    n = len(weights)'+char(10)+N'    dp = [[0] * (W + 1) for _ in range(n + 1)]'+char(10)+N''+char(10)+N'    for i in range(1, n + 1):'+char(10)+N'        for w in range(1, W + 1):'+char(10)+N'            if weights[i-1] <= w:'+char(10)+N'                dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1])'+char(10)+N'            else:'+char(10)+N'                dp[i][w] = dp[i-1][w]'+char(10)+N'    '+char(10)+N'    return dp[n][W]'+char(10)+N''+char(10)+N'# Пример использования'+char(10)+N'weights = [1, 2, 3]'+char(10)+N'values = [10, 15, 40]'+char(10)+N'W = 5'+char(10)+N'print("Арзиши максималӣ (0/1 бастаи):", knapsack(weights, values, W))')

,(27, 1, N'def min_path_sum(grid):'+char(10)+N'    if not grid or not grid[0]:'+char(10)+N'        return 0'+char(10)+N''+char(10)+N'    m, n = len(grid), len(grid[0])'+char(10)+N'    dp = [[0] * n for _ in range(m)]'+char(10)+N''+char(10)+N'    # Оғози кор'+char(10)+N'    dp[0][0] = grid[0][0]'+char(10)+N''+char(10)+N'    # Оғози сутуни аввал'+char(10)+N'    for i in range(1, m):'+char(10)+N'        dp[i][0] = dp[i-1][0] + grid[i][0]'+char(10)+N''+char(10)+N'    # Оғози сатри аввал'+char(10)+N'    for j in range(1, n):'+char(10)+N'        dp[0][j] = dp[0][j-1] + grid[0][j]'+char(10)+N''+char(10)+N'    # Пур кардани массив dp'+char(10)+N'    for i in range(1, m):'+char(10)+N'        for j in range(1, n):'+char(10)+N'            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])'+char(10)+N''+char(10)+N'    return dp[m-1][n-1]'+char(10)+N''+char(10)+N'# Намунаи истифода'+char(10)+N'grid = ['+char(10)+N'    [1, 3, 1],'+char(10)+N'    [1, 5, 1],'+char(10)+N'    [4, 2, 1]'+char(10)+N']'+char(10)+N'print("Арзиши ҳадди ақали роҳ:", min_path_sum(grid))')

--,(28, 1, N'')

--,(26, 1, N'')

GO


INSERT INTO Users([Name], IsAdmin, [Login], PasswordHash)
VALUES(N'Azimjon', 0, N'anematov2002@gmail.com', N'123')
,(N'Акмалхон Бурхонов', 0, N'b@gmail.com', N'123')
,(N'Шаҳзод', 0, N'shahanshohov01@gmail.com', N'123')
,(N'admin', 1, N'admin', N'admin')

--,(N'', 0, '', '')





GO 



SELECT COUNT(*) AS 'Alg count' FROM Topics WHERE HasChildren = 0